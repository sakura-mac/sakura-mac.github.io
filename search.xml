<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Todo List</title>
    <url>/2020/08/30/Todo-list/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul>
<li><p>完善C++新经典笔记</p>
</li>
<li><p>完善C++对象模型笔记</p>
</li>
<li><p>完成mit-6.828 lab6</p>
</li>
<li><p>csapp lab记录</p>
</li>
<li><p>完善leetcode常用代码模版并</p>
</li>
<li><p>学习hadoop mapreduce</p>
</li>
<li><p>添加解析口来进行影院搭建</p>
</li>
<li><p>添加文章的封面实现</p>
</li>
<li><p>添加毛玻璃特效</p>
</li>
<li><p>xv6翻译</p>
</li>
<li><p>添加个人网盘</p>
<span id="more"></span></li>
</ul>
<p>Test:</p>
<p>1.mp3&#x2F;mp4 player plugin</p>
<ul>
<li>
        <div id="aplayer-fYxmomdQ" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>
			  <script>
				  var options = {"narrow":false,"autoplay":false,"showlrc":0,"mode":"random","music":[{"title":"Blue in green","author":"TheGrimeyHooligan","url":"https://bed1.oss-cn-beijing.aliyuncs.com/mp3/EILmVbUEZZEz.128.mp3","pic":"https://bed1.oss-cn-beijing.aliyuncs.com/202209022020020.png"}]};
				  options.element = document.getElementById("aplayer-fYxmomdQ");
				  var ap = new APlayer(options);
			    window.aplayers || (window.aplayers = []);
				  window.aplayers.push(ap);
			  </script></li>
</ul>
<div id="dplayer0" class="dplayer" style="margin-bottom: 20px;"></div><script>var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":0,"theme":"#FADFA3","loop":0,"video":{"url":"https://pan.baidu.com/play/video#/video?path","pic":"https://i2.hdslb.com/bfs/face/55e59f5ad685340567387450e3a2c315ec6e29b5.jpg@96w_96h_1c.webp"}});</script><!-- dplayer used1 -->

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=73183667&bvid=BV1eE411y7G9&cid=125341177&page=16"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>
]]></content>
      <tags>
        <tag>Todo List</tag>
      </tags>
  </entry>
  <entry>
    <title>摸鱼阅读:No.1</title>
    <url>/2024/03/08/%E6%91%B8%E9%B1%BC%E9%98%85%E8%AF%BB:No.1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>原文</p>
<p>这是一篇介绍故障排除和学习环境（TLEs）AI程序的文章，不过大部分篇幅讲了故障排除需要的技术以及专家和初学者的区别</p>
<span id="more"></span>

<h1 id="故障排除需要的技术"><a href="#故障排除需要的技术" class="headerlink" title="故障排除需要的技术"></a>故障排除需要的技术</h1><p>​	文章认为故障排除主要是一项认知任务，包括通过潜在的大问题寻找可能的故障原因。一般使用流程图和决策表。但是他们通常适用于简单的故障排除问题，如果你想要变得熟练或者精通故障排除，是远远不够的。</p>
<p>​	有经验的故障排除者不是直接对故障进行从头开始的测试，而是首先将故障与他们从经验中过往的故障相匹配，并应用这些经验中的解决方案来解决当前的问题。</p>
<p>​	以下几种系统知识被普遍认为是排除故障的关键</p>
<ul>
<li>专业知识</li>
<li>设备了解</li>
<li>性能测试</li>
<li>排除策略</li>
<li>固有能力</li>
</ul>
<h2 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h2><p>所谓“纸上得来终觉浅，绝知此事要躬行”，专业知识是初学故障排除者的必要条件，但对于学习成为一个合格熟练的故障排除者来说，这并不充分。</p>
<p>不过有意思的是，文章提出初学者通常按照顺序记忆和使用专业知识，而专家则更偏向于以因果关系来记忆，个人认为可以推广为记忆专业知识的相互联系。</p>
<h2 id="系统设备了解"><a href="#系统设备了解" class="headerlink" title="系统设备了解"></a>系统设备了解</h2><p>文章认为，专家和新手排除故障的主要区别在于系统设备知识的数量和组织，即特定范围内的经验丰富与否。</p>
<blockquote>
<p> 当调试电子系统时，David（1983）发现熟练的故障排除者围绕着电气系统中的因果相互作用来组织他们的模型，而不是布线的线性组织</p>
</blockquote>
<p>同样的，在特定设备的了解上，因果关系胜过线性关系。尽管系统的拓扑图和功能关系图都提供了排错路径，但新手故障排除者更可能使用拓扑图搜索策略，而有经验的在排除故障时更经常以功能关系图来思考。基于对设备操作的功能了解的故障排除策略使故障排除者通常能更有效地找到问题。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h2 id="排除策略"><a href="#排除策略" class="headerlink" title="排除策略"></a>排除策略</h2><h2 id="固有能力"><a href="#固有能力" class="headerlink" title="固有能力"></a>固有能力</h2><p>基本上讲了关于工作记忆，问题敏感性，排错策略理解的这些作为人本身的能力。</p>
<h1 id="学习故障排除"><a href="#学习故障排除" class="headerlink" title="学习故障排除"></a>学习故障排除</h1><blockquote>
<p>学生通过复制操作从程序性演示中学习。如果这些具体的操作不能显示出故障，那么按程序教学的学习者就不知道该怎么做。他们缺乏领域原则、系统知识和战略知识，而这些都是排除故障所需要的。</p>
</blockquote>
<p>教导故障排除的内容方法强调对系统的理论和概念理解，与任何故障排除活动无关</p>
<p>故障排除</p>
<p>专家们可以很容易地决定做什么，但他们更不能提供关于他们为什么要这样做的明确规则</p>
<p>专家们根据在构建问题空间和随后的解释过程中获得的初步信息形成他们的初步假设</p>
<p> 如果产生了一个以上的解决方案选项，那么故障排除者必须选择并验证首选的解决方案</p>
<p>概念模型中的这种多层次表述的一个重要理由是，它们可以减少学习者的认知负荷</p>
<p> 然而，提供系统成分和状态的外部表示，通过卸载同时对多个问题成分进行建模的需要，为工作记忆提供支架。能够通过一个复杂的概念模型的不同层次来减少工作记忆的需求，然后可以应用于诊断。—</p>
<p>对于每个案例，确定相关的索引，以便在每种情况下都能召回案例。故障排除案例库中可能的索引包括：。• 具体故障描述• 观察到的最初症状• 发生的频率• 隔离故障所需的行动、程序• 检验的假设• 各种测试的结果• 地形部分• 职能目的• 解决方案战略</p>
<p>对于熟练的执行者和专家来说，诊断成为一种分类活动，在这种活动中，故障排除者搜索他们的事件模式，以便识别不同的故障状态。学习排除故障代表着从对系统的概念性理解到对过程的经验性理解的转变</p>
]]></content>
      <tags>
        <tag>Essay note</tag>
      </tags>
  </entry>
  <entry>
    <title>数学二笔记</title>
    <url>/2024/03/08/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最重要的是一种必要性：笔记掌握不一定解出题，但是题解一定用到了笔记里的内容</p>
<h1 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h1><span id="more"></span>

<p>不等式<br>1 函数，泰勒，可以通过常数变易来确定函数再到极值（给出一题，另2022证明题也可以）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212121132222.png"><br>2 保号性（连续或者极限），第一种普通，第二种：<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212061316904.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212101338188.png"><br>3 所有可能情况下的放缩(如果不行可能是放的不行，而不是否定这个可能)</p>
<ul>
<li>基本不等式的放缩</li>
<li>分子&#x2F;分母&#x2F;乘积部分放缩</li>
<li>第一步或者第二步再放缩</li>
</ul>
<p>常见不等式：</p>
<ul>
<li><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202210131807718.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211271312491.png"></li>
<li>均值不等式（2）</li>
<li>柯西不等式（2）？</li>
<li>绝对值不等式</li>
<li>积分不等式（内大外小）</li>
</ul>
<p>恒等变形</p>
<ul>
<li>基本函数变形</li>
<li>三角函数变形</li>
<li>拉格朗日中值定理</li>
<li>定积分性质<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202210131808883.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212142144147.png"></li>
<li>积分中值定理（2）</li>
<li>积分对称性（区域轴+函数轴（奇偶））<ul>
<li>区域对称：区间再现</li>
<li>函数对称：区域减半，合并</li>
<li>区域拼凑<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212171327210.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212171325181.png"></li>
</ul>
</li>
<li>积分周期性<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212101333176.png"></li>
</ul>
<h1 id="口诀和笔记"><a href="#口诀和笔记" class="headerlink" title="口诀和笔记"></a>口诀和笔记</h1><h2 id="函数数列"><a href="#函数数列" class="headerlink" title="函数数列"></a>函数数列</h2><p>暂不填写</p>
<p>1 特殊曲线图像</p>
<p>  <img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211151015559.png"></p>
<p>  <img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211212234280.png"></p>
<p>2 数列：归纳（猜），递推</p>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>函数极限：等泰洛导夹</p>
<p>化简技巧：合拆变换抓</p>
<p>数列极限：夹定拉</p>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>极限</p>
<p>1 分子二重积分，可以洛必达则设而不求原函数，不可以则交换积分次序<br>2 连乘应该用指数变换变为连加，连加可能是定积分定义<br>3 夹定拉里的夹：看放缩要点<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212171327947.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212171329081.png"><br>4 数列直接求极限确定情况，可以先求极限然后和端点值对比得到</p>
<ul>
<li>不会证极限用数列极限口诀</li>
<li>不会证有界用归纳或者递推</li>
<li>不会证单调直接跳过（分值不大）</li>
<li>一步到位的递推：（绝对值递推|xn - a| &lt; A|xn-1 - a|, A from(0,1)）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212101332903.png"></li>
</ul>
<p>等价无穷小比较<br>1 简单上限积分泰勒展开，但是从等价无穷小来找更快，求导等价无穷小来推原函数等价无穷小</p>
<p>2 复杂上限积分基本公式<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212121125549.png"></p>
<p>注意：</p>
<ul>
<li>趋于无穷的极限不过，就这几个</li>
</ul>
<p>$$<br>lim_{n-&gt;\infty}\sqrt[n]{n} &#x3D; 1 \ &lt;&#x3D;&gt;<br>lim_{n-&gt;\infty}\frac{lnn}{n} &#x3D; 0 \<br>lim_{n-&gt;\infty}\sqrt[n]{a} &#x3D; 1 \<br>lim_{n-&gt;\infty}(1-\frac{1}{x})^x &#x3D; e<br>$$</p>
<ul>
<li>提前化简：指数函数x-&gt;0或者x在x-&gt;1时可以直接化简</li>
<li>凑等价无穷小：由于小题必定等价无穷小或者洛必达，并且前者更常见，因此思考凑，比如$e^{tanx} - e^x  &#x3D; e^x(e^{tanx-x}-1) ～ tanx - x$</li>
<li>洛必达通常在第二步，因此如果能够让求导更容易就先化简，分子最小的无穷小必须高阶于分母无穷小才能洛必达（0是永恒的高阶无穷小）。原因很简单，泰勒展开的条件就是无穷小能够高阶达到为0，否则$\frac{o(x)+o(x^2)}{x^2}$消不掉<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212111408628.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212111425910.png"></li>
<li>放缩求极限即夹逼<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212191159867.png">，也要额外记一个公式<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211271316872.png"></li>
</ul>
<h2 id="不等-x2F-等式证明"><a href="#不等-x2F-等式证明" class="headerlink" title="不等&#x2F;等式证明"></a>不等&#x2F;等式证明</h2><p>不等式<br>2.构造函数的极值<br>等式<br>1.单中值定理：罗尔（证导数为0）&#x2F;拉&#x2F;柯<br>    构造：观察（加减乘除求导）&#x2F;公式法<br>2.双中值定理：拉拉，罗拉，拉柯<br>    构造：找到三个端点<br>3.泰勒公式<br>    注意误差为n+1次	，可能会搭配介值定理来不恒等变形</p>
<h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3><p>技巧：<br>1.定积分用积分中值定理<br>2.上限积分用洛必达&#x2F;泰勒<br>3.导数定义<br>4.极限存在且分母极限为0则分子极限为0<br>5.连续则有最大最小值的介值定理，介值定理只讨论端点<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212101332548.png"></p>
<p>注意：方程左右两边绝对值，实际上只是一个绝对值（因为正负抵消），而不等式则有四种</p>
<h2 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h2><h3 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h3><p>考点：微分方程，全微分，链式法则，隐函数，积分，定义</p>
<ul>
<li><p>一元求导：定构方高</p>
</li>
<li><p>多元求导：微练拳击</p>
</li>
</ul>
<h3 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h3><p>1 订购方高里的构造：函数和一阶导数是罗尔或者基本运算（后者反而更简单更容易忽略），函数值和一阶导数关系是拉格朗日，高阶是泰勒</p>
<p>2 隐函数：直接或者存在定理（存在定理确定了函数连续可导）</p>
<p>3 微不是全微分，是微分定义</p>
<p>4 求导对于对称性里的奇偶性影响<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211212224635.png"></p>
<p>5 方是方程，微分方程最重要的就是函数的求导和微分之间关系</p>
<p>6 高阶导数的泰勒和莱布尼兹里，通过推理来局部&#x2F;整体使用，各给出一个例子<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212101342080.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212142124949.png">7 二元偏导从一元导数角度考虑（积也算是一种想法)：<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212111452788.png"></p>
<h2 id="连续间断"><a href="#连续间断" class="headerlink" title="连续间断"></a>连续间断</h2><p>1 分段函数，分类讨论的左右极限</p>
<p>2 连续可以推出介值定理，中值定理，零点定理，最大最小值定理等各种定理</p>
<h2 id="渐近线"><a href="#渐近线" class="headerlink" title="渐近线"></a>渐近线</h2><p>1 三类渐近线分类讨论，极限只要单侧满足即可，具体求则两个都要看</p>
<p>2 斜渐近线：f(x)&#x2F;x极限为a，f(x)-ax极限为b。从而求出答案</p>
<h2 id="驻点极值拐点"><a href="#驻点极值拐点" class="headerlink" title="驻点极值拐点"></a>驻点极值拐点</h2><p>1.极值点充要邻域最值，并非存在一阶导数。如果可导则有两个充分判定，第一个更普遍（左右异号或者单调）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212132220091.png"></p>
<p>2 拐点（凹凸性变化）两个有充分判定，第一个更普遍（左右异号）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212191159543.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212121127022.png"></p>
<h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><p>无穷和瑕是f(x)的0和无穷，而不是原函数，原函数极限存在则反常积分收敛</p>
<p>题型大概率拆分成一个反常积分一个瑕积分，可以代点再判断收敛</p>
<p>判定：</p>
<ul>
<li><p>比较审敛法：大收小收，小发大发</p>
</li>
<li><p>&#x3D;&gt;极限审敛法（0&#x2F;0型）</p>
</li>
<li><p>$lim_{x-&gt;\infty}f(x)<em>x^p&#x3D;? \ or \ lim_{x-&gt;a+}f(x)</em>(x-a)^p&#x3D;? \ 0收，无穷发，其余同敛散$</p>
</li>
<li><p>要求：左区间标记：无穷闭点发散，瑕开点收缩</p>
</li>
</ul>
<p>常见反常积分：</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212041003985.png"></p>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>一道同样的题可能从导数角度和积分角度考虑。</p>
<h3 id="口诀-1"><a href="#口诀-1" class="headerlink" title="口诀"></a>口诀</h3><ul>
<li><p>化：中性区导</p>
</li>
<li><p>一重积分：化一分二</p>
</li>
<li><p>二重积分：极一交</p>
</li>
<li><p>证明：最大最小值，泰勒？，中值定理，求导</p>
</li>
</ul>
<h3 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h3><p>注意：</p>
<ul>
<li>换元：碰到绝对值注意前提，同时不是单调则不应该代入端点</li>
<li>第二类换元有三角换元（针对根号内平方差），和x&#x3D;pi-t, x&#x3D;pi&#x2F;2 -t（针对修改上下限）</li>
<li>arcsinsinx &#x3D; x, pi-x的分类讨论</li>
<li>对于上限积分，要么求导要么原函数，<ul>
<li>原函数要么性质（比fx积分连续可导条件强（原函数定义就是可导））要么分段，不管怎样一定会求积分或者导数</li>
<li>求导必须看清是f(u)或者xf(u)，否则f(u, x)必须换元</li>
</ul>
</li>
<li>分步积分：反对幂三指为u，v可以是dv的任何一个原函数，比如2x得到x^2+c，c根据题目给的确定。例子：<ul>
<li>$\int \frac{x^n}{1+x^n}dx$,$\int \frac{x}{1+x^2}dx$</li>
<li><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212142112551.png"></li>
</ul>
</li>
<li>从上部分也可看出来分步积分目的是消元（存在求导部分或者x * 1&#x2F;x），降次，化简。</li>
<li>去根号：根号内或者根号的第一类换元，三角第二类换元</li>
<li>积分奇偶性</li>
<li>有理函数积分拆分是(f(x))^k拆k个：从1-&gt;k；三角有理函数拆分必须是最简单的三角函数</li>
</ul>
<p>一重积分</p>
<p>1 区间函数一个不同比较 ：内部比较：不等式口诀。外部比较：对称性周期性出口成章<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212181338836.png"><br>2 被积函数有导数的定积分，可以用分步积分<br>3 使用分步积分和设而后求</p>
<p>二重积分</p>
<p>1 中性区导可以用到中性区，性质包括了对称性，没看到过周期性，还有极坐标的换元，华里士公式，形心公式。区域可加性时，一般用两种解法（极坐标+直角）<br>2 给定累次积分想到交换次序（交换次序为了避免计算），给极坐标想直角坐标，给直角坐标想极坐标<br>3 极坐标交换次序只考过强形式的<br>4 累乘比交换次序形式更强<br>5 复杂累次积分可能设而后求，紧接着也可能通过“性”来化简</p>
<h2 id="定积分应用题"><a href="#定积分应用题" class="headerlink" title="定积分应用题"></a>定积分应用题</h2><h3 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h3><p>静：三种体积（柱，环，极），两种面积（侧，环），形心公式（从离散推起）,水中受力<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211212145199.png"></p>
<p>动：确定<strong>抽象函数</strong>，从微分（可能使用链式法则）到题问变量的<strong>方程</strong>，得到微分方程求解（毕竟是定积分）</p>
<p>注意：</p>
<ul>
<li>做工，压强，体积面积，质心等物理定积分，变化率即求导<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211251725335.png"></li>
</ul>
<h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><h3 id="口诀-2"><a href="#口诀-2" class="headerlink" title="口诀"></a>口诀</h3><ul>
<li><p>一：换构分公</p>
</li>
<li><p>高：降常</p>
</li>
</ul>
<h3 id="笔记-5"><a href="#笔记-5" class="headerlink" title="笔记"></a>笔记</h3><p>注意：微分方程公式法里的积分不加C，vdv &#x3D; xdx不是公式法</p>
<p>1.解的结构：</p>
<ul>
<li>齐次解：n阶方程即n个非零无关特解线性组合<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211212233899.png"></li>
</ul>
<p>注意：易错为r1 &#x3D; r2 &#x3D; r3 &#x3D; 1<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211212233530.png"></p>
<p>2.解的结论：<img src="/Users/khalilchen/Library/Application%20Support/typora-user-images/image-20221213221834211.png" alt="image-20221213221834211"></p>
<ul>
<li>非 &#x3D; 非+齐</li>
<li>齐 &#x3D; 齐+齐</li>
<li>非的01系数比</li>
</ul>
<p>3 数学二会使用微分方程求出函数f(x)，然后随你怎么玩</p>
<p>4 注意题目给的条件一定可以用到，不能莽撞<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212121135106.png"></p>
<h2 id="极值最值"><a href="#极值最值" class="headerlink" title="极值最值"></a>极值最值</h2><p>1 一元极值不代表可导，可能是有定义的间断点</p>
<p>2 二元无条件极值通过一阶来求，二阶只是证明是否算极值，太难可以忽略</p>
<p>3 二元条件极值为拉格朗日乘数法</p>
<p>4 最值要代入边界来转化为一元极值</p>
<h2 id="线代做题"><a href="#线代做题" class="headerlink" title="线代做题"></a>线代做题</h2><p>考虑性质：从向量到向量组，从行列式到矩阵</p>
<h3 id="口诀-3"><a href="#口诀-3" class="headerlink" title="口诀"></a>口诀</h3><p><strong>行列式</strong>：特相拉变</p>
<p><strong>相似关系</strong>：极值函角特行（迹秩函角特行）</p>
<p><strong>特征值</strong>：行相量特行，函角惯性（函即特征值的函数，方程可整理为0矩阵从而得到特征值0）</p>
<p><strong>高阶矩阵</strong>：归纳，递推法，相似对角化（高阶矩阵对应数列，求不出通项求递推式）,特征向量的函<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212171336390.png"></p>
<p><strong>秩</strong>：转零函分满。给出函的情况：（矩阵函数为乘，通过方程或本身乘积，存在秩不等式）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212111438765.png"></p>
<p><strong>正交矩阵</strong>：定义，实对称，逆</p>
<p><strong>二次型正定</strong>：特顺，正正P（* 特征值，* 顺序主子式，惯性正，*二次型正，A&#x3D; P^{T}P？）（给出二次型正的不常见用法<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212101340066.png"></p>
<p> <strong>线性方程组的解</strong>：莱特零</p>
<h3 id="笔记-6"><a href="#笔记-6" class="headerlink" title="笔记"></a>笔记</h3><p>1 求矩阵：</p>
<ul>
<li>矩阵函数（基变换：相似，合同）</li>
<li>特征向量（矩阵化）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212161134082.png"></li>
<li>解向量18年（AX&#x3D;B）</li>
<li>猜向量（正交）<img src="/Users/khalilchen/Library/Application%20Support/typora-user-images/image-20221211151041129.png" alt="image-20221211151041129"></li>
</ul>
<p>2 相似充要：定义&#x2F;相同特征值&#x2F;特征多项式+特征空间相等（实对称阵不需要，肯定等），或者使用相似对角阵传递性 </p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202211151636976.png"></p>
<p>3 实对称阵：</p>
<ul>
<li>AA^T就是实对称矩阵</li>
<li>充要为正交对角化，也就是充要为正交特征向量</li>
<li>不同特征值的特征向量相互正交</li>
<li>拉格朗日配方法：就是可逆线性变换，只要保证矩阵满秩即可</li>
</ul>
<p>4 初等矩阵：倍加交换内数乘</p>
<ul>
<li>转置：变化括号外</li>
<li>逆：变化括号内</li>
<li>伴随：除了倍加相等，其余的都改变</li>
</ul>
<p>5 合同关系：定义&#x2F;充要（惯性定理+同对称）</p>
<ul>
<li>性质：传递性，惯性指数相同，累加的r相同？</li>
</ul>
<p>6 向量组线性无关</p>
<ul>
<li>定义</li>
<li>行列式（秩）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212181339425.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212181340149.png"></li>
<li>推理+定义<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212181331600.png"></li>
</ul>
<p>7 秩</p>
<ul>
<li>复合矩阵的秩(A m*n)：r(A) + r(B) -n &lt;&#x3D; r(AB) &lt;&#x3D; min{r(A), r(B)}</li>
<li>分块矩阵的秩：max{r(A), r(B)}&lt;&#x3D; r(A, B) &lt;&#x3D; r(A) + r(B)</li>
<li>r(A + B) &lt;&#x3D; r(A) + r(B)</li>
<li>可以通过非零子式来辅助判断计算是否正确</li>
<li>满秩只有唯一零解</li>
<li>等价：rA&#x3D;rB&#x3D;左右分块大矩阵的秩</li>
<li>同解：rA&#x3D;rB&#x3D;上下分块大矩阵的秩，即行向量组等价</li>
<li>公共解：上下分块ABx函数有解？</li>
</ul>
<p>8 二次型：</p>
<ul>
<li>正负惯性指数和为秩</li>
<li>惯性指数被特征值正负决定</li>
<li>矩阵的A可以拆开重组</li>
</ul>
<p>9 线性方程组</p>
<ul>
<li>解向量：和A行向量正交，齐次则作为A的特征值为0的特征向量</li>
<li>克莱默法则求唯一解</li>
<li>A的列空间是值域空间</li>
<li>因此得到秩零定理<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212142012993.png"></li>
</ul>
<h1 id="陌生题型"><a href="#陌生题型" class="headerlink" title="陌生题型"></a>陌生题型</h1><ul>
<li>联想，题问，第一小问</li>
<li>化定，以退为进</li>
</ul>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>工具链配置</title>
    <url>/2024/03/08/%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><p>前提：对unix的shell有一定的认识，否则可以观看<a href="https://www.youtube.com/watch?v=tc4ROCJYbm0">视频</a>或者自行了解关于文件目录和命令行知识，对于配置报错应该认知到问题在哪，对症下药</p>
<p>参考官网：<a href="https://pdos.csail.mit.edu/6.828/2017/tools.html">https://pdos.csail.mit.edu/6.828/2017/tools.html</a></p>
<span id="more"></span>

<p>基本环境：mac下vmware fusion8 + ubuntu20.04+python2.7</p>
<p>工具链：测试得知环境为64位,进行32位补丁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<p>qemu模拟器安装编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://web.mit.edu/ccutler/www/qemu.git -b 6.828-2.3.0                               <span class="comment">#如果你报错根据报错提示安装git即可</span></span><br><span class="line"></span><br><span class="line">./configure --disable-kvm --disable-werror --target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span><span class="comment">#qemu目录下</span></span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install<span class="comment">#make install是必须的，如果遇到permission denied则加入sudo来临时增加权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>报错：</p>
<ol>
<li><p>configure配置时lib缺失等工具链不完善，则根据报错进行搜索,比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache search glib</span><br></pre></td></tr></table></figure>

<p>根据搜索结果决定安装，给出部分情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">glib: sudo apt-get install libglib2.0-dev<span class="comment">#dev就没错</span></span><br><span class="line"></span><br><span class="line">libtool : sudo apt-get install libtool-bin <span class="comment">#这个libtool broken报错在第一行，很容易错过没发现</span></span><br><span class="line"></span><br><span class="line">pixman: sudo apt-get install libpixman-1-dev　　</span><br><span class="line"></span><br><span class="line">zlib: sudo apt-get intall zlib1g-dev</span><br><span class="line"></span><br><span class="line">c++ compiler: sudo apt-get install g++</span><br></pre></td></tr></table></figure>


</li>
<li><p>Make编译错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: qga/commands-posix.o: <span class="keyword">in</span> <span class="keyword">function</span> `dev_major_minor<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">/home/yunwei/qemu/qga/commands-posix.c:633: undefined reference to `major&#x27;</span> &amp;&amp;</span><br><span class="line">/usr/bin/ld: /home/yunwei/qemu/qga/commands-posix.c:634: undefined reference to `minor<span class="string">&#x27;</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure>

<p>找到major和min函数的头文件，在相应commands-posix.c文件下进行头文件导入 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/sysmacros.h&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果make install之后最后几行显示命令和相应的目录，则可视为配置成功<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211112780.png"></p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>基本工具使用</title>
    <url>/2024/03/08/%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<p>首先清楚我们的实验大致流程：</p>
<ol>
<li>编写代码（可能）</li>
<li>编译内核</li>
<li>调试或者查看os</li>
</ol>
<p>因此给出以下基本工具&#x2F;文件的介绍和基本使用</p>
<span id="more"></span>

<h2 id="编译makefile"><a href="#编译makefile" class="headerlink" title="编译makefile"></a>编译makefile</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.在你的<span class="built_in">clone</span>文件夹下</span><br><span class="line">make qemu</span><br><span class="line">编译你的内核并运行qemu硬件模拟你的os，如果没有新改动，会编译非常快，</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">清除你的编译内核，以便于重新编译</span><br><span class="line"></span><br><span class="line">make qemu-nox</span><br><span class="line">与上面的唯一区别就是上面的会给出一个窗口，下面这个几乎没什么显示内容，ssh时候方便用</span><br><span class="line"></span><br><span class="line">make qemu-gdb</span><br><span class="line">一开始的实验最常用，他会等待接受gdb的到来</span><br><span class="line"></span><br><span class="line">make qemu-nox-gdb</span><br><span class="line">等同于 make-gdb &amp;&amp; make-nox</span><br><span class="line"></span><br><span class="line">make run-name</span><br><span class="line">运行用户进程：usr/hello.c 下的编译运行，lab3后会使用</span><br><span class="line"></span><br><span class="line">make run-name-nox, run-name-gdb, run-name-gdb-nox,</span><br><span class="line">nox含义等同于前面</span><br><span class="line"></span><br><span class="line">make V=1 ...</span><br><span class="line">列出所有的执行命令和参数</span><br><span class="line"></span><br><span class="line">make V=1 grade</span><br><span class="line">grade失败后退出，日志在jos.out可以查看</span><br><span class="line"></span><br><span class="line">make QEMUEXTRA=<span class="string">&#x27;args&#x27;</span> ...</span><br><span class="line">指定给qemu额外的参数</span><br></pre></td></tr></table></figure>

<h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><p>硬件模拟器，你可以认为你的os在qemu上运行。想要退出：ctrl + a 和 x,需要注意ctrl 与 a同时按住抬起后再按c,不要三个键同时按</p>
<p>同时qemu也类似gdb可以给你一些调试信息查看:ctrl+a和c进入qemu模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xp/Nx paddr</span><br><span class="line">从指定的物理地址开始显示N个字，默认N=1</span><br><span class="line"></span><br><span class="line">info registers</span><br><span class="line">寄存器的信息，例子：CS =0008 10000000 ffffffff 10cf9a00 DPL=0 CS32 [-R-]</span><br><span class="line">						     cs选择子  段基址     段限长    线性地址   权限  32位  只读</span><br><span class="line">						     </span><br><span class="line">info mem</span><br><span class="line">lab2+内存信息，例子：ef7c0000-ef800000 00040000 urw</span><br><span class="line">						 efbf8000-efc00000 00008000 -rw</span><br><span class="line">						 </span><br><span class="line">info pg</span><br><span class="line">lab2+多进程页表结构，PDE做base，PTE做offset找到一个页表。进程页表查找过程：cr3-PDE-PTE。例子：</span><br><span class="line">VPN range     Entry         Flags        Physical page</span><br><span class="line">[00000-003ff]  PDE[000]     -------UWP//一个进程</span><br><span class="line">  [00200-00233]  PTE[200-233] -------U-P 00380 0037e 0037d 0037c 0037b 0037a ......</span><br><span class="line">[00800-00bff]  PDE[002]     ----A--UWP//另一个进程</span><br><span class="line">  [00800-00801]  PTE[000-001] ----A--U-P 0034b 00349</span><br><span class="line">  [00802-00802]  PTE[002]     -------U-P 00348</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">make QEMUEXTRA=<span class="string">&#x27;-d int&#x27;</span> ...</span><br><span class="line">记录所有int中断信息，举例：</span><br><span class="line">4: v=30 e=0000 i=1 cpl=3 IP=001b:00800e2e pc=00800e2e SP=0023:eebfdf28 EAX=00000005</span><br><span class="line">EAX=00000005 EBX=00001002 ECX=00200000 EDX=00000000</span><br><span class="line">ESI=00000805 EDI=00200000 EBP=eebfdf60 ESP=eebfdf28</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="JOS内核"><a href="#JOS内核" class="headerlink" title="JOS内核"></a>JOS内核</h2><p>内核编译之后，额外会产生一些文件：比如反汇编得到汇编文件等，让你更方便查看内核具体的情况。</p>
<p>obj目录下，分别有一些值得关注的目录：usr, boot, kernel</p>
<p>你可以使用gdb单独调试他们，来获得更短小方便的调试体验</p>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>当你第一次使用make qemu-gdb后，你应该再开一个同样路径的窗口运行make-gdb，这样就开始了第一次的实验调试。给出以下常见的gdb调试命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b <span class="keyword">function</span> or b file:line (or breakpoint)</span><br><span class="line">设置一个断点，运行后会停在这里中断执行,例子：b main</span><br><span class="line"></span><br><span class="line">b *addr (or breakpoint)</span><br><span class="line">也可以指定指令的地址，例子：b * 0x7c00</span><br><span class="line"></span><br><span class="line">c（or <span class="built_in">continue</span>）</span><br><span class="line">运行</span><br><span class="line"></span><br><span class="line">si(or stepi)</span><br><span class="line">单汇编指令执行</span><br><span class="line"></span><br><span class="line">&lt;回车键&gt;</span><br><span class="line">重复执行上一条指令</span><br><span class="line"></span><br><span class="line">quit</span><br><span class="line">退出gdb</span><br><span class="line"></span><br><span class="line">//接下来是稍微复杂一点的命令</span><br><span class="line"><span class="built_in">set</span>命令</span><br><span class="line">	<span class="built_in">set</span> <span class="built_in">print</span> address on/off 显示/不显示进入函数的地址，默认开袋</span><br><span class="line">	<span class="built_in">set</span> <span class="built_in">print</span> pretty on/off 打开或者关闭pretty模式，这样会影响结构体显示的美观程度</span><br><span class="line">	<span class="built_in">set</span> <span class="built_in">print</span> array on/off 打开则一个元素一行</span><br><span class="line">show命令：如果只是想查看上述显示的效果，替换<span class="built_in">set</span>，删除on/off即可</span><br><span class="line"></span><br><span class="line">info registers</span><br><span class="line">显示寄存器的值</span><br><span class="line"></span><br><span class="line">i r eip/eax</span><br><span class="line">更精准显示寄存器的值</span><br><span class="line"></span><br><span class="line">x/Nx addr</span><br><span class="line">显示地址开始的N个字，1.如果想要以字节形式，在末尾x加b，2.如果想使用寄存器，比如esp/ebp，将addr替换为<span class="variable">$esp</span>即可查看指向的指令字</span><br><span class="line"></span><br><span class="line">x/Ni addr</span><br><span class="line">以指定地址开始显示N条汇编指令（instructions）</span><br><span class="line"></span><br><span class="line">symbol-file file</span><br><span class="line">lab3开始：转向执行指定的文件，例子：symbol-file obj/usr/hello，或者你直接简写为file obj/usr/hello</span><br><span class="line"></span><br><span class="line">//线程部分</span><br><span class="line">thread n</span><br><span class="line">关注某个线程（0开始）</span><br><span class="line"></span><br><span class="line">info threads</span><br><span class="line">线程信息</span><br></pre></td></tr></table></figure>

<h2 id="Objdump"><a href="#Objdump" class="headerlink" title="Objdump"></a>Objdump</h2><p>反汇编工具，包括但不限于：提供反汇编代码文件，查看完整的ELF，查看ELF头，查看ELF section table等功能，给出以下代码，但是忘了可以通过 man objdump来回忆</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obdjump -d file反汇编文件代码部分</span><br><span class="line">objdump -h file查看ELF文件头：魔数，main入口，</span><br><span class="line">objdump -x file查看ELF所有头：file header, section headers, program headers，不建议一开始用</span><br><span class="line">objdump -h file查看ELF节头：section个数，地址，等信息</span><br><span class="line"></span><br><span class="line">补充：ELF格式：我们关注两个个header，section header，（programheader是section header的执行文件层面的一体两面表述）</span><br><span class="line">1.ELF header文件头：所有section headers的base/offset等</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x1050</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          14768 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         11</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         29</span></span><br><span class="line"><span class="string">  Section header string table index: 28</span></span><br><span class="line"><span class="string">2.ELF section header：所有布局上section的信息</span></span><br><span class="line"><span class="string">Section Headers:</span></span><br><span class="line"><span class="string">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span><br><span class="line"><span class="string">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span></span><br><span class="line"><span class="string">  [ 1] .interp           PROGBITS        00008154 000154 000019 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 2] .note.ABI-tag     NOTE            00008170 000170 000020 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 3] .note.gnu.build-i NOTE            00008190 000190 000024 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 4] .gnu.hash         GNU_HASH        000081b4 0001b4 000024 04   A  5   0  4</span></span><br><span class="line"><span class="string">  [ 5] .dynsym           DYNSYM          000081d8 0001d8 000040 10   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 6] .dynstr           STRTAB          00008218 000218 00003c 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 7] .gnu.version      VERSYM          00008254 000254 000008 02   A  5   0  2</span></span><br><span class="line"><span class="string">  [ 8] .gnu.version_r    VERNEED         0000825c 00025c 000020 00   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 9] .rel.dyn          REL             0000827c 00027c 000008 08   A  5   0  4</span></span><br><span class="line"><span class="string">  [10] .rel.plt          REL             00008284 000284 000018 08   A  5  12  4</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6教程笔记</title>
    <url>/2024/03/08/xv6%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>



<h1 id="xv6教程笔记"><a href="#xv6教程笔记" class="headerlink" title="xv6教程笔记"></a>xv6教程笔记</h1><p><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf">xv6教程原版</a></p>
<p><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/xv6-rev10.pdf">xv6源代码</a></p>
<p>Todo：剩余部分的翻译</p>
<h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><p>我们将会通过学习xv6的内核，来完成对操作系统的通用学习。阅读中有疑问请配合<a href="https://pdos.csail.mit.edu/6.828/2017/xv6/xv6-rev10.pdf">源代码</a>学习，所有的源代码全部都是由C构成。本个教程涵盖了所有lab的大部分知识，所以请结合实验需求，计划阅读相应章节。</p>
<span id="more"></span>
<h2 id="0：操作系统接口"><a href="#0：操作系统接口" class="headerlink" title="0：操作系统接口"></a>0：操作系统接口</h2><p>操作系统接口的设计目的就是通过对硬件的抽象，来获得更好的体验。抽象有以下需求：</p>
<ol>
<li><p>对逻辑抽象</p>
</li>
<li><p>多路复用硬件</p>
</li>
<li><p>程序互动，包括资源共享等</p>
</li>
</ol>
<p>用户通过系统接口来使用操作系统，系统接口的设计有以下需求</p>
<ol>
<li><p>KISS原则</p>
</li>
<li><p>易实现</p>
</li>
<li><p>功能可扩展</p>
</li>
</ol>
<p>xv6是一个类UNIX系统，实际上UNIX更像一个标准而不是一个系统，因此了解xv6，对于Linux，MAC等类UNIX系统有帮助，比如内核中同样的系统调用命名或者实现等等</p>
<pre><code>//给出一些系统调用，你应该知道这些调用的意义和使用场景
System call Description
fork() 											Create a process
exit() 											Terminate the current process
wait() 											Wait for a child process to exit
kill(pid) 									Terminate process pid
getpid() 										Return the current process’s pid
sleep(n) 										Sleep for n clock ticks
exec(filename, *argv) 			Load a file and execute it
sbrk(n) 										Grow process’s memory by n bytes
open(filename, flags) 			Open a file; the flags indicate read/write
read(fd, buf, n) 						Read n bytes from an open file into buf
write(fd, buf, n) 					Write n bytes to an open file
close(fd) 									Release open file fd
dup(fd) 										Duplicate fd
pipe(p) 										Create a pipe and return fd’s in p
chdir(dirname) 							Change the current directory
mkdir(dirname) 							Create a new directory
mknod(name, major, minor) 	Create a device file
fstat(fd) 									Return info about an open file
link(f1, f2) 								Create another name (f2) for the file f1
unlink(filename) 						Remove a file
</code></pre>
<p>进程的概念：进程即运行的程序，所以二者的关系为先有进程后有程序。一个进程包含了程序的指令（代码），数据，栈。而前者通常有相当一部分内容是使用栈来保存。因此一个进程的创建，或者相似概念的某些创建，必须要先开辟一个栈帧，借以组织各种调用和存储。</p>
<p>用户态和内核态：当一个进程使用内核服务的时候，他会调用系统接口，紧接着从用户态转入内核态，即必须进入”中断“，进而执行内核的指令，最后返回到用户态。因此一个进程的栈包含了用户空间和内核空间。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/008i3skNgy1gulvk2lo35j60dl0520sp02.jpg"></p>
<p>CPU的保护模式来确保每个进程可以访问修改自己的一片空间，而不是突然进入其他进程内。这实际上也是一种抽象：即用户态和内核态一层，内存一层。这样的抽象需要地址转换来实现。这涉及到了虚拟内存的知识。留个问题：进程真的完全不同相互访问吗？如果是真的那么不同的进程进入内核态是一致的吗？</p>
<p>Ps：如果现在不了解很正常，当你理解内存管理和进程后，这个问题就会变的非常简单。</p>
<p>接下来的章节讲述了xv6的服务：</p>
<ol>
<li><p>进程</p>
</li>
<li><p>内存</p>
</li>
<li><p>描述符（多种）</p>
</li>
<li><p>管道</p>
</li>
<li><p>文件系统</p>
<p>并且教会你如何使用shell的代码来使用他们，同时也希望你结合源代码来理解实现逻辑。shell实际上就是你的cmd或者terminal。这是一个用户程序，你通过shell来直观地访问内核服务。</p>
</li>
</ol>
<h3 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h3><p>​	对于多进程来说，调度是一个很正常的事：我们采用的方法是进程之间时间同步，根据时间片来决定调度。在单核（单CPU）前提下，当一个进程切换为另一个进程时，当前进程会被挂起，这意味着CPU的寄存器和一些其他的会被保存，等待接下来的某个时刻，通过pid来辨识，重新切换回来。</p>
<p>​	进程的创建依赖于一个叫做fork的系统调用，即父进程通过调用fork来创建一个子进程，由于某些历史原因，子进程一开始并不是我们想要的那些程序代码或者数据，而是除了pid，内存部分引用父进程。因此还需要一些其他的系统调用来正确地回到我们要的“进程”中（exec等）。同时我可以保证，子进程只是暂时引用了父进程的内存，很快它便会使用“copy on wirte”技术，得到独立于父进程的内存空间。所以，子进程的活动不影响父进程的内存。</p>
<pre><code>//给出创建子进程的一个实例：得到同样的进程代码执行，根据pid的不同来识别父，子进程
int pid = fork();
if(pid &gt; 0)&#123;
printf(&quot;parent: child=%d\n&quot;, pid);
pid = wait();
printf(&quot;child %d is done\n&quot;, pid);
&#125; else if(pid == 0)&#123;  //注意
printf(&quot;child: exiting\n&quot;);
exit();
&#125; else &#123;
printf(&quot;fork error\n&quot;);
&#125;
</code></pre>
<p>我们除了fork还关注两个系统调用</p>
<ul>
<li><p>wait：父进程将等待，直到子进程调用exit结束，得到子pid</p>
</li>
<li><p>exit：结束进程，释放内存资源</p>
</li>
<li><p>exec：执行新的部分</p>
</li>
</ul>
<p>注意：父进程和子进程的输出顺序并不是绝对的，我们可以很简单地认为随机。比如子进程执行了一行，父进程执行了一行，这样。输出往往看上去很混乱。这里也为后面的锁的实现提供了需求。</p>
<p>同时再强调一遍，虽然fork导致的父子进程几乎完全一样，代码执行位置也一样（所以才只通过pid判断），但是二者的活动互不相关，寄存器，用户态内存，等都可以认为相互独立。</p>
<p>接下来来讨论exec部分，将子进程执行我们想要的正确程序是一件很重要的事，因此exec就承担了这个责任：</p>
<ul>
<li><p>使用ELF格式文件</p>
</li>
<li><p>告诉CPU新的代码，数据，执行起点等信息</p>
</li>
<li><p>一旦开始执行，就不再返回</p>
<pre><code>//给出exec实例，其中exec函数接收两个参数：1.文件位置 2.传入的字符串参数
char *argv[3];
argv[0] = &quot;echo&quot;;//注意：第一个指针通常被忽略，默认认为是文件名，因此echo执行为“hello”
argv[1] = &quot;hello&quot;;
argv[2] = 0;//作为结束
exec(&quot;/bin/echo&quot;, argv);
printf(&quot;exec error\n&quot;);
</code></pre>
</li>
</ul>
<p>最后给出一些小细节来结束本小节</p>
<ul>
<li><p>一些系统调用比如echo，将会在执行后自动调用exit，同理wait也是被写入很多系统调用中，更何况还有调度程序使用这些结束的系统调用来管控进程。所以不要担心开始和结束的问题，就算上面的代码不写exit，他们也会自动结束的</p>
</li>
<li><p>进程中内存需要并不是一成不变的，fork得到了一些内存，exec也分配了一些内存，但是执行中仍然需要malloc（内调用sbrk（n），n代表字节）来分配新的内存，从而在返回的location中，继续使用内存</p>
</li>
<li><p>xv6并没有管理员或者客人模式来设置安全防护，全都是root模式，因此你可以很放心地写关于用户态和内核态的代码交互</p>
</li>
</ul>
<h3 id="I-x2F-O和文件描述符"><a href="#I-x2F-O和文件描述符" class="headerlink" title="I&#x2F;O和文件描述符"></a>I&#x2F;O和文件描述符</h3><p>文件描述符fd是一个int from 0，通常由一个进程独有，通常我们可以通过以下方式得到它</p>
<ul>
<li><p>打开文件</p>
</li>
<li><p>打开目录</p>
</li>
<li><p>打开设备</p>
</li>
<li><p>创建管道</p>
</li>
<li><p>复制dup</p>
</li>
</ul>
<p>那么文件描述符为什么要和文件名字区分开呢？有两个方面</p>
<ul>
<li><p>抽象以上这些文件和非文件动作，最终大家都只通过字节流的方式读写，来达到一个“一切皆文件”的观念</p>
</li>
<li><p>进程拥有一个描述符表，不同进程的fd不同，通过多级索引指向文件位置（多级索引是不同系统设计方式中非常常用的一个手段）</p>
</li>
</ul>
<p>fd 中</p>
<ul>
<li><p>0代表用来标准输入，就是你的键盘</p>
</li>
<li><p>1代表用来标准输出，就是你的屏幕</p>
</li>
<li><p>2代表error</p>
</li>
</ul>
<p>其中这三个fd是被printf，scanf这样的系统接口所认定，所以当我们使用管道等工作，重定向fd就非常有必要。其中fd存在于每个进程的文件描述符表中，每次”占用“fd将会使用最小的，比如</p>
<pre><code>close(0);
fd=open(...);
//将会在释放之后fd得到0，作为标准输入
</code></pre>
<p>为了保证I&#x2F;O和管道的正常使用，shell保证了这三个fd在shell进程中都能被使用而不被占用</p>
<p>关于fd有以下系统调用</p>
<ul>
<li><p>int fd &#x3D; open(filename, flags, mode)打开文件，返回fd</p>
</li>
<li><p>read(fd, buf,n)，返回成功读取的字节数，多个read会维护一个offset来完成顺序读取</p>
</li>
<li><p>write(fd, buf, n)，返回成功写入的字节数，同样维护一个offset</p>
</li>
</ul>
<p>具体给出以下例子（实际上是cat的实现），你应该查看代码逻辑，并理解错误时发生的故事</p>
<pre><code>char buf[512];
int n;

for(;;)&#123;
    n = read(0, buf, sizeof buf);//read
    if(n == 0)
        break;
    if(n &lt; 0)&#123;
        fprintf(2, &quot;read error\n&quot;);
        exit();
    &#125;
    if(write(1, buf, n) != n)&#123;//error
        fprintf(2, &quot;write error\n&quot;);
        exit();
    &#125;
&#125;
</code></pre>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>​	管道是一个小型的内核buffer，实际上是一个文件，进程传递一对fd：R&#x2F;W来使用管道。管道通过重定向标准输入&#x2F;输出的fd，使进程能够不修改读写文件的函数情况下，来访问同一个文件，进而完成进程通信。给出以下例子，来完成以上的功能。</p>
<pre><code>int p[2];
char *argv[2];
argv[0] = &quot;wc&quot;;
argv[1] = 0;
pipe(p);

if(fork() == 0) &#123;//作为标准输入
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec(&quot;/bin/wc&quot;, argv);
&#125; else &#123;//作为标准输出
    close(p[0]);
    write(p[1], &quot;hello world\n&quot;, 12);
    close(p[1]);
&#125;
</code></pre>
<p>程序调用pipe，给定p创建一个管道，使用p数组来记录fd的读写。fork之后，父子进程都有对pipe的引用。</p>
<p>子进程：close来释放fd0，保证0不被使用。紧接着复制读端fd就会获得0标准输入，此时0会同样指向fd[0]所在的buffer。此时子进程我们需要调用wc来读，不过pbuffer已经没用了（0已经指向了读buffer），我们可以关闭p所在的管道(释放两个fd)，然后执行wc，当wc读取标准输入，是从p来读取的。</p>
<p>父进程：我们需要写，于是p的读也没什么用了。关闭管道的读，并写hello world!\n入管道，然后关闭管道写端。</p>
<p>总之，管道的实现非常抠门，因为fd表非常小，大家记得随时关闭！</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>​	xv6提供数据文件，就只是未解释类型的字节数组，并且提供目录，目录包含了指向其他文件和目录的引用。对于目录构造一个树，从一个称为root的特殊目录开始。一个形如“&#x2F;a&#x2F;b&#x2F;c”指向&#x2F;目录下的a目录下的b目录下的文件c。这个例子中，从不是“&#x2F;”目录下开始的目录能够称为进程的当前目录，可以通过chdir（linux下shell命令cd也是如此）系统调用来改变当前目录。给出以下例子，他们打开了相同的文件（假设文件，目录存在）</p>
<pre><code>chdir(&quot;/a&quot;);
chdir(&quot;b&quot;);//可以看到目录改变有绝对和相对两种
open(&quot;c&quot;, O_RDONLY);

open(&quot;/a/b/c&quot;, O_RDONLY);
</code></pre>
<p>第一部分改变当前目录为“&#x2F;a&#x2F;b”，第二部分直接给出绝对路径</p>
<p>​	我们有多种系统调用来产生文件和目录（你会很快体会一切皆文件这个理念）：1.mkdir来创建一个新的目录，以一个“O_CREATE”flag来创建一个文件2.mknod来创建一个新的设备文件，给定以下例子来说明设备文件的细微不同</p>
<pre><code>mkdir(&quot;/dir&quot;);
fd = open(&quot;/dir/file&quot;,O_CREATE|O_WRONLY);
close(fd);
mknod(&quot;/console&quot;,1,1);
</code></pre>
<p>mknode通过创建一个文件系统里的文件，但是没有内容。并且文件metadata标记为一个设备文件，并且记录major和minor设备号（你可以认为是mknod的两个必备参数），这两个参数唯一确定一个内核设别。当一个进程打开文件后，R&#x2F;W系统调用并不操作文件系统（那些字节数组），而是操作设备文件里的内容。</p>
<p>​	fstat从fd指向的对象中检索信息，信息填充在struct stat中。stat定义在stat.h</p>
<pre><code>#define T_DIR 1 // 目录
#define T_FILE 2 // 文件
#define T_DEV 3 // 设备
struct stat &#123;
  short type; // 文件类型
    int dev; // 容纳文件系统的磁盘设备号，考虑mknod是否创建一个新的文件系统？
    uint ino; // inode编号
    short nlink; // 连接的数量
    uint size; // 以字节为单位的文件大小
&#125;;
</code></pre>
<p>​	目录下的文件名和文件本身不相同：考虑一个抽象概念：filename-&gt;inode(如果打开文件就会有以下结构：fd-&gt;opened_filename&gt;inode)，name对inode是多对一关系，称为links。link系统调用能够创建另一个名字，但是能够指向同样的文件inode，以下例子创建一个文件，他拥有两个名字，即硬链接（问题：软链接是什么？）</p>
<pre><code>open(&quot;a&quot;, O_CREATE|O_WRONLY);
link(&quot;a&quot;,&quot;b&quot;);
</code></pre>
<p>至此，R&#x2F;W能够通过a&#x2F;b来对同一个文件操作。每个inode有唯一的inode编号。上面的代码完成后，fstat返回相同的inode编号（ino），以此能够决定a和b能够指向同的文件，然后nlink增加为2。（问题：文件名不在stat里，怎么通过filename定向stat？）</p>
<p>​	unlink从文件系统中删除这个filename，文件inode和磁盘空间里，有关的部分将会在nlink为0，并且没有fd指向的时候</p>
<pre><code>unlink(&quot;a&quot;);
</code></pre>
<p>​	这句代码将会使b唯一指向inode指向文件。玩一个例子：</p>
<pre><code>fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR);
unlink(&quot;/tmp/xyz&quot;);
</code></pre>
<p>在这种情况会创建一个临时的inode，然后在进程结束后关闭fd，或者退出</p>
<p>​	对于shell里操作文件系统，能够被我们使用并且接手修改的的包括mkdir, ln, rm等。这种设计允许任何人修改命令，而只需要添加用户级别的程序代码。但是后来我们发现，这个想法被其他unix时代设计操作系统摒弃：必须在内核里。</p>
<p>​	幸运的是，除了cd，cd能够改变shell当前查看的目录，如果cd执行，那么首先fork一个子进程，子进程执行cd，而对于父进程的当前目录未变。</p>
<h3 id="真实世界"><a href="#真实世界" class="headerlink" title="真实世界"></a>真实世界</h3><p>​	UNIX对于文件描述符，管道和shell这个思想是一个很大的进步，通过这些抽象提供的服务，让我们的软件门槛一下子降低了很多，UNIX思想也流行了起来。shell语言也被称作第一个脚本语言，今天类UNIX，或者UNIX思想的继承，有BSD，MAC OS，LINUX，你可以在里面找到上面说的那些东西。</p>
<p>UNIX思想的继承由POSIX标准来指定系统接口，XV6不是POSIX实现，因为它只实现了部分的系统接口，更多的需要你来写。你可以通过C标准库来修改内核，来完成这些系统接口。对于更多的现代内核来说，他们完成了更多的部分：网络，图形化界面，用户进程（xv6没有用户&#x2F;内核的概念），设备驱动等。很多东西超越了POSIX标准，所以我们可以说：类UNIX系统满足并超越了UNIX系统。</p>
<p>对于现代类UNIX系统而言，他们对早期UNIX一个很重要的改动就是不把设备当作”特殊“的文件（包括上面讲的控制台设备文件，当然你看的例子都是现代的），而是引入了一个很重要的概念：“一切皆文件”。即把网络，图形，其他的资源全都当作文件和文件树，通过不同抽象统一为文件（流）。</p>
<p>文件系统抽象是一个非常有用的想法。尤其对于网络来说，网络接口也如同操作系统的接口一样，就像处理文件（流）一样处理各种类型的网络信息。UNIX把文件存放处理如同内存一般，来使一切变得简单。</p>
<p>这本书讲的XV6使用了类UNIX接口，但是想法更多一点：就目前的时代而言，你必须实现处理硬件抽象的多进程，进程隔离，进程通信等。学习XV6之后，你应该看看其他系统，寻找关于本课程学习的相同思想部分。</p>
<h2 id="1：操作系统组织"><a href="#1：操作系统组织" class="headerlink" title="1：操作系统组织"></a>1：操作系统组织</h2><p>​	对于操作系统来说，很重要的一件事就是所有资源能够立即响应。例如：进程中，使用fork产生一个新进程时候，所有的资源都必须时分复用（不是计网的时分复用），意思是操作系统必须保证所有的硬件能够在不同的时间提供不同进程所需要的资源。同时，操作系统必须保证进程之间资源独立，假如一个进程失败了，那么其他进程必须不会被这部分失败的资源所直接影响，最大程度保证运行正常。但是所谓资源独立并不是完全的，因为你必须要保证进程之间能够通信。因此，一个操作系统对于进程方面必须要保证三个要求：</p>
<ol>
<li>时分复用（即进程调度）</li>
<li>进程资源独立</li>
<li>进程通信</li>
</ol>
<p>​	本章节总览式地告诉你操作系统如何组织这三个要求。我们关注设计而不是细节，这些设计在类UNIX中都会用到。通过跟踪一个进程，来告诉你这三个要求的实现，你会同时知道xv6提供的抽象服务。对于xv6来说，进程代码重用代码，这简化了代码量，同时你也被屏蔽了底层的细节，不过接下来的lab中你会看到深入的细节。</p>
<p>​	xv6通过在80386（x86）的pc平台上运行，因此底层功能都是x86平台架构独有。因此我们假设你会一些x86平台机器级代码知识，并且在需要的时候会给你一些知识扫盲或补充，所以不用担心，这部分内容不多，并且用时再查。</p>
<h3 id="抽象硬件资源"><a href="#抽象硬件资源" class="headerlink" title="抽象硬件资源"></a>抽象硬件资源</h3><p>​	让我们从日常的软件角度考虑：什么时候需要操作系统？当然是与硬件交互的时候：当你实现某个系统调用作为调用库的时候，它可能访问&#x2F;修改内存，来为更高层的caller来提供服务（比如open为fopen提供服务），或者操作系统能够嵌入硬件（USB），甚至另一个操作系统。(当然我们的实验大部分都是当caller重用代码，即便如此也算在操作系统部分的）、</p>
<p>​	我们考虑如何复用（进程调度）？，调度系统对于程序员是透明的，因此假设你有一个无限循环的程序，那么其他进程也可以不断的切换进来执行，最大程度保证了整体的正常运转。再比如你一整个早上打开直播授课，但是你仍然可以再开一个窗口微信聊天，这种设计对于早期的单核CPU非常有意义，就算如今是多核时代，仍然非常有用。</p>
<p>​	如何实现进程资源独立？一个想法是我们的抽象设计需要禁止上层应用直接对硬件资源访问，比如内存访问只允许：read，open，close这样的设计。我们通过路径名，fd这样的东西来访问内存和磁盘，具体的访问硬件细节则不需要考虑，只需要考虑抽象提供的组织和结构即可。</p>
<p>​	再考虑exec，这个系统调用决定了在从磁盘调来的程序在内存哪里存放，假如内存不够放了，还能把部分内容暂存回磁盘，同时文件系统的实现更方便了exec：找你刚写的程序然后执行，非常自然。</p>
<p>​	如何实现通信？同样需要文件系统的帮助。用户通常使用fd来访问文件，因此进程通信变得非常简单：通过fd来访问同一个文件（比如pipe管道），假如第一个进程结束，第三个进程就可以使用管道，和第二个进程通过管道连接。</p>
<p>​	进程资源独立不仅仅是系统调用的设计，更多的抽象方法（看进程总览）我们下面介绍</p>
<h3 id="用户态，内核态，系统调用"><a href="#用户态，内核态，系统调用" class="headerlink" title="用户态，内核态，系统调用"></a>用户态，内核态，系统调用</h3><p>​	进程资源隔离是非常有必要的：我们不想一个除0错误，让整个电脑死机。我们应该自动退出这个程序，方便我们进行下一个。对于进程，不应该访问操作系统部分的数据（比如调度程序所需要的一些数据），而是仅仅相互通信罢了。</p>
<p>​	因此我们设计用户态&#x2F;内核态这样的抽象，大部分进程都是在用户态运行，而想要进入内核态，需要系统调用。想象以下过程：你的fread进行后，产生int0x80中断，花费大量开销进入内核态，然后调用system call函数，这个函数如同一个门卫，处理你的参数，决定拒绝，回到用户态，或者根据syscall table来决定跳转到read函数，进行IO处理，然后携带着返回参数eax回到用户态。</p>
<p>​	我们需要重点关注内核部分。</p>
<h3 id="内核组织"><a href="#内核组织" class="headerlink" title="内核组织"></a>内核组织</h3><p>​	内核部分是我们的操作系统部分，这部分拥有所有的特权级：不像用户那样受约束。自由地访问和管理所有的硬件资源。这种级别让不同操作系统连接，或者挂载文件系统时候假如需要一段cache，其中的访问就不会像用户态&#x2F;内核态转换那么麻烦，而是非常快。当然缺点就是用户态进程挂了还行，操作系统部分的挂了，整个机子就挂了。</p>
<p>​	所以为了避免这种问题，我们把大量的操作系统部分尽可能转为用户态，不得不放在内核的部分我们叫做微内核。比如下图中，假设文件系统运行在用户态（linux当然是在内核态），微内核在内核态，我们想要使用shell发送消息，就必须从用户态-&gt;内核态-&gt;用户态，然后shell 等待回应，进行相同的状态转移（问题：状态切换开销很大，有没有办法绕开这个抽象直接映射？），这种微内核结构非常简单，通常需要用户态server来保证正常运转。<img src="https://bed1.oss-cn-beijing.aliyuncs.com/008i3skNly1gvdvcgcg9zj614o0duab602.jpg"></p>
<p>​	在真实世界中，我们通常可以看到微内核和宏内核的不同使用。对于xv6和linux来说，都是宏内核，不过我们手中已有的xv6因为实现的系统接口非常少，所以甚至比不过微内核，需要你的帮助。</p>
<h3 id="进程总览"><a href="#进程总览" class="headerlink" title="进程总览"></a>进程总览</h3><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/008i3skNly1gvdvd46m9cj618c0q8q4j02.jpg"></p>
<h3 id="代码：第一个空间地址"><a href="#代码：第一个空间地址" class="headerlink" title="代码：第一个空间地址"></a>代码：第一个空间地址</h3><h3 id="代码：创建第一个进程"><a href="#代码：创建第一个进程" class="headerlink" title="代码：创建第一个进程"></a>代码：创建第一个进程</h3><h3 id="代码：运行第一个进程"><a href="#代码：运行第一个进程" class="headerlink" title="代码：运行第一个进程"></a>代码：运行第一个进程</h3><h3 id="第一个系统调用：exec"><a href="#第一个系统调用：exec" class="headerlink" title="第一个系统调用：exec"></a>第一个系统调用：exec</h3><h3 id="真实世界-1"><a href="#真实世界-1" class="headerlink" title="真实世界"></a>真实世界</h3><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li>在 <code>swtch</code> 中设断点。用 gdb 的 <em>stepi</em> 单步调试返回到 <code>forkret</code> 的代码，然后使用 gdb 的 <em>finish</em> 继续执行到 <code>trapret</code>，然后再用 <em>stepi</em> 直到你进入虚拟地址0处的 <code>initicode</code>。</li>
<li><code>KERNBASE</code> 会限制一个进程能使用的内存量，在一台有着 4GB 内存的机器上，这可能会让人感到不悦。那么提高 <code>KERNBASE</code> 的值是否能让进程使用更多的内存呢？</li>
</ol>
<h2 id="2：页表"><a href="#2：页表" class="headerlink" title="2：页表"></a>2：页表</h2><h2 id="3：中断：traps，interrupts，drivers"><a href="#3：中断：traps，interrupts，drivers" class="headerlink" title="3：中断：traps，interrupts，drivers"></a>3：中断：traps，interrupts，drivers</h2><h2 id="4：锁"><a href="#4：锁" class="headerlink" title="4：锁"></a>4：锁</h2><h2 id="5：调度"><a href="#5：调度" class="headerlink" title="5：调度"></a>5：调度</h2><h2 id="6：文件系统"><a href="#6：文件系统" class="headerlink" title="6：文件系统"></a>6：文件系统</h2><h2 id="7：总结"><a href="#7：总结" class="headerlink" title="7：总结"></a>7：总结</h2><h2 id="附录A：PC硬件"><a href="#附录A：PC硬件" class="headerlink" title="附录A：PC硬件"></a>附录A：PC硬件</h2><h2 id="附录B：引导"><a href="#附录B：引导" class="headerlink" title="附录B：引导"></a>附录B：引导</h2>]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile编写</title>
    <url>/2024/03/08/makefile%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>TODO：完成所有整理</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target  : prerequisites </span><br><span class="line">	command<span class="comment">#shell command,并且所有命令都需要tab来空出格子：也可以用空格四格</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<span id="more"></span>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">/* c文件及其头文件</span><br><span class="line">* main.c: defs.h</span><br><span class="line">* command.c: defs.h command.h</span><br><span class="line">* diplay.c: defs.h display.h buffer.h</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#链接所有文件生成edit可执行文件</span></span><br><span class="line"><span class="section">edit: main.o command.o diplay.o</span></span><br><span class="line">	cc -o edit main.o command.o \</span><br><span class="line">diplay.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c defs.h</span></span><br><span class="line">	cc -c main.o</span><br><span class="line"></span><br><span class="line"><span class="section">command.o: defs.h command.h</span></span><br><span class="line">	cc -c command.c</span><br><span class="line"></span><br><span class="line"><span class="section">diplay.o: defs.h diplay.h buffer.h</span></span><br><span class="line">	cc -c diplay.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#clean：为了重新编译可链接文件,放在文件最后，如果放在头会变成make执行的命令</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f edit main.o command.o display.o</span><br></pre></td></tr></table></figure>

<p>编译过程为依赖自顶向下：</p>
<ul>
<li>如果中途失败，很可能会残留已经成功的部分.o文件：比如diplay.o编译失败，但是main.o command.o会被生成</li>
<li>如果修改了.h文件，那么引入头文件的.c文件也会被重新编译为.o文件</li>
<li>假如新增一个.c文件，那么修改地方一般为三个：目标文件，.o生成，clean命令</li>
</ul>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用变量来减少编写,规则类似shell里的 命令输出定向为参数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">/* c文件及其头文件</span><br><span class="line">* main.c: defs.h</span><br><span class="line">* command.c: defs.h command.h</span><br><span class="line">* diplay.c: defs.h display.h buffer.h</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#链接所有文件生成edit可执行文件</span></span><br><span class="line">objs = main.o command.o diplay.o</span><br><span class="line"><span class="section">edit: <span class="variable">$(objs)</span></span></span><br><span class="line">	cc -o edit <span class="variable">$(objs)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c defs.h</span></span><br><span class="line">	cc -c main.o</span><br><span class="line"></span><br><span class="line"><span class="section">command.o:command.o defs.h command.h</span></span><br><span class="line">	cc -c command.c</span><br><span class="line"></span><br><span class="line"><span class="section">diplay.o:diplay.o defs.h diplay.h buffer.h</span></span><br><span class="line">	cc -c diplay.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#clean：为了重新编译可链接文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f edit <span class="variable">$(objs)</span></span><br></pre></td></tr></table></figure>

<h2 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h2><p>GNU的make会自动根据.o文件推导.c文件，生成相应的cc命令，同时头文件也可以共有推导</p>
<p>问题：为什么需要写.c文件的头文件依赖？include已经包含了，那么执行cc也不需要才对，实际上我的测试也是没有问题。。。或许是路径的问题，makefile可以保证不在同一个目录下的引入？</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">/* c文件及其头文件</span><br><span class="line">* main.c: defs.h</span><br><span class="line">* command.c: defs.h command.h</span><br><span class="line">* diplay.c: defs.h display.h buffer.h</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#链接所有文件生成edit可执行文件</span></span><br><span class="line">objs = main.o command.o diplay.o</span><br><span class="line"><span class="section">edit: <span class="variable">$(objs)</span></span></span><br><span class="line">	cc -o edit <span class="variable">$(objs)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">#或许你不需要这部分书写</span></span><br><span class="line"><span class="variable">$(objs)</span>: defs.h</span><br><span class="line"><span class="section">command.o:command.h</span></span><br><span class="line"><span class="section">diplay.o:diplay.h buffer.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#clean：为了重新编译可链接文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f edit <span class="variable">$(objs)</span></span><br></pre></td></tr></table></figure>

<h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释</p>
<ul>
<li>显式规则：目标文件，依赖，命令</li>
<li>隐晦规则：自动推导部分</li>
<li>变量定义：变量简化字符串书写</li>
<li>文件指示：makefile之间的引入</li>
<li>注释：#作为注释</li>
</ul>
<h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>一般make识为文件为当前目录下的“makefile“或者”Makefile“，而如果自定义了”makefile.Linux“, 则使用”-f”参数来指定文件</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>项目中很可能的一种情况：由于makefile只能考虑一级子目录，所以常在一级子目录content下也创建一个makefile；同时如果考虑makefile内容太多需要分开，则会在当前目录下新增一些诸如：makeconfig.mk之类，则可以通过总的makefile引入来覆盖整个项目。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.*作为通配符使用</span></span><br><span class="line"><span class="keyword">include</span> *.mk content/makefile</span><br><span class="line"><span class="comment">#2如果写的目录没有找到,可以在命令中引入 -I参数来指定目录</span></span><br><span class="line"><span class="comment">#3.还没有，会在usr/local/bin和usr/include中找</span></span><br><span class="line"><span class="keyword">-include</span> *.mk<span class="comment">#4.代表如果没找到也不要报错，忽略它</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>先不要使用，但是如果有问题，可以看看环境变量是否有MAEKFILES，在执行的时候会因此执行其他的makefile脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo MAKEFILES</span><br></pre></td></tr></table></figure>

<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ol>
<li>读入所有的makefile</li>
<li>读入被include的makefile</li>
<li>初始化变量:展开宏</li>
<li>推导隐晦规则</li>
<li>创建依赖链</li>
<li>根据依赖关系决定生成的文件</li>
<li>自顶向下执行命令</li>
</ol>
<h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><p>根据自顶向下的生成规则，你应该把第一个目标文件作为最终目标；同时目标文件一定是比依赖文件日期新，以此来判断是否重新编译</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">command</span><br><span class="line"><span class="comment">#其中，targets可以是使用通配符来产生的多个目标文件</span></span><br><span class="line"><span class="comment">#紧凑型书写也可以：</span></span><br><span class="line"><span class="section">targets: prerequisites; command</span></span><br></pre></td></tr></table></figure>

<p>对于通配符，make支持三种：“*”， “？”，“…”；还有一个Unix下的”~”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o</span><br><span class="line"></span><br><span class="line"><span class="section">print: *.c</span></span><br><span class="line">	lpr -p <span class="variable">$?</span></span><br><span class="line">	touch print</span><br><span class="line"></span><br><span class="line">objs = *.o<span class="comment">#变量作为宏展开得到的还是*.o</span></span><br><span class="line">objs = <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span><span class="comment">#使用关键字来保证查找</span></span><br></pre></td></tr></table></figure>

<p>搜寻文件可以有多个途径：</p>
<ul>
<li>指定的文件路径名（无论是相对还是绝对）</li>
<li>当前文件夹下</li>
<li>默认的一些文件夹</li>
<li>*类比于环境变量的VPATH：从左到右根据“：”分割开的文件夹里去找</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常见</span></span><br><span class="line">VPATH = src : ../headers<span class="comment">#src优先于headers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还有三种使用vpath关键字的：可以在不同文件目录查找</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;<span class="comment">#为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;</span></span><br><span class="line"><span class="keyword">vpath</span> %.h ../headers<span class="comment">#如果没指定，当前文件夹也没有，那么：在headers目录下查找所有以.h结尾的文件</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt;<span class="comment">#清除符合模式&lt;pattern&gt;的文件的搜索目录</span></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">vpath</span><span class="comment">#清除所有已被设置好了的文件搜索目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果多个vpath的重复pattern，那么就会形成顺序查找，直到找到</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">vpath</span> %.c foo </span><br><span class="line"><span class="keyword">vpath</span> % blish </span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">vpath</span> %.c foo:bar </span><br><span class="line"><span class="keyword">vpath</span> % blish</span><br></pre></td></tr></table></figure>

<p>伪目标</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ps：make clean查找所有的cleanall 和clean</span></span><br><span class="line"><span class="comment">#增加一行，因此make clean来代表生成clean这个文件,我还不知道使用有啥区别。。。</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#同样,将all放在开头，那么就可以依此生成多个文件的依赖链，一次make生成多个目标文件</span></span><br><span class="line"><span class="section">all: main command diplay</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同样，伪目标也可以成为依赖,但是还是感觉没了.PHONY没啥差别，比如命令:make cleanall或者上面例子的make all都可以在没有.PHONY这一行情况下正常执行（目前为止）</span></span><br><span class="line"><span class="section">cleanall: cleanobj cleanprog</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:cleanall</span></span><br><span class="line"></span><br><span class="line"><span class="section">cleanobj:</span></span><br><span class="line">	rm -f *.o</span><br><span class="line"><span class="section">cleanprog:</span></span><br><span class="line">	rm -f edit</span><br></pre></td></tr></table></figure>

<p>多文件：$@代表所有目标集，$&lt;代表所有依赖集</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#相同依赖的多个目标生成简写</span></span><br><span class="line">bigoutput littleoutput : text.g </span><br><span class="line">generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#上述规则等价于： </span></span><br><span class="line">bigoutput : text.g </span><br><span class="line">generate text.g -big &gt; bigoutput </span><br><span class="line">littleoutput : text.g </span><br><span class="line">generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>

<p>静态模式：更加方便定义多目标</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式</span></span><br><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; </span><br><span class="line">&lt;commands&gt; </span><br><span class="line">....</span><br><span class="line"><span class="comment">#给出两个例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">objects = foo.o bar.o </span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span> #作为最终目标</span></span><br><span class="line"><span class="comment">#静态模式：看看这两个“:”，他们决定了$@,$&lt;，并且保证扩展的部分一一对应</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c </span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#上述规则等价于： </span></span><br><span class="line">foo.o : foo.c </span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o </span><br><span class="line">bar.o : bar.c </span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">files = foo.elc bar.o lose.o </span><br><span class="line"><span class="comment">#静态模式：看看这两个“:”</span></span><br><span class="line"><span class="comment">#第一个filter，得到新的$(files)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c </span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"><span class="comment">#第二个filter，得到新的$(files)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el </span><br><span class="line">emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment">#上述规则等价于：</span></span><br><span class="line">bar.o : bar.c </span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o </span><br><span class="line">lose.o : lose.c </span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> lose.c -o lose.o</span><br><span class="line">foo.elc : foo.el</span><br><span class="line">emacs -f batch-byte-compile foo.el</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动生成依赖性</p>
<p>假如，不管自动推导.c以来和cc命令，也不管.c的.h依赖问题（见前面我的include问题）。</p>
<p>那么我们还有以下方式来化简书写</p>
<ul>
<li><p>自动生成.h依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">	cc -MM main.c#GNU如此，非GNU编译器参数为-M</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">等价于</span></span><br><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure>

<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202201091804951.png"></p>
</li>
<li><p>为每个.c文件生成依赖文件.d</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写出.c和.d依赖，让makefile自动生成.d文件</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.d: %.c</span> </span><br><span class="line">@set -e; rm -f $@; \ </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(CC) -M $(CPPFLAGS) $&lt; &gt; <span class="variable">$@</span>.$$$$; \ </span></span><br><span class="line">sed &#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \ </span><br><span class="line">rm -f $@.$$$$</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“<span class="built_in">rm</span> -f <span class="variable">$@</span>”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“<span class="variable">$@</span>”表示模式“%.d”文件，如果有一个 C 文件是 name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用 sed 命令做了一个替换，第四行就是删除临时文件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上述规则等价于：</span></span><br><span class="line">main.o : main.c defs.h </span><br><span class="line">转成： </span><br><span class="line">main.o main.d : main.c defs.h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">因此得到了.d文件，存放了依赖关系，我们因此可以在接下来的编译中引入.d文件</span></span><br><span class="line">sources = foo.c bar.c </span><br><span class="line">include $(sources:.c=.d) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为 include 是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Make运行"><a href="#Make运行" class="headerlink" title="Make运行"></a>Make运行</h1><p>make 3个推出码</p>
<ul>
<li>0：成功</li>
<li>1：错误</li>
<li>2：”-q”参数，表示部分更新</li>
</ul>
<h2 id="指定Make"><a href="#指定Make" class="headerlink" title="指定Make"></a>指定Make</h2><p>对于makeconfig.mk这样的分层makefile，使用参数“-f”来找到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure>

<p>。。。很多参数和惯例，用到时再说</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]《跟我一起学makefile》-陈皓</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>实验 6：网络</title>
    <url>/2024/03/08/lab6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="实验-6：网络"><a href="#实验-6：网络" class="headerlink" title="实验 6：网络"></a>实验 6：网络</h1><p>既然你有一个文件系统，任何操作系统都不应该没有网络堆栈。在本实验中，您将编写网络接口卡的驱动程序。该卡将基于英特尔 82540EM 芯片，也称为 E1000。</p>
<span id="more"></span>

<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>使用 Git 提交您的 Lab 5 源代码（如果您还没有），获取课程存储库的最新版本，然后基于我们的 lab6 分支<code>origin/lab6</code>创建一个名为<code>lab6</code>的本地分支：&#96;&#96;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git checkout lab6</span><br><span class="line">$git merge lab5</span><br></pre></td></tr></table></figure>

<p>但是，网卡驱动程序不足以让您的操作系统连接到 Internet。在新的 lab6 代码中，我们为您提供了网络堆栈和网络服务器。与之前的实验一样，使用 git 获取本实验的代码，合并到您自己的代码中，并探索新<code>net/</code>目录的内容 以及<code>kern/ 中</code>的新文件。</p>
<p>除了编写驱动程序之外，您还需要创建一个系统调用接口来访问您的驱动程序。您将实现缺少的网络服务器代码以在网络堆栈和驱动程序之间传输数据包。您还将通过完成 Web 服务器将所有内容联系在一起。使用新的 Web 服务器，您将能够从您的文件系统提供文件。</p>
<p>大部分内核设备驱动程序代码都需要您自己从头开始编写。本实验提供的指导比以前的实验少得多：没有骨架文件，没有一成不变的系统调用接口，许多设计决策由您决定。出于这个原因，我们建议您在开始任何单独的练习之前阅读整个作业。许多学生发现这个实验比以前的实验更难，所以请相应地计划你的时间。</p>
<h3 id="实验室要求"><a href="#实验室要求" class="headerlink" title="实验室要求"></a>实验室要求</h3><p>和以前一样，您需要完成实验室中描述的所有常规练习和<em>至少一个</em>挑战题。写下对实验室中提出的问题的简要回答，并在<code>answers-lab6.txt 中</code>描述你的挑战练习。</p>
<h2 id="QEMU-的虚拟网络"><a href="#QEMU-的虚拟网络" class="headerlink" title="QEMU 的虚拟网络"></a>QEMU 的虚拟网络</h2><p>我们将使用 QEMU 的用户模式网络堆栈，因为它不需要管理权限即可运行。QEMU 的文档<a href="http://wiki.qemu.org/download/qemu-doc.html#Using-the-user-mode-network-stack">在这里</a>有更多关于 user-net 的 <a href="http://wiki.qemu.org/download/qemu-doc.html#Using-the-user-mode-network-stack">信息</a>。我们更新了 makefile 以启用 QEMU 的用户模式网络堆栈和虚拟 E1000 网卡。</p>
<p>默认情况下，QEMU 提供了一个运行在 IP 10.0.2.2 上的虚拟路由器，并将为 JOS 分配 IP 地址 10.0.2.15。为了简单<code>起见</code>，我们将这些默认值硬编码到网络服务器的<code>net/ns.h 中</code>。</p>
<p>虽然 QEMU 的虚拟网络允许 JOS 与 Internet 进行任意连接，但 JOS 的 10.0.2.15 地址在 QEMU 内部运行的虚拟网络之外没有任何意义（即 QEMU 充当 NAT），因此我们无法直接连接到服务器在 JOS 内部运行，甚至从运行 QEMU 的主机运行。为了解决这个问题，我们将 QEMU 配置为在<em>主机</em>上的某个端口上运行一个服务器，该服务器只需连接到 JOS 中的某个端口，并在您的真实主机和虚拟网络之间来回传输数据。</p>
<p>您将在端口 7 (echo) 和 80 (http) 上运行 JOS 服务器。为了避免共享 Athena 机器上的冲突，makefile 会根据您的用户 ID 为这些机器生成转发端口。要找出 QEMU 转发到您的开发主机上的哪些端口，请运行make which-ports. 为方便起见，makefile 还提供了 make nc-7和make nc-80，它允许您直接与在终端中的这些端口上运行的服务器进行交互。（这些目标仅连接到正在运行的 QEMU 实例；您必须单独启动 QEMU 本身。）</p>
<h3 id="数据包检查"><a href="#数据包检查" class="headerlink" title="数据包检查"></a>数据包检查</h3><p>makefile 还配置 QEMU 的网络堆栈以将所有传入和传出数据包记录到实验室目录中的<code>qemu.pcap</code>。</p>
<p>要获取捕获数据包的十六进制&#x2F;ASCII 转储，请使用<code>tcpdump，</code>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure>

<p>或者，您可以使用<a href="http://www.wireshark.org/">Wireshark</a>以图形方式检查 pcap 文件。Wireshark 还知道如何解码和检查数百种网络协议。如果您在 Athena 上，则必须使用 Wireshark 的前身 ethereal，它位于 sipbnet 储物柜中。</p>
<h3 id="调试E1000"><a href="#调试E1000" class="headerlink" title="调试E1000"></a>调试E1000</h3><p>我们很幸运能够使用仿真硬件。由于 E1000 在软件中运行，仿真的 E1000 可以以用户可读的格式向我们报告其内部状态和遇到的任何问题。通常，对于使用裸机编写的驱动程序开发人员来说，这种奢侈是不可能的。</p>
<p>E1000 可以产生大量调试输出，因此您必须启用特定的日志记录通道。您可能会觉得有用的一些频道是：</p>
<table>
<thead>
<tr>
<th>旗帜</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>发送</td>
<td>记录数据包传输操作</td>
</tr>
<tr>
<td>发送错误</td>
<td>记录传输环错误</td>
</tr>
<tr>
<td>接收</td>
<td>记录对 RCTL 的更改</td>
</tr>
<tr>
<td>过滤器</td>
<td>传入数据包的日志过滤</td>
</tr>
<tr>
<td>输入错误</td>
<td>记录接收环错误</td>
</tr>
<tr>
<td>未知</td>
<td>记录未知寄存器的读写</td>
</tr>
<tr>
<td>内存</td>
<td>从 EEPROM 读取日志</td>
</tr>
<tr>
<td>打断</td>
<td>记录中断和对中断寄存器的更改。</td>
</tr>
</tbody></table>
<p>例如，要启用“tx”和“txerr”日志记录，请使用 make E1000_DEBUG&#x3D;tx,txerr ….</p>
<p><em>注意：</em> <code>E1000_DEBUG</code>标志仅适用于 6.828 版本的 QEMU。</p>
<p>您可以更进一步地使用软件模拟硬件进行调试。如果您曾经被卡住并且不明白为什么 E1000 没有按照您预期的方式响应，您可以在<code>hw/e1000.c 中</code>查看 QEMU 的 E1000 实现。</p>
<h2 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h2><p>从头开始编写网络堆栈是一项艰巨的工作。相反，我们将使用 lwIP，这是一个开源的轻量级 TCP&#x2F;IP 协议套件，其中包括一个网络堆栈。您可以在<a href="http://www.sics.se/~adam/lwip/">此处</a>找到有关 lwIP 的更多信息 。在本次作业中，就我们而言，lwIP 是一个实现了 BSD 套接字接口的黑盒，并具有数据包输入端口和数据包输出端口。</p>
<p>网络服务器实际上是四种环境的组合：</p>
<ul>
<li>核心网络服务器环境（包括socket调用调度器和lwIP）</li>
<li>输入环境</li>
<li>输出环境</li>
<li>定时器环境</li>
</ul>
<p>下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将对其进行介绍。在本实验中，您将实现以绿色突出显示的部分。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203291920043.png"></p>
<h3 id="核心网服务器环境"><a href="#核心网服务器环境" class="headerlink" title="核心网服务器环境"></a>核心网服务器环境</h3><p>核心网服务器环境由socket调用调度器和lwIP本身组成。套接字调用调度程序的工作方式与文件服务器完全一样。用户环境使用存根（在<code>lib/nsipc.c 中</code>找到）将 IPC 消息发送到核心网络环境。如果查看 <code>lib/nsipc.c，</code>您会发现我们找到核心网络服务器的方式与找到文件服务器的方式相同：<code>i386_init</code>使用 NS_TYPE_NS 创建 NS 环境，因此我们进行扫描<code>envs</code>，寻找这种特殊的环境类型。对于每个用户环境IPC，网络服务器中的调度器代表用户调用lwIP提供的相应BSD套接字接口函数。</p>
<p>常规用户环境不<code>nsipc_*</code>直接使用调用。相反，他们使用<code>lib/sockets.c 中</code>的函数，它提供了一个基于文件描述符的套接字 API。因此，用户环境通过文件描述符引用套接字，就像它们引用磁盘文件一样。多个操作（<code>connect</code>，<code>accept</code>等）特定于插座，但是<code>read</code>，<code>write</code>和 <code>close</code>经过在正常文件描述符设备分派代码<code>LIB / fd.c</code>。就像文件服务器如何为所有打开的文件维护内部唯一 ID 一样，lwIP 也为所有打开的套接字生成唯一 ID。在文件服务器和网络服务器中，我们使用存储在其中的信息将<code>struct Fd</code>每个环境的文件描述符映射到这些唯一的 ID 空间。</p>
<p>尽管看起来文件服务器和网络服务器的 IPC 调度程序的行为相同，但还是有一个关键的区别。BSD 套接字调用像 <code>accept</code>并且<code>recv</code>可以无限期地阻塞。如果调度程序让 lwIP 执行这些阻塞调用之一，调度程序也会阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的 IPC 消息，调度程序创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程进入睡眠状态，而其他线程继续运行。</p>
<p>除了核心网络环境，还有三个辅助环境。除了接受来自用户应用程序的消息，核心网络环境的调度器还接受来自输入和定时器环境的消息。</p>
<h3 id="输出环境"><a href="#输出环境" class="headerlink" title="输出环境"></a>输出环境</h3><p>在服务用户环境套接字调用时，lwIP 将生成数据包供网卡传输。LwIP 将使用<code>NSREQ_OUTPUT</code>IPC 消息将要传输的每个数据包发送到输出帮助程序环境，数据包附加在 IPC 消息的页面参数中。输出环境负责接受这些消息，并通过您即将创建的系统调用接口将数据包转发到设备驱动程序。</p>
<h3 id="输入环境"><a href="#输入环境" class="headerlink" title="输入环境"></a>输入环境</h3><p>网卡收到的数据包需要注入lwIP。对于设备驱动程序接收到的每个数据包，输入环境将数据包拉出内核空间（使用您将实现的内核系统调用）并使用<code>NSREQ_INPUT</code>IPC 消息将数据包发送到核心服务器环境。</p>
<p>数据包输入功能与核心网络环境分离，因为 JOS 很难同时接受 IPC 消息和轮询或等待来自设备驱动程序的数据包。我们<code>select</code> 在 JOS 中没有允许环境监视多个输入源以识别哪些输入已准备好进行处理的系统调用。</p>
<p>如果你看看<code>网/ Input.c中</code>和<code>网/ output.c</code>你会看到，都需要执行。这主要是因为实现取决于您的系统调用接口。在实现驱动程序和系统调用接口后，您将为两个帮助程序环境编写代码。</p>
<h3 id="定时器环境"><a href="#定时器环境" class="headerlink" title="定时器环境"></a>定时器环境</h3><p>定时器环境定期向<code>NSREQ_TIMER</code>核心网络服务器发送类型消息，通知它定时器已到期。lwIP 使用来自该线程的计时器消息来实现各种网络超时。</p>
<h1 id="A部分：初始化和传输数据包"><a href="#A部分：初始化和传输数据包" class="headerlink" title="A部分：初始化和传输数据包"></a>A部分：初始化和传输数据包</h1><p>您的内核没有时间概念，因此我们需要添加它。目前硬件每 10ms 产生一个时钟中断。在每个时钟中断上，我们可以增加一个变量来表示时间已经提前了 10 毫秒。这是在<code>kern/time.c 中实现的</code>，但尚未完全集成到您的内核中。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习 1."></a><strong>练习 1.</strong></h2><p><code>time_tick</code>在<code>kern/trap.c 中</code>为每个时钟中断 添加一个调用。落实<code>sys_time_msec</code>并把它添加到<code>syscall</code>在<code>kern/ syscall.c</code>使用户空间的访问时间。</p>
<p>使用make INIT_CFLAGS&#x3D;-DTEST_NO_NS run-testtime来测试你的时间码。您应该看到环境以 1 秒为间隔从 5 倒计时。“-DTEST_NO_NS”禁止启动网络服务器环境，因为此时它会在实验室中出现混乱。</p>
<h2 id="网络接口卡"><a href="#网络接口卡" class="headerlink" title="网络接口卡"></a>网络接口卡</h2><p>编写驱动程序需要深入了解硬件和呈现给软件的接口。实验课本将提供有关如何与 E1000 交互的高级概述，但您在编写驱动程序时需要大量使用英特尔的手册。</p>
<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2."></a><strong>练习 2.</strong></h2><p>浏览英特尔的E1000<a href="https://pdos.csail.mit.edu/6.828/2017/readings/hardware/8254x_GBe_SDM.pdf">软件开发人员手册</a>。本手册涵盖了几个密切相关的以太网控制器。QEMU 模拟 82540EM。</p>
<p>您现在应该浏览第 2 章以了解该设备。要编写驱动程序，您需要熟悉第 3 章和第 14 章以及 4.1（尽管不是 4.1 的小节）。您还需要使用第 13 章作为参考。其他章节主要介绍您的驱动程序不必与之交互的 E1000 组件。现在不要担心细节；只需感受一下文档的结构，您就可以稍后查找内容。</p>
<p>在阅读手册时，请记住 E1000 是一款具有许多高级功能的精密设备。正常工作的 E1000 驱动程序只需要 NIC 提供的一小部分功能和接口。仔细考虑与卡交互的最简单方法。我们强烈建议您在使用高级功能之前先让基本驱动程序工作。</p>
<h3 id="PCI接口"><a href="#PCI接口" class="headerlink" title="PCI接口"></a>PCI接口</h3><p>E1000 是 PCI 设备，这意味着它插入主板上的 PCI 总线。PCI总线有地址线、数据线和中断线，允许CPU与PCI设备通信，PCI设备读写内存。PCI 设备需要先被发现并初始化，然后才能使用。发现是在 PCI 总线上寻找连接设备的过程。初始化是分配 I&#x2F;O 和内存空间以及协商 IRQ 线以供设备使用的过程。</p>
<p>我们在<code>kern/pci.c 中</code>为您提供了 PCI 代码。为了在引导期间执行 PCI 初始化，PCI 代码会在 PCI 总线上寻找设备。当它找到一个设备时，它会读取它的供应商 ID 和设备 ID，并使用这两个值作为关键字来搜索<code>pci_attach_vendor</code>数组。该数组由如下<code>struct pci_driver</code>条目组成 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构 pci_driver &#123;</span><br><span class="line">    uint32_t key1, key2;</span><br><span class="line">    int (*attachfn) (struct pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果发现的设备的供应商 ID 和设备 ID 与阵列中的条目匹配，则 PCI 代码调用该条目的<code>attachfn</code>来执行设备初始化。（设备也可以通过类来识别，这是<code>kern/pci.c 中</code>另一个驱动程序表的用途。）</p>
<p>attach 函数通过一个<em>PCI 函数</em>来初始化。PCI 卡可以提供多种功能，而 E1000 只提供一种功能。以下是我们在 JOS 中表示 PCI 功能的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构 pci_func &#123;</span><br><span class="line">    结构 pci_bus *总线；</span><br><span class="line"></span><br><span class="line">    uint32_t 开发；</span><br><span class="line">    uint32_t 函数；</span><br><span class="line"></span><br><span class="line">    uint32_t dev_id;</span><br><span class="line">    uint32_t dev_class;</span><br><span class="line"></span><br><span class="line">    uint32_t reg_base[6];</span><br><span class="line">    uint32_t reg_size[6];</span><br><span class="line">    uint8_t irq_line;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述结构反映了开发人员手册第 4.1 节表 4-1 中的一些条目。<code>struct pci_func</code>我们特别感兴趣的是最后三个条目 ，因为它们记录了设备的协商内存、I&#x2F;O 和中断资源。在<code>reg_base</code>与<code>reg_size</code>阵列包含多达六个基地址寄存器或条信息。 <code>reg_base</code>存储内存映射 I&#x2F;O 区域（或 I&#x2F;O 端口资源的基本 I&#x2F;O 端口）的基本内存地址， <code>reg_size</code>包含来自 的相应基本值的大小（以字节为单位）或 I&#x2F;O 端口数<code>reg_base</code>，并<code>irq_line</code>包含IRQ 线分配给设备用于中断。E1000 BAR 的具体含义如表4-2 后半部分所示。</p>
<p>当设备的 attach 函数被调用时，该设备已被找到但尚未<em>启用</em>。这意味着 PCI 代码尚未确定分配给设备的资源，例如地址空间和 IRQ 线，因此，<code>struct pci_func</code>尚未填充结构的最后三个元素。附加函数应调用 <code>pci_func_enable</code>，即将启用设备，协商这些资源，并填写<code>struct pci_func</code>.</p>
<h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习 3."></a><strong>练习 3.</strong></h2><p>实现一个附加函数来初始化 E1000。如果找到匹配的 PCI 设备，则向<code>kern/pci.c 中</code>的<code>pci_attach_vendor</code>数组添加一个条目以 触发您的函数（确保将其放在标记表末尾的条目之前）。您可以在第 5.2 节中找到 QEMU 模拟的 82540EM 的供应商 ID 和设备 ID。当 JOS 在引导时扫描 PCI 总线时，您还应该看到这些列表。 &#96;&#96;&#96;{0, 0, 0}&#96;</p>
<p>现在，只需通过 启用 E1000 设备 <code>pci_func_enable</code>。我们将在整个实验中添加更多初始化。</p>
<p>我们已经为您提供了<code>kern/e1000.c</code>和 <code>kern/e1000.h</code>文件，这样您就不需要弄乱构建系统。它们目前是空白的；你需要在这个练习中填写它们。您可能还需要在内核的其他位置包含<code>e1000.h</code>文件。</p>
<p>当您启动内核时，您应该看到它打印出 E1000 卡的 PCI 功能已启用。现在您的代码应通过 <code>PCI附加</code>的测试make grade。</p>
<h3 id="内存映射-I-x2F-O"><a href="#内存映射-I-x2F-O" class="headerlink" title="内存映射 I&#x2F;O"></a>内存映射 I&#x2F;O</h3><p>软件通过<em>内存映射 I&#x2F;O</em> (MMIO)与 E1000 通信。您之前在 JOS 中已经见过两次：CGA 控制台和 LAPIC 都是您通过写入和读取“内存”来控制和查询的设备。但是这些读取和写入不会进入 DRAM；他们直接进入这些设备。</p>
<p><code>pci_func_enable</code>与 E1000 协商一个 MMIO 区域，并将其基数和大小存储在 BAR 0（即 <code>reg_base[0]</code>和<code>reg_size[0]</code>）中。这是分配给设备的<em>物理内存地址</em>范围，这意味着您必须做一些事情才能通过虚拟地址访问它。由于 MMIO 区域被分配了非常高的物理地址（通常超过 3GB），<code>KADDR</code>由于 JOS 的 256MB 限制，您不能使用它来访问它。因此，您必须创建一个新的内存映射。我们将使用 MMIOBASE 上方的区域（您<code> mmio_map_region</code>来自实验 4 的区域将确保我们不会覆盖 LAPIC 使用的映射）。由于 PCI 设备初始化发生在 JOS 创建用户环境之前，因此您可以在其中创建映射，<code>kern_pgdir</code>并且它始终可用。</p>
<h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习 4."></a><strong>练习 4.</strong></h2><p>在您的附加函数中，通过调用<code>mmio_map_region</code>（您在实验 4 中编写以支持内存映射 LAPIC）为 E1000 的 BAR 0 创建虚拟内存映射 。</p>
<p>您需要将这个映射的位置记录在一个变量中，以便您以后可以访问刚刚映射的寄存器。查看<code>kern/lapic.c</code>中的<code>lapic</code>变量，以获取执行此操作的一种方法的示例。如果您确实使用指向设备寄存器映射的指针，请务必声明它 ；否则，允许编译器缓存值并重新排序对该内存的访问。&#96;&#96;&#96;volatile&#96;</p>
<p>要测试您的映射，请尝试打印设备状态寄存器（第 13.4.2 节）。这是一个 4 字节的寄存器，从寄存器空间的第 8 字节开始。您应该得到<code>0x80080783</code>，这表明全双工链路的速度为 1000 MB&#x2F;s，等等。</p>
<p>提示：您将需要很多常量，例如寄存器的位置和位掩码的值。试图从开发人员手册中复制这些内容很容易出错，并且错误会导致痛苦的调试会话。我们建议改为使用 QEMU 的<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab6/e1000_hw.h"><code>e1000_hw.h</code></a>头文件作为指导。我们不建议逐字复制它，因为它定义的内容远比您实际需要的多，并且可能无法按照您需要的方式定义事物，但这是一个很好的起点。</p>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>您可以想象通过从 E1000 的寄存器写入和读取来发送和接收数据包，但这会很慢并且需要 E1000 在内部缓冲数据包数据。相反，E1000 使用<em>直接内存访问</em>或者DMA直接从内存中读写包数据，不涉及CPU。驱动程序负责为发送和接收队列分配内存，设置 DMA 描述符，并使用这些队列的位置配置 E1000，但之后的一切都是异步的。为了传输一个数据包，驱动程序将它复制到传输队列中的下一个 DMA 描述符中，并通知 E1000 另一个数据包可用；当有时间发送数据包时，E1000 会将数据从描述符中复制出来。同样，当 E1000 接收到一个数据包时，它会将它复制到接收队列中的下一个 DMA 描述符中，驱动程序可以在下一次机会读取它。</p>
<p>接收和发送队列在高层次上非常相似。两者都由一系列<em>描述符组成</em>。虽然这些描述符的确切结构各不相同，但每个描述符都包含一些标志和包含数据包数据的缓冲区的物理地址（卡要发送的数据包数据，或操作系统分配的缓冲区，用于卡将接收到的数据包写入到）。</p>
<p>队列被实现为循环数组，这意味着当卡或驱动程序到达数组的末尾时，它会返回到开头。两者都有一个<em>头指针</em>和一个<em>尾指针</em>而队列的内容就是这两个指针之间的描述符。硬件总是从头部消耗描述符并移动头指针，而驱动程序总是在尾部添加描述符并移动尾指针。传输队列中的描述符代表等待发送的数据包（因此，在稳定状态下，传输队列为空）。对于接收队列，队列中的描述符是卡可以接收数据包的空闲描述符（因此，在稳定状态下，接收队列由所有可用的接收描述符组成）。在不混淆 E1000 的情况下正确更新尾寄存器是很棘手的；当心！</p>
<p>指向这些数组的指针以及描述符中数据包缓冲区的地址都必须是<em>物理地址，</em> 因为硬件直接在物理 RAM 之间执行 DMA，而无需通过 MMU。</p>
<h2 id="传输数据包"><a href="#传输数据包" class="headerlink" title="传输数据包"></a>传输数据包</h2><p>E1000的发射和接收功能基本上是相互独立的，所以我们可以一次处理一个。我们将首先攻击传输数据包，因为我们无法在不传输“我在这里！”的情况下测试接收。先打包。</p>
<p>首先，您必须按照 14.5 节中描述的步骤初始化要传输的卡（您不必担心小节）。传输初始化的第一步是设置传输队列。队列的精确结构在 3.4 节中描述，描述符的结构在 3.3.3 节中描述。我们不会使用 E1000 的 TCP 卸载功能，因此您可以专注于“传统传输描述符格式”。您现在应该阅读这些部分并熟悉这些结构。</p>
<h3 id="C-结构"><a href="#C-结构" class="headerlink" title="C 结构"></a>C 结构</h3><p>您会发现使用 C<code>struct</code>来描述 E1000 的结构很方便。正如您所看到的结构，如 <code>struct Trapframe</code>, C<code>struct</code>允许您在内存中精确地布局数据。C 可以在字段之间插入填充，但 E1000 的结构布局使得这应该不是问题。如果确实遇到字段对齐问题，请查看 GCC 的“packed”属性。</p>
<p>例如，考虑手册表 3-8 中给出并在此处复制的传统传输描述符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">63 48 47 40 39 32 31 24 23 16 15 0</span><br><span class="line">+------------------------------------------------- --------------+</span><br><span class="line">| 缓冲区地址 |</span><br><span class="line">+--------------+-------+-------+-------+-------+- --------------+</span><br><span class="line">| 特价 | CSS | 状态| 命令 | 公民社会组织 | 长度 |</span><br><span class="line">+--------------+-------+-------+-------+-------+- --------------+</span><br></pre></td></tr></table></figure>

<p>该结构的第一个字节从右上角开始，因此要将其转换为 C 结构，请从右到左、从上到下读取。如果你眯着眼睛看它，你会看到所有的字段甚至可以很好地适应标准大小的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构体 tx_desc</span><br><span class="line">&#123;</span><br><span class="line">	uint64_t 地址；</span><br><span class="line">	uint16_t 长度；</span><br><span class="line">	uint8_t cso;</span><br><span class="line">	uint8_t cmd;</span><br><span class="line">	uint8_t 状态；</span><br><span class="line">	uint8_t css；</span><br><span class="line">	uint16_t 特殊；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>您的驱动程序必须为传输描述符数组和传输描述符指向的数据包缓冲区保留内存。有几种方法可以做到这一点，从动态分配页面到简单地在全局变量中声明它们。无论您选择什么，请记住，E1000 直接访问物理内存，这意味着它访问的任何缓冲区必须在物理内存中是连续的。</p>
<p>还有多种方法可以处理数据包缓冲区。我们建议从最简单的开始，是在驱动程序初始化期间为每个描述符保留数据包缓冲区的空间，并简单地将数据包数据复制到这些预先分配的缓冲区中或从这些缓冲区中复制出来。以太网数据包的最大大小为 1518 字节，这限制了这些缓冲区需要多大。更复杂的驱动程序可以动态分配数据包缓冲区（例如，在网络使用率较低时减少内存开销），甚至传递由用户空间直接提供的缓冲区（一种称为“零复制”的技术），但最好从简单开始。</p>
<h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习 5."></a><strong>练习 5.</strong></h2><p>执行第 14.5 节（但不是其小节）中描述的初始化步骤。使用第 13 节作为初始化过程参考的寄存器的参考，使用第 3.3.3 和 3.4 节作为传输描述符和传输描述符数组的参考。</p>
<p>请注意传输描述符数组的对齐要求以及该数组长度的限制。由于 TDLEN 必须是 128 字节对齐且每个传输描述符为 16 字节，因此您的传输描述符数组将需要 8 个传输描述符的一些倍数。但是，不要使用超过 64 个描述符，否则我们的测试将无法测试传输环溢出。</p>
<p>对于 TCTL.COLD，您可以假设全双工操作。对于 TIPG，IEEE 802.3 标准 IPG 参考 13.4.34 节表 13-77 中描述的默认值（不要使用 14.5 节表中的值）。</p>
<p>尝试运行make E1000_DEBUG&#x3D;TXERR,TX qemu。如果您正在使用 qemu 课程，当您设置 TDT 寄存器时，您应该看到“e1000: tx disabled”消息（因为这发生在您设置 TCTL.EN 之前）并且没有更多的“e1000”消息。</p>
<p>现在传输已初始化，您必须编写代码来传输数据包，并通过系统调用使其可访问用户空间。要传输一个数据包，你必须将它添加到传输队列的尾部，这意味着将数据包数据复制到下一个数据包缓冲区，然后更新 TDT（传输描述符尾部）寄存器以通知卡在队列中还有另一个数据包传输队列。（请注意，TDT 是传输描述符数组的<em>索引</em>，而不是字节偏移量；文档对此不是很清楚。）</p>
<p>然而，传输队列只有这么大。如果卡已经落后于传输数据包并且传输队列已满，会发生什么情况？为了检测这种情况，您需要 E1000 的一些反馈。不幸的是，您不能只使用 TDH（传输描述符头）寄存器；该文档明确指出从软件读取该寄存器是不可靠的。但是，如果在传输描述符的命令字段中设置 RS 位，那么当卡在该描述符中传输了数据包时，卡将在描述符的状态字段中设置 DD 位。如果设置了描述符的 DD 位，您就知道回收该描述符并使用它来传输另一个数据包是安全的。</p>
<p>如果用户调用您的传输系统调用，但下一个描述符的 DD 位没有设置，表明传输队列已满，该怎么办？您必须决定在这种情况下该怎么做。您可以简单地丢弃数据包。网络协议对此具有弹性，但如果丢弃大量突发数据包，协议可能无法恢复。您可以改为告诉用户环境它必须重试，就像您对<code>sys_ipc_try_send</code>. 这具有推回生成数据的环境的优势。</p>
<h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习 6."></a><strong>练习 6.</strong></h2><p>编写一个函数，通过检查下一个描述符是否空闲，将数据包数据复制到下一个描述符，并更新 TDT 来传输数据包。确保您处理传输队列已满。</p>
<p>现在是测试数据包传输代码的好时机。尝试通过直接从内核调用传输函数来仅传输几个数据包。您不必创建符合任何特定网络协议的数据包来进行测试。运行make E1000_DEBUG&#x3D;TXERR,TX qemu以运行您的测试。你应该看到类似的东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e1000：索引 0：0x271f00：9000002a 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当您传输数据包时。每一行都给出了传输数组中的索引、传输描述符的缓冲区地址、cmd&#x2F;CSO&#x2F;长度字段和特殊&#x2F;CSS&#x2F;状态字段。如果 QEMU 没有从传输描述符中打印出您期望的值，请检查您是否填写了正确的描述符以及您是否正确配置了 TDBAL 和 TDBAH。如果你得到“e1000: TDH wraparound @0, TDT x, TDLEN y”的消息，这意味着E1000一直在传输队列中不停地运行（如果QEMU不检查这个，它会进入一个无限循环），这可能意味着您没有正确操作 TDT。如果您收到很多“e1000: tx disabled”消息，那么您没有正确设置传输控制寄存器。</p>
<p>一旦 QEMU 运行，您就可以运行tcpdump -XXnr qemu.pcap 以查看您传输的数据包数据。如果您看到来自 QEMU 的预期“e1000: index”消息，但您的数据包捕获为空，请仔细检查您是否填写了传输描述符中的每个必要字段和位（E1000 可能通过了您的传输描述符，但没有认为它必须发送任何东西）。</p>
<h2 id="练习-7"><a href="#练习-7" class="headerlink" title="练习 7."></a><strong>练习 7.</strong></h2><p>添加一个系统调用，让您可以从用户空间传输数据包。确切的界面由您决定。不要忘记检查从用户空间传递给内核的任何指针。</p>
<h2 id="传输数据包：网络服务器"><a href="#传输数据包：网络服务器" class="headerlink" title="传输数据包：网络服务器"></a>传输数据包：网络服务器</h2><p>既然您有一个到设备驱动程序传输端的系统调用接口，就该发送数据包了。输出助手环境的目标是在循环中执行以下操作：接受<code>NSREQ_OUTPUT</code>来自核心网络服务器的 IPC 消息，并使用您在上面添加的系统调用将伴随这些 IPC 消息的数据包发送到网络设备驱动程序。该<code>NSREQ_OUTPUT</code> IPC的由发送<code>low_level_output</code>功能在 <code>净/ LWIP /乔斯/ JIF / jif.c</code>，该胶合的LWIP的堆书的网络系统。每个 IPC 将包含一个页面，该页面<code>union Nsipc</code>由其<code>struct jif_pkt pkt</code>字段中的数据包 组成 （参见<code>inc/ns.h</code>）。 <code>struct jif_pkt</code>好像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构 jif_pkt &#123;</span><br><span class="line">    int jp_len;</span><br><span class="line">    字符 jp_data[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>jp_len</code>表示数据包的长度。IPC 页上的所有后续字节都专用于数据包内容。<code>jp_data</code>在结构的末尾使用零长度数组是一种常见的 C 技巧（有些人会说可恶），用于表示没有预定长度的缓冲区。由于 C 不进行数组边界检查，只要确保结构后面有足够的未使用内存，就可以<code>jp_data</code>像使用任何大小的数组一样使用它。</p>
<p>当设备驱动程序的传输队列中没有更多空间时，请注意设备驱动程序、输出环境和核心网络服务器之间的交互。核心网服务器使用IPC向输出环境发送数据包。如果输出环境由于发送数据包系统调用而暂停，因为驱动程序没有更多缓冲区空间用于新数据包，核心网络服务器将阻塞等待输出服务器接受 IPC 调用。</p>
<h2 id="练习-8"><a href="#练习-8" class="headerlink" title="练习 8."></a><strong>练习 8.</strong></h2><p>实现<code>net/output.c</code>。</p>
<p>您可以使用<code>net/testoutput.c</code>来测试您的输出代码，而无需涉及整个网络服务器。尝试运行 make E1000_DEBUG&#x3D;TXERR,TX run-net_testoutput。你应该看到类似的东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送数据包 0</span><br><span class="line">e1000：索引 0：0x271f00：9000009 0</span><br><span class="line">发送数据包1</span><br><span class="line">e1000：索引 1：0x2724ee：9000009 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>并且tcpdump -XXnr qemu.pcap应该输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从文件 qemu.pcap 中读取，链接类型 EN10MB（以太网）</span><br><span class="line">-5:00:00.600186 [|以太]</span><br><span class="line">	0x0000: 5061 636b 6574 2030 30 Packet.00</span><br><span class="line">-5:00:00.610080 [|以太]</span><br><span class="line">	0x0000: 5061 636b 6574 2030 31 Packet.01</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>要使用更大的数据包数进行测试，请尝试 make E1000_DEBUG&#x3D;TXERR,TX NET_CFLAGS&#x3D;-DTESTOUTPUT_COUNT&#x3D;100 run-net_testoutput。如果这溢出了您的传输环，请仔细检查您是否正确处理了 DD 状态位，并且您已告诉硬件设置 DD 状态位（使用 RS 命令位）。</p>
<p>您的代码应通过<code>testoutput</code>的测试make grade。</p>
<p><strong>问题</strong></p>
<ol>
<li>你是如何构建你的传输实现的？特别是发送环满了怎么办？</li>
</ol>
<h1 id="B-部分：接收数据包和-Web-服务器"><a href="#B-部分：接收数据包和-Web-服务器" class="headerlink" title="B 部分：接收数据包和 Web 服务器"></a>B 部分：接收数据包和 Web 服务器</h1><h2 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h2><p>就像传输数据包一样，您必须配置 E1000 以接收数据包并提供接收描述符队列和接收描述符。3.2节描述了数据包接收的工作原理，包括接收队列结构和接收描述符，14.4节详细介绍了初始化过程。</p>
<h2 id="练习-9"><a href="#练习-9" class="headerlink" title="练习 9."></a><strong>练习 9.</strong></h2><p>阅读第 3.2 节。您可以忽略有关中断和校验和卸载的任何内容（如果您决定稍后使用这些功能，您可以返回到这些部分），并且您不必关心阈值的细节以及卡的内部缓存如何工作。</p>
<p>接收队列与发送队列非常相似，不同之处在于它由等待被传入数据包填充的空数据包缓冲区组成。因此，当网络空闲时，传输队列为空（因为所有数据包都已发送），但接收队列已满（空数据包缓冲区）。</p>
<p>当 E1000 收到数据包时，它首先检查它是否与卡配置的过滤器匹配（例如，查看数据包是否寻址到此 E1000 的 MAC 地址），如果不匹配任何过滤器，则忽略该数据包。否则，E1000 会尝试从接收队列的头部检索下一个接收描述符。如果头 (RDH) 已赶上尾 (RDT)，则接收队列中的空闲描述符已用完，因此卡会丢弃数据包。如果有空闲的接收描述符，它将包数据复制到描述符指向的缓冲区中，设置描述符的 DD（描述符完成）和 EOP（包结束）状态位，并递增 RDH。</p>
<p>如果 E1000 接收到的数据包大于一个接收描述符中的数据包缓冲区，它将从接收队列中检索所需数量的描述符以存储数据包的全部内容。为了表明这已经发生，它将在所有这些描述符上设置 DD 状态位，但只在这些描述符中的最后一个上设置 EOP 状态位。您可以在驱动程序中处理这种可能性，或者简单地将卡配置为不接受“长数据包”（也称为<em>巨型帧</em>），并确保您的接收缓冲区足够大以存储可能最大的标准以太网数据包（1518 字节） ）。</p>
<h2 id="练习-10"><a href="#练习-10" class="headerlink" title="练习 10."></a><strong>练习 10.</strong></h2><p>按照 14.4 节的过程设置接收队列并配置 E1000。您不必支持“长数据包”或多播。现在，不要将卡配置为使用中断；如果您决定使用接收中断，您可以稍后更改它。此外，配置 E1000 以剥离以太网 CRC，因为等级脚本希望它被剥离。</p>
<p>默认情况下，卡将过滤掉<em>所有</em>数据包。您必须使用卡自己的 MAC 地址配置接收地址寄存器（RAL 和 RAH），以便接受发往该卡的数据包。您可以简单地对 QEMU 的默认 MAC 地址 52:54:00:12:34:56 进行硬编码（我们已经在 lwIP 中对其进行了硬编码，因此在这里这样做也不会使事情变得更糟）。字节顺序要非常小心；MAC地址是从最低字节到最高字节写入的，所以52:54:00:12是MAC地址的低32位，34:56是高16位。</p>
<p>E1000 仅支持一组特定的接收缓冲区大小（在 13.4.22 中的 RCTL.BSIZE 描述中给出）。如果您使接收数据包缓冲区足够大并禁用长数据包，您就不必担心跨越多个接收缓冲区的数据包。另外，请记住，就像传输一样，接收队列和数据包缓冲区在物理内存中必须是连续的。</p>
<p>您应该至少使用 128 个接收描述符</p>
<p>您现在可以对接收功能进行基本测试，甚至无需编写接收数据包的代码。运行 make E1000_DEBUG&#x3D;TX,TXERR,RX,RXERR,RXFILTER run-net_testinput。 <code>测试输入</code>将传输一个 ARP（地址解析协议）公告数据包（使用您的数据包传输系统调用），QEMU 将自动回复。即使您的驱动程序还无法收到此回复，您应该会看到“e1000: unicast match[0]: 52:54:00:12:34:56”消息，表明 E1000 收到了一个数据包并匹配配置的接收过滤器。如果您看到“e1000: unicast mismatch: 52:54:00:12:34:56”消息，则说明 E1000 过滤掉了数据包，这意味着您可能没有正确配置 RAL 和 RAH。确保您的字节顺序正确并且没有忘记在 RAH 中设置“地址有效”位。如果您没有收到任何“e1000”消息，您可能没有正确启用接收。</p>
<p>现在您已准备好实现接收数据包。要接收数据包，您的驱动程序必须跟踪它希望保存下一个接收到的数据包的描述符（提示：根据您的设计，E1000 中可能已经有一个寄存器来跟踪它）。与传输类似，文档指出无法从软件可靠地读取 RDH 寄存器，因此为了确定数据包是否已传送到此描述符的数据包缓冲区，您必须读取描述符中的 DD 状态位。如果设置了 DD 位，您可以从该描述符的数据包缓冲区中复制数据包数据，然后通过更新队列的尾部索引 RDT 来告诉卡该描述符是空闲的。</p>
<p>如果 DD 位未设置，则没有接收到数据包。这是发送队列已满时的接收端等效项，在这种情况下您可以执行多种操作。您可以简单地返回“再试一次”错误并要求调用者重试。虽然这种方法适用于完整的传输队列，因为这是一种瞬态条件，但对于空的接收队列来说不太合理，因为接收队列可能会在很长一段时间内保持为空。第二种方法是暂停调用环境，直到接收队列中有要处理的数据包。这个策略非常类似于<code>sys_ipc_recv</code>. 就像在 IPC 的情况下一样，由于每个 CPU 只有一个内核堆栈，一旦我们离开内核，堆栈上的状态就会丢失。我们需要设置一个标志，表明环境已被接收队列下溢挂起，并记录系统调用参数。这种方法的缺点是复杂：必须指示 E1000 生成接收中断，并且驱动程序必须处理它们以恢复阻塞等待数据包的环境。</p>
<h2 id="练习-11"><a href="#练习-11" class="headerlink" title="练习 11."></a><strong>练习 11.</strong></h2><p>编写一个函数来接收来自 E1000 的数据包，并通过添加系统调用将其暴露给用户空间。确保您处理接收队列为空。</p>
<p><em>挑战！</em> 如果传输队列已满或接收队列为空，则环境和您的驱动程序可能会花费大量 CPU 周期轮询、等待描述符。E1000 可以在完成发送或接收描述符后生成中断，从而无需轮询。修改您的驱动程序，以便处理发送和接收队列都是中断驱动的，而不是轮询。</p>
<p>请注意，一旦中断被断言，它将保持断言直到驱动程序清除中断。在您的中断处理程序中，请确保在处理中断后立即清除该中断。如果不这样做，从中断处理程序返回后，CPU 将再次跳回它。除了清除E1000卡上的中断外，还需要清除LAPIC上的中断。使用<code>lapic_eoi</code>这样做。</p>
<h2 id="接收数据包：网络服务器"><a href="#接收数据包：网络服务器" class="headerlink" title="接收数据包：网络服务器"></a>接收数据包：网络服务器</h2><p>在网络服务器输入环境中，您将需要使用新的接收系统调用来接收数据包，并使用<code>NSREQ_INPUT</code>IPC 消息将它们传递到核心网络服务器环境。这些 IPC 输入消息应该附有一个页面，<code>union Nsipc</code>其中的<code>struct jif_pkt pkt</code>字段填充了从网络接收到的数据包。</p>
<h2 id="练习-12"><a href="#练习-12" class="headerlink" title="练习 12."></a><strong>练习 12.</strong></h2><p>实现<code>net/input.c</code>。</p>
<p>再次 运行<code>testinput</code>make E1000_DEBUG&#x3D;TX,TXERR,RX,RXERR,RXFILTER run-net_testinput。你应该看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正在发送 ARP 通知...</span><br><span class="line">等待数据包...</span><br><span class="line">e1000：索引 0：0x26dea0：900002a 0</span><br><span class="line">e1000：单播匹配[0]：52:54:00:12:34:56</span><br><span class="line">输入：0000 5254 0012 3456 5255 0a00 0202 0806 0001</span><br><span class="line">输入：0010 0800 0604 0002 5255 0a00 0202 0a00 0202</span><br><span class="line">输入：0020 5254 0012 3456 0a00 020f 0000 0000 0000</span><br><span class="line">输入：0030 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>以“input:”开头的行是 QEMU ARP 回复的十六进制转储。</p>
<p>您的代码应通过<code>testinput</code>的测试make grade。请注意，如果不发送至少一个 ARP 数据包来通知 QEMU JOS 的 IP 地址，就无法测试数据包接收，因此传输代码中的错误可能导致此测试失败。</p>
<p>为了更彻底地测试您的网络代码，我们提供了一个名为<code>echosrv</code>的守护进程 ，它设置了一个运行在端口 7 上的回显服务器，它将回显通过 TCP 连接发送的任何内容。用于 make E1000_DEBUG&#x3D;TX,TXERR,RX,RXERR,RXFILTER run-echosrv在一个终端和make nc-7另一个终端中启动回显服务器以连接到它。您键入的每一行都应由服务器回显。每次模拟的 E1000 收到数据包时，QEMU 应该在控制台打印如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e1000：单播匹配[0]：52:54:00:12:34:56</span><br><span class="line">e1000：索引 2：0x26ea7c：9000036 0</span><br><span class="line">e1000：索引 3：0x26f06a：9000039 0</span><br><span class="line">e1000：单播匹配[0]：52:54:00:12:34:56</span><br></pre></td></tr></table></figure>

<p>此时，您应该也可以通过<code>echosrv</code> 测试。</p>
<p><strong>问题</strong></p>
<ol>
<li>你是如何构建你的接收实现的？特别是，如果接收队列为空并且用户环境请求下一个传入数据包，您会怎么做？</li>
</ol>
<p><em>挑战！</em> 阅读开发者手册中关于 EEPROM 的内容，编写代码将 E1000 的 MAC 地址从 EEPROM 中加载出来。目前，QEMU 的默认 MAC 地址被硬编码到您的接收初始化和 lwIP 中。修复您的初始化以使用您从 EEPROM 读取的 MAC 地址，添加系统调用以将 MAC 地址传递给 lwIP，并将 lwIP 修改为从卡读取的 MAC 地址。通过将 QEMU 配置为使用不同的 MAC 地址来测试您的更改。</p>
<p><em>挑战！</em>将您的 E1000 驱动程序修改为“零拷贝”。目前，数据包数据必须从用户空间缓冲区复制到发送数据包缓冲区，并从接收数据包缓冲区复制回用户空间缓冲区。零拷贝驱动程序通过让用户空间和 E1000 直接共享数据包缓冲内存来避免这种情况。对此有许多不同的方法，包括将内核分配的结构映射到用户空间或将用户提供的缓冲区直接传递到 E1000。无论您采用何种方法，请注意重用缓冲区的方式，以免在用户空间代码和 E1000 之间引入竞争。</p>
<p><em>挑战！</em> 将零拷贝概念一直带入 lwIP。</p>
<p>一个典型的数据包由许多报头组成。用户在一个缓冲区中发送要传输到 lwIP 的数据。TCP 层要添加 TCP 头，IP 层要添加 IP 头，MAC 层要添加以太网头。尽管数据包有很多部分，但现在需要将这些部分连接在一起，以便设备驱动程序可以发送最终数据包。</p>
<p>E1000 的传输描述符设计非常适合收集分散在内存中的数据包片段，例如在 lwIP 内部创建的数据包片段。如果您将多个传输描述符排入队列，但只在最后一个设置 EOP 命令位，那么 E1000 将在内部连接来自这些描述符的数据包缓冲区，并且仅在到达 EOP 标记的描述符时传输连接的缓冲区。因此，单个数据包片段永远不需要在内存中连接在一起。</p>
<p>更改您的驱动程序，使其能够发送由许多缓冲区组成的数据包，而无需复制和修改 lwIP，以避免像现在这样合并数据包片段。</p>
<p><em>挑战！</em> 扩充您的系统调用接口以服务多个用户环境。如果有多个网络堆栈（和多个网络服务器），每个网络堆栈都有自己的 IP 地址在用户模式下运行，这将被证明是有用的。接收系统调用需要决定将每个传入数据包转发到哪个环境。</p>
<p>请注意，当前接口无法区分两个数据包之间的区别，如果多个环境调用数据包接收系统调用，则每个相应的环境将获得传入数据包的子集，该子集可能包括不以调用环境为目的地的数据包。</p>
<p><a href="http://pdos.csail.mit.edu/papers/exo:tocs.pdf">这篇</a> Exokernel 论文中的 第 2.2 节和第 3 节 对这个问题进行了深入的解释，以及在像 JOS 这样的内核中解决它的方法。使用论文来帮助您解决问题，您可能不需要论文中提出的那么复杂的解决方案。</p>
<h2 id="网络服务器-1"><a href="#网络服务器-1" class="headerlink" title="网络服务器"></a>网络服务器</h2><p>最简单形式的 Web 服务器将文件的内容发送到请求客户端。我们在<code>user/httpd.c 中</code>为一个非常简单的 web 服务器提供了框架代码。骨架代码处理传入的连接并解析标头。</p>
<h2 id="练习-13"><a href="#练习-13" class="headerlink" title="练习 13."></a><strong>练习 13.</strong></h2><p>Web 服务器缺少处理将文件内容发送回客户端的代码。通过实现<code>send_file</code>和 来完成 Web 服务器<code>send_data</code>。</p>
<p>完成 Web 服务器后，启动 Web 服务器 ( make run-httpd-nox) 并将您喜欢的浏览器指向 http:&#x2F;&#x2F; <em>host</em> : <em>port</em> &#x2F;index.html，其中<em>host</em>是运行 QEMU 的计算机的名称（如果您正在运行 QEMU athena 使用<code>hostname.mit.edu</code>（主机名是<code> hostname</code>athena上命令的输出，如果您在同一台计算机上运行 Web 浏览器和 QEMU，则<code>主机</code>名是<code>localhost</code>）并且<em>port</em> 是由 为 Web 服务器报告的端口号make which-ports 。您应该查看由在 JOS 中运行的 HTTP 服务器提供的网页。</p>
<p>此时，您应该在 上得分 105&#x2F;105 make grade。</p>
<p><em>挑战！</em> 向 JOS 添加一个简单的聊天服务器，多人可以连接到服务器，任何用户输入的任何内容都会传输给其他用户。要做到这一点，你必须找到一种方法同时处理多个插座进行沟通 <em>，并</em>在同一时间发送和接收同一插座上。有多种方法可以解决这个问题。lwIP 为 recv 提供了一个 MSG_DONTWAIT 标志（请参阅 <code>net/lwip/api/ ``sockets.c</code>中的<code>lwip_recvfrom</code>），因此您可以不断循环所有打开的套接字，轮询它们以获取数据。请注意，虽然网络服务器 IPC 支持<code>recv</code>标志，但无法通过常规<code>读取</code>访问它们&#96;&#96;&#96;&#96;&#96;&#96;函数，所以你需要一种方法来传递标志。一种更有效的方法是为每个连接启动一个或多个环境，并使用 IPC 来协调它们。方便的是，在套接字的结构 Fd 中找到的 lwIP 套接字 ID 是全局的（不是每个环境），因此，例如，<code>fork</code>的子级 继承其父级套接字。或者，一个环境甚至可以通过构造一个包含正确套接字 ID 的 Fd 来发送另一个环境的套接字。</p>
<p><strong>问题</strong></p>
<ol>
<li>JOS 的网络服务器提供的网页内容是什么？</li>
<li>你做这个实验大约花了多长时间？</li>
</ol>
<h1 id="回答问题汇总"><a href="#回答问题汇总" class="headerlink" title="回答问题汇总"></a>回答问题汇总</h1><p>既然有了文件系统，那么网络功能就能在基础上进行搭建。在本实验中，我们将编写一些网络接口卡的<strong>驱动程序</strong>和网络服务进程的<strong>中间层</strong>。网卡将基于英特尔 82540EM 芯片，也称为 E1000。</p>
<h1 id="网络驱动总览"><a href="#网络驱动总览" class="headerlink" title="网络驱动总览"></a>网络驱动总览</h1><p>我们将使用 QEMU 的用户模式网络堆栈，因为它不需要管理权限即可运行。实验更新了 makefile 以启用 QEMU 的用户模式网络堆栈和虚拟 E1000 网卡。</p>
<p>QEMU为 JOS 分配 IP 地址 10.0.2.15并NAT转换为10.0.2.2。为了简单<code>起见</code>，我们将这些默认值硬编码到网络服务器的<code>net/ns.h 中</code>。</p>
<p>虽然 QEMU 的虚拟网络允许 JOS 与 Internet 进行任意连接，但 JOS 的 10.0.2.15 地址在 QEMU 内部运行的虚拟网络之外没有任何意义（即 QEMU 充当 NAT），因此我们无法直接连接到服务器在 JOS 内部运行，甚至从运行 QEMU 的主机运行。为了解决这个问题，<strong>我们将 QEMU 配置为在<em>主机</em>上的某个端口上运行一个服务器</strong>，该服务器只需连接到 JOS 中的某个端口，并在您的真实主机和虚拟网络之间来回传输数据。</p>
<p>您将在端口 7 (echo) 和 80 (http) 上运行 JOS 服务器。</p>
<h2 id="数据包检查-1"><a href="#数据包检查-1" class="headerlink" title="数据包检查"></a>数据包检查</h2><p>makefile 还配置 QEMU 的网络堆栈以将所有传入和传出数据包记录到实验室目录中的<code>qemu.pcap</code>。</p>
<p>要获取捕获数据包的十六进制&#x2F;ASCII 转储，请使用<code>tcpdump，</code>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure>

<h2 id="调试E1000-1"><a href="#调试E1000-1" class="headerlink" title="调试E1000"></a>调试E1000</h2><p>我们很幸运能够使用仿真硬件。由于 E1000 在软件中运行，仿真的 E1000 可以以用户可读的格式向我们报告其内部状态和遇到的任何问题。通常，对于使用裸机编写的驱动程序开发人员来说，是不可能的。</p>
<p>E1000 可以产生大量debug输出，因此您必须启用特定的日志记录通道。您可能会觉得有用的一些make flag是</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>tx</td>
<td>Log packet transmit operations</td>
</tr>
<tr>
<td>txerr</td>
<td>Log transmit ring errors</td>
</tr>
<tr>
<td>rx</td>
<td>Log changes to RCTL</td>
</tr>
<tr>
<td>rxfilter</td>
<td>Log filtering of incoming packets</td>
</tr>
<tr>
<td>rxerr</td>
<td>Log receive ring errors</td>
</tr>
<tr>
<td>unknown</td>
<td>Log reads and writes of unknown registers</td>
</tr>
<tr>
<td>eeprom</td>
<td>Log reads from the EEPROM</td>
</tr>
<tr>
<td>interrupt</td>
<td>Log interrupts and changes to interrupt registers.</td>
</tr>
</tbody></table>
<p>例如，要启用“tx”和“txerr”日志记录，请使用 make E1000_DEBUG&#x3D;tx,txerr ….</p>
<p><em>注意：</em> <code>E1000_DEBUG</code>标志仅适用于 6.828 版本的 QEMU。</p>
<p>您可以更进一步地使用软件模拟硬件进行调试。如果您曾经被卡住并且不明白为什么 E1000 没有按照您预期的方式响应，您可以在<code>hw/e1000.c 中</code>查看 QEMU 的 E1000 实现。</p>
<h2 id="网络服务器-2"><a href="#网络服务器-2" class="headerlink" title="网络服务器"></a>网络服务器</h2><p>我们将使用 lwIP而不是从头编写驱动程序，这是一个开源的轻量级 TCP&#x2F;IP 协议套件，其中包括一个网络堆栈。您可以在<a href="http://www.sics.se/~adam/lwip/">此处</a>找到有关 lwIP 的更多信息 。在本次作业中，就我们而言，lwIP 是一个实现了 BSD 套接字接口的黑盒，并具有数据包输入端口和数据包输出端口。</p>
<p>网络服务器实际上是四种环境的组合：</p>
<ul>
<li>核心网络服务器环境（包括socket调用调度器和lwIP）</li>
<li>输入环境</li>
<li>输出环境</li>
<li>定时器环境</li>
</ul>
<p>下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将对其进行介绍。在本实验中，我们将实现以绿色突出显示的部分。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203291921445.png"></p>
<ul>
<li>用户应用httpd</li>
<li>用户态：输出env和输出env（用来和内核&#x2F;核心网络环境进行通信）</li>
<li>内核态：E1000驱动网络env</li>
</ul>
<h3 id="核心网服务器环境-1"><a href="#核心网服务器环境-1" class="headerlink" title="核心网服务器环境"></a>核心网服务器环境</h3><p>核心网服务器环境由socket调用和lwIP本身组成。套接字调用调度程序的工作方式与文件服务器完全一样。用户环境将 IPC 消息（在<code>lib/nsipc.c 中</code>找到）发送到核心网络环境。</p>
<p>如果查看 <code>lib/nsipc.c，</code>您会发现我们找到核心网络服务器的方式与找到文件服务器的方式相同：<code>i386_init</code>使用 NS_TYPE_NS 创建 NS 环境，因此我们进行扫描<code>envs</code>，寻找这种特殊的环境类型。对于每个用户环境IPC，网络服务器中的调度器代表用户调用lwIP提供的相应BSD套接字接口函数。</p>
<p>常规用户环境不直接调用<code>nsipc_*</code>。相反，他们使用<code>lib/sockets.c 中</code>的函数，它提供了一个基于文件描述符的套接字 API。因此，用户环境通过fd引用套接字，就像它们引用磁盘文件一样。多个操作（<code>connect</code>，<code>accept</code>等）使用特定接口，但是<code>read</code>，<code>write</code>和 <code>close</code>依旧是正常操作正常文件描述符的设备代码<code>LIB / fd.c</code>。因此类似文件系统的实现fd，lwIP 也为所有打开的套接字生成唯一 ID。在文件服务器和网络服务器中，我们使用存储在其中的信息将<code>struct Fd</code>每个环境的文件描述符映射到这些唯一的 ID 空间。</p>
<p>尽管看起来文件服务器和网络服务器的 IPC 调度程序的行为相同，但还是有一个关键的区别。BSD 套接字调用比如 <code>accept</code>并且<code>recv</code>可以无限期地阻塞。如果调度程序让 lwIP 执行这些阻塞调用之一，调度程序也会阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，网络服务器使用<strong>用户级线程</strong>来避免阻塞整个服务器环境。对于每个传入的 IPC 消息，调度程序创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程进入睡眠状态，而其他线程继续运行。</p>
<p>除了核心网络环境，还有三个辅助环境。除了接受来自用户应用程序的消息，核心网络环境的调度器还接受来自输入和定时器环境的消息。</p>
<h3 id="输出环境-1"><a href="#输出环境-1" class="headerlink" title="输出环境"></a>输出环境</h3><p>在服务用户环境套接字调用时，lwIP 将生成数据包供网卡传输。LwIP 将使用<code>NSREQ_OUTPUT</code>IPC 把将要传输的每个数据包发送到输出帮助程序环境，数据包附加在 IPC 消息的页面参数中。输出env负责接受这些消息，并通过<strong>即将创建的</strong>系统调用接口将数据包转发到设备驱动程序。</p>
<h3 id="输入环境-1"><a href="#输入环境-1" class="headerlink" title="输入环境"></a>输入环境</h3><p>网卡收到的数据包需要注入lwIP。对于设备驱动程序接收到的每个数据包，输入环境将数据包拉出内核空间（使用您将实现的内核系统调用）并使用<code>NSREQ_INPUT</code>IPC 消息将数据包发送到核心服务器环境。</p>
<p>问题：为什么数据包输入功能与内核网络环境分离？是因为 JOS 很难<strong>同时接受 IPC 消息和轮询或等待来自设备驱动程序的数据包</strong>。我们使用<code>select</code>来I&#x2F;O复用， 因此input发送后服务器select环境将会O（n）查找是哪个线程，借而切换进行消息处理。</p>
<h3 id="定时器环境-1"><a href="#定时器环境-1" class="headerlink" title="定时器环境"></a>定时器环境</h3><p>定时器环境定期向<code>NSREQ_TIMER</code>核心网络服务器发送类型消息，通知它定时器已到期。lwIP 使用来自该线程的计时器消息来实现各种网络超时。</p>
<h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><p>1.在<code>kern/trap.c </code>中使用<code>time_tick</code>，保证一开始进行10ms的计时开始</p>
<p>2.在<code>kern/ syscall.c</code>中实现<code>sys_time_msec</code>并把它添加到<code>syscall</code>，保证每次中断询问时间都可以回应</p>
<p>使用make INIT_CFLAGS&#x3D;-DTEST_NO_NS run-testtime， INIT_CFLAGS&#x3D;-DTEST_NO_NS是屏蔽网络，否则测试出错</p>
<h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><p>浏览英特尔的E1000<a href="https://pdos.csail.mit.edu/6.828/2017/readings/hardware/8254x_GBe_SDM.pdf">软件开发人员手册</a>（本文件夹下）。本手册涵盖了几个密切相关的以太网控制器。QEMU 模拟 82540EM。</p>
<p>您现在应该浏览第 2 章以了解该设备。要编写驱动程序，您需要熟悉第 3 章和第 14 章以及 4.1（尽管不是 4.1 的小节）。您还需要使用第 13 章作为参考。</p>
<p>总的来说，E1000通过了一些硬件手段加速接收数据，在接收到QEMU作为服务器发送的包后，使用DMA写入内存，然后中断请求IRQ，然后处理，一路向上到达我们的LwIP处理进程。</p>
<p>同时使用<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab6/e1000_hw.h">e1000_hw.h</a>对接下来的实验很有帮助，建议配合阅读。</p>
<p>简要讲解一下E1000，作为PCI设备，需要接入PCI总线上，因此给定以下数据结构我们可以看到：pci_bus是总线，pci_func则规定了接入的设备，id，寄存器，寄存器大小等细节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct pci_func &#123;</span><br><span class="line">    struct pci_bus *bus;	// Primary bus for bridges</span><br><span class="line"></span><br><span class="line">    uint32_t dev;</span><br><span class="line">    uint32_t func;</span><br><span class="line"></span><br><span class="line">    uint32_t dev_id;</span><br><span class="line">    uint32_t dev_class;</span><br><span class="line"></span><br><span class="line">    uint32_t reg_base[6];</span><br><span class="line">    uint32_t reg_size[6];</span><br><span class="line">    uint8_t irq_line;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pci_bus &#123;</span><br><span class="line">    struct pci_func *parent_bridge;</span><br><span class="line">    uint32_t busno;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203291922484.png"></p>
<p>在<code>kern/e100.h</code> <code>kern/e100.c</code>实现一个attachfn函数来初始化 E1000。</p>
<p>如果找到匹配的 PCI 设备，则向<code>kern/pci.c 中</code>的<code>pci_attach_vendor</code>数组添加一个条目，第 5.2 节中找到 QEMU 模拟的 82540EM 的供应商 ID 和设备 ID。上图为100E和8086，我们为此定义两个宏（模仿e1000 hw.h文件），再添加触发函数。此外保证末尾应该有： <code>&#123;0, 0, 0&#125;</code></p>
<p>对于数组由pci_driver组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct pci_driver &#123;</span><br><span class="line">    uint32_t key1, key2;</span><br><span class="line">    int (*attachfn) (struct pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kern&#x2F;e1000.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">e1000_attachfn(struct pci_func *pcif)</span><br><span class="line">&#123;</span><br><span class="line">       pci_func_enable(pcif);</span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kern&#x2F;pci.c：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//两个宏定义为 100e 8086</span><br><span class="line">struct pci_driver pci_attach_vendor[] = &#123;</span><br><span class="line">      &#123; E1000_VENDER_ID_82540EM, E1000_DEV_ID_82540EM, &amp;e1000_attachfn &#125;,</span><br><span class="line">       &#123; 0, 0, 0 &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><p>在刚刚的attachfn函数中，通过调用<code>mmio_map_region</code>（实验 4 中编写的支持内存映射 LAPIC）为 E1000 的 BAR 0 创建虚拟内存映射 。</p>
<p>我们需要将这个映射的位置记录在一个变量中，以便以后可以访问刚刚映射的寄存器。查看<code>kern/lapic.c</code>中的<code>lapic</code>变量，来确认细节。如果使用指向设备寄存器映射的指针，请务必使用volatile声明它 ；否则，编译器将可能不会立即写入变量。</p>
<p>然后尝试打印设备状态寄存器（第 13.4.2 节）。这是一个 4 字节的寄存器，从寄存器空间的第 8 字节开始。您应该得到<code>0x80080783</code>，这表明全双工链路的速度为 1000 MB&#x2F;s，等等。</p>
<p>前面lab预留的IO孔在这里使用：程序通过内存映射IO（MMIO）和E1000交互。我们直接读写设备。pci_func_enable()决定MMIO范围，并将基址和对应size保存在基地址寄存器0（reg_base[0] and reg_size[0]）中，因此使用mmio_map_region函数来填充kern_pgdir和内核页表，然后我们访问写入的第八个寄存器，确认是否为<code>0x80080783</code>（这表明全双工链路的速度为 1000 MB&#x2F;s）。这里同样使用宏来为以后的使用提供便利。</p>
<p>kern&#x2F;e1000.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//宏E1000_STATUS 0x8</span><br><span class="line">//宏GET_E1000_REG(offset) *(uint32_t*)(bar_va + offset)</span><br><span class="line"></span><br><span class="line">volatile void *bar_va;</span><br><span class="line">int</span><br><span class="line">e1000_attachfn(struct pci_func *pcif)&#123;</span><br><span class="line">	pci_func_enable(pcif);</span><br><span class="line">	bar_va = mmio_map_region(pcif-&gt;reg_base[0], pcif-&gt;reg_size[0]);//bar_va == base of mapping va</span><br><span class="line">	uint32_t status_reg = GET_E1000_REG(E1000_STATUS);</span><br><span class="line">	assert(status_reg == 0x80080783);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h2><h2 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h2><h2 id="Exercise7"><a href="#Exercise7" class="headerlink" title="Exercise7"></a>Exercise7</h2><h2 id="Exercise8"><a href="#Exercise8" class="headerlink" title="Exercise8"></a>Exercise8</h2><h2 id="Exercise9"><a href="#Exercise9" class="headerlink" title="Exercise9"></a>Exercise9</h2><h2 id="Exercise10"><a href="#Exercise10" class="headerlink" title="Exercise10"></a>Exercise10</h2><h2 id="Exercise11"><a href="#Exercise11" class="headerlink" title="Exercise11"></a>Exercise11</h2><h2 id="Exercise12"><a href="#Exercise12" class="headerlink" title="Exercise12"></a>Exercise12</h2><h2 id="Exercise13"><a href="#Exercise13" class="headerlink" title="Exercise13"></a>Exercise13</h2><h2 id="聊天服务器挑战"><a href="#聊天服务器挑战" class="headerlink" title="聊天服务器挑战"></a>聊天服务器挑战</h2>]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>实验 5：文件系统、Spawn 和 Shell</title>
    <url>/2024/03/08/lab5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，您将实现<code>spawn</code>，一个加载和运行磁盘可执行文件的库调用。然后，您将充实您的内核和库操作系统，足以在控制台上运行 shell。这些特性需要一个文件系统，本实验介绍了一个简单的读&#x2F;写文件系统。</p>
<span id="more"></span>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout lab5</span><br><span class="line"><span class="variable">$git</span> merge lab4</span><br></pre></td></tr></table></figure>

<p>实验室这部分的主要新组件是文件系统环境，位于新的<code>fs</code>目录中。浏览此目录中的所有文件以了解所有新内容。此外，在<code>user</code>和<code>lib</code>目录中有一些新的文件系统相关的源文件，</p>
<table>
<thead>
<tr>
<th><code>fs/fs.c</code></th>
<th>mainipulates 文件系统的磁盘结构的代码。</th>
</tr>
</thead>
<tbody><tr>
<td><code>fs/bc.c</code></td>
<td>一个简单的块缓存建立在我们的用户级页面错误处理设施之上。</td>
</tr>
<tr>
<td><code>fs/ide.c</code></td>
<td>最小的基于 PIO（非中断驱动）的 IDE 驱动程序代码。</td>
</tr>
<tr>
<td><code>fs/serv.c</code></td>
<td>使用文件系统 IPC 与客户端环境交互的文件系统服务器。</td>
</tr>
<tr>
<td><code>lib/fd.c</code></td>
<td>实现通用类 UNIX 文件描述符接口的代码。</td>
</tr>
<tr>
<td><code>lib/file.c</code></td>
<td>磁盘文件类型的驱动程序，作为文件系统 IPC 客户端实现。</td>
</tr>
<tr>
<td><code>lib/console.c</code></td>
<td>控制台输入&#x2F;输出文件类型的驱动程序。</td>
</tr>
<tr>
<td><code>lib/ spawn.c</code></td>
<td><code>spawn</code>库调用的代码框架。</td>
</tr>
</tbody></table>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>首先我们要赋予文件系统I&#x2F;O特权，作为实现文件系统的第一步。</p>
<p>在i386_init里调用env_create，因此取消这部分注释，并在mmu.h找到相应的I&#x2F;O权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (type == ENV_TYPE_FS) &#123;</span><br><span class="line">		e-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><p>我们的文件系统也拥有自己的虚拟地址空间，大小为3GB：从 0x10000000 ( <code>DISKMAP</code>) 到 0xD0000000 ( <code>DISKMAP+DISKMAX</code>)。例如，磁盘块 0 映射到虚拟地址 0x10000000，磁盘块 1 映射到虚拟地址 0x10001000，依此类推。由于磁盘本身比3GB大，所以这是一个并不是很完美的想法。</p>
<p>anyway，既然是作为拥有虚拟地址空间的一个env，我们同样要为文件系统环境提供了零拷贝的功能。当PGFLT产生时，我们从磁盘调入内存处理，而不是仅仅分配物理页置0。因此本exercise需要通过DMA方式来完成fs&#x2F;bc.c中PGFLT处理和写入磁盘。</p>
<p>通过”fs.h”找到相关宏和函数，我们可以发现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BLKSIZE：PGSIZE</span><br><span class="line">SECTSIZE：<span class="number">512B</span></span><br></pre></td></tr></table></figure>

<p>bc_pgfault：读取一个磁盘块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">sys_page_alloc(<span class="number">0</span>, addr, PTE_W|PTE_U|PTE_P);</span><br><span class="line"><span class="keyword">if</span> ((r = ide_read(blockno * BLKSECTS, addr, BLKSECTS)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;ide_read failed!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>flush_block：写入磁盘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addr = ROUNDOWN(addr, PGSIZE);<span class="comment">//hint</span></span><br><span class="line">	<span class="keyword">if</span>(!va_is_mapped(addr) || !va_is_dirty(addr))<span class="keyword">return</span>;<span class="comment">//hint</span></span><br><span class="line">	<span class="keyword">if</span>((r = ide_write(blockno * BLKSECTS, addr, BLKSECTS)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;flush_block: ide_write failed! %e\n&quot;</span>, r);</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,addr,<span class="number">0</span>,addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)<span class="comment">//hint</span></span><br><span class="line">		panic(<span class="string">&quot;flush_block: sys_page_map failed! %e\n&quot;</span>,r);</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203291922894.png"></p>
<p>我们通过bitmap来访问，这里给出一些信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> *bitmap<span class="comment">//定义：4字节，bitmap实际就是bool数组，bitmap[0]就可以访问0-31的block使用情况</span></span><br><span class="line"></span><br><span class="line">bitmap = disaddr(<span class="number">2</span>)：<span class="keyword">return</span> (<span class="type">char</span>*)(DISKMAP + blockno * BLKSIZE)<span class="comment">//2的block映射为bitmap</span></span><br><span class="line"></span><br><span class="line">bitmap[i/<span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (blockno%<span class="number">32</span>);<span class="comment">//free block：0代表use</span></span><br></pre></td></tr></table></figure>

<p>使用<code>free_block</code>作为一种模式来实现<code>alloc_block</code>的<code>FS / fs.c</code>，应在该位图找到一个免费的磁盘块，将其标记使用，并返回该块的数量。分配块时，应立即使用 将更改的位图块刷新到磁盘<code>flush_block</code>，以帮助文件系统一致性。</p>
<p>alloc_block</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//check_bitmap保证了0，1，bitmap所在的块都已经使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">3</span>; i &lt; super-&gt;s_nblocks; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(block_is_free(i))&#123;</span><br><span class="line">			bitmap[i/<span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (i%<span class="number">32</span>));</span><br><span class="line">			flush_block(&amp;bitmap[i/<span class="number">32</span>]);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><p>实施 <code>file_block_walk</code> 和<code>file_get_block</code>。</p>
<p> <code>file_block_walk</code>从文件中的块偏移量映射到该块<code>struct File</code>或间接块中该块的指针， <code>pgdir_walk</code>与页表所做的非常相似 。</p>
<p> <code>file_get_block</code>更进一步，映射到实际的磁盘块，必要时分配一个新的内存块。</p>
<p>使用make grade来测试你的代码。您的代码应该通过“file_open”、“file_get_block”、“file_flush&#x2F;file_truncated&#x2F;file rewrite”和“testfile”。</p>
<p><code>file_block_walk</code>和<code>file_get_block</code>是文件系统的主力。例如，<code>file_read</code> 和<code>file_write</code>需要 <code>file_get_block</code>来分配块和初始化。</p>
<p>给出文件File的信息</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203291923290.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];<span class="comment">//直接块pointer10个</span></span><br><span class="line">NINDIRECT (BLKSIZE / <span class="number">4</span>)<span class="comment">//非直接块pointer 1024个</span></span><br><span class="line"><span class="type">uint32_t</span> f_indirect;<span class="comment">//非直接块的块号</span></span><br></pre></td></tr></table></figure>

<p>file_block_walk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//*ppdiskbno我们*之后得到块号，因此我们设置为存储块号的虚拟地址</span></span><br><span class="line">	<span class="comment">//filebno是File里面block数组的索引</span></span><br><span class="line">	<span class="comment">//注意这里块号和虚拟地址，File直接块里的索引区分</span></span><br><span class="line">	<span class="keyword">if</span>(filebno &gt;= NDIRECT + NINDIRECT)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(filebno &lt; NDIRECT)&#123;</span><br><span class="line">		*ppdiskbno = f-&gt;f_direct + filebno;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(alloc &amp;&amp; (f-&gt;f_indirect == <span class="number">0</span>))&#123;</span><br><span class="line">			<span class="type">int</span> r;</span><br><span class="line">			<span class="keyword">if</span>((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			<span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">			f-&gt;f_indirect = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;f_indirect == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">		&#125;</span><br><span class="line">		*ppdiskbno = ((<span class="type">uint32_t</span> *)diskaddr(f-&gt;f_indirect)) + filebno - NDIRECT;<span class="comment">//diskaddr return char*</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//在间接块分配时，我们将得到一个间接块里存储的块号 的地址，而我们filebno指向的那个块还没分配，暂时是0</span></span><br></pre></td></tr></table></figure>

<p>file_get_block</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的二级指针意义是：当我修改一个变量时，我将传入一个指针，当我修改一个指针时，我将传入一个二级指针。</span></span><br><span class="line">	<span class="type">uint32_t</span> *pdiskbno;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = file_block_walk(f, filebno, &amp;pdiskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span>(*pdiskbno == <span class="number">0</span>)&#123;<span class="comment">//上文说的0</span></span><br><span class="line">		<span class="keyword">if</span>((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		*pdiskbno = r;</span><br><span class="line">	&#125;</span><br><span class="line">	*blk = (<span class="type">char</span> *)diskaddr(*pdiskbno);</span><br><span class="line">	flush_block(*blk);<span class="comment">//访问块先flush，或者分配块也先flush（空闲块虚拟地址对应的物理页不一定是空的？？？，或许只是无用功）</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>至此，我们可以开始准备将分页管理和文件系统结合：通过文件系统环境来管理环境（包括自己：又当裁判又当球员）的内存和磁盘的映射。而我们将通过自定的PGFLT处理来很容易地：页表修改-&gt;磁盘写入来完成串行结合。</p>
<h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><p>由于其他环境无法直接调用文件系统环境中的函数，我们将通过构建在 JOS 的 IPC 机制之上的<em>远程过程调用</em>或 RPC 抽象公开对文件系统环境的访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">       Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure>

<p>虚线下方的所有内容只是从常规环境到文件系统环境获取读取请求的机制。从一开始，<code>read</code>（我们提供的）适用于任何文件描述符，并简单地分派到适当的设备读取函数，在这种情况下 <code>devfile_read</code>（我们可以有更多的设备类型，如管道）。 <code>devfile_read</code> 工具<code>read</code>专门针对磁盘上的文件。这个<code>devfile_*</code>函数和<code>lib/file.c 中</code>的其他函数 实现了 FS 操作的客户端，并且都以大致相同的方式工作，将参数捆绑在一个请求结构中，调用 <code>fsipc</code>发送 IPC 请求，解包并返回结果。这<code>fsipc</code> 函数只是处理向服务器发送请求和接收回复的常见细节。</p>
<p>文件系统服务器代码可以在<code>fs/serv.c 中</code>找到。它在<code>serve</code>函数中循环，通过 IPC 无休止地接收请求，将该请求分派给适当的处理函数，并通过 IPC 将结果发送回。在读取示例中， <code>serve</code>将调度到<code>serve_read</code>，它将处理特定于读取请求的 IPC 详细信息，例如解包请求结构并最终调用 <code>file_read</code>以实际执行文件读取。</p>
<p>回想一下，JOS 的 IPC 机制允许环境发送单个 32 位数字，并且可以选择共享页面。要将请求从客户端发送到服务器，我们使用 32 位数字作为请求类型（文件系统服务器 RPC 已编号，就像系统调用的编号方式一样）并将请求的参数存储<code>union Fsipc</code>在页面上的a 中 通过 IPC 共享。在客户端，我们总是在<code>fsipcbuf</code>; 在服务器端，我们将传入的请求页面映射到<code>fsreq</code> ( <code>0x0ffff000</code>)。</p>
<p>服务器还通过 IPC 发回响应。我们使用 32 位数字作为函数的返回码。对于大多数 RPC，这就是它们返回的全部内容。 <code>FSREQ_READ</code>并<code>FSREQ_STAT</code>返回数据，它们只是将数据写入客户端发送请求的页面。不需要在响应 IPC 中发送此页面，因为客户端首先与文件系统服务器共享它。此外，在其响应中，<code>FSREQ_OPEN</code>与客户端共享一个新的“Fd 页面”。我们将很快返回到文件描述符页面。</p>
<p>实现<code>serve_read</code>在<code>FS / serv.c</code>。</p>
<p><code>serve_read</code>的繁重工作将由已经在<code>fs/fs.c </code>中实现的<code>file_read</code> （反过来，它只是一堆对  <code>file_get_block</code>的调用）来完成。 <code>serve_read</code>只需要提供用于文件读取的RPC接口。查看注释和代码<code>serve_set_size</code>以大致了解服务器功能的结构。</p>
<p>使用make grade来测试你的代码。您的代码应通过“serve_open&#x2F;file_stat&#x2F;file_close”和“file_read”以获得 70&#x2F;150 的分数。</p>
<p>给出有用的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	<span class="type">off_t</span> f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;		<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];	<span class="comment">// direct blocks</span></span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;		<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">	<span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">	<span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenFile</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span>&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> o_field;<span class="comment">//file id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span><span class="comment">//mapped descriptor for open file</span></span><br><span class="line">	<span class="type">int</span> o_mode; <span class="comment">//open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span><span class="comment">//fd page</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//called function</span></span><br><span class="line"><span class="type">ssize_t</span>	<span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">openfile_lookup</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> fileid, <span class="keyword">struct</span> OpenFile **po)</span>;</span><br><span class="line"><span class="type">int</span>	<span class="title function_">file_write</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>serve_read</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模仿serve_set_size来进行openfile_lookup的调用参数传入</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> * <span class="title">o</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h2><p>模仿已有的serve_read即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serve_write</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Fsreq_write *req)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = file_write(o-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><p> <code>spawn</code>依靠新的系统调用 <code>sys_env_set_trapframe</code>来初始化新创建环境的状态。<code>sys_env_set_trapframe</code>在<code>kern/syscall.c 中</code>实现 （不要忘记在 中调度新的系统调用<code>syscall()</code>）。</p>
<p>通过运行<code>kern/init.c 中</code>的<code>user/spawnhello</code>程序来测试您的代码，该 程序将尝试从文件系统中生成<code>/hello</code>。</p>
<p>使用make grade来测试你的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line">	<span class="comment">// address!</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">	tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;			<span class="comment">//普通进程不能有IO权限</span></span><br><span class="line">	tf-&gt;tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf = *tf;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h2><p>变化<code>duppage</code>中<code>的lib / fork.c</code>遵循新的约定。如果页表条目<code>PTE_SHARE</code> 设置了位，则直接复制映射。（您应该使用<code>PTE_SYSCALL</code>, not<code>0xfff</code>来屏蔽页表条目中的相关位。也可以<code>0xfff</code> 获取访问过的位和脏位。）</p>
<p>同样，<code>copy_shared_pages</code>在 <code>lib/spawn.c 中实现</code>。它应该遍历当前进程中的所有页表条目（就像<code>fork</code> 之前所做的那样），将任何<code>PTE_SHARE</code>设置了该位的页映射复制 到子进程中。</p>
<p>使用make run-testpteshare来检查你的代码是否正确行为。您应该会看到写着“ <code>fork handles PTE_SHARE right</code> ”和“ <code>spawn handles PTE_SHARE right</code> ”的行。</p>
<p>使用make run-testfdsharing检查文件描述符正确共享。您应该会看到写着“ <code>read in child successfully</code> ”和“ <code>read in parent successfully</code> ”的行。</p>
<h2 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h2><p>在您的<code>kern/trap.c 中</code>，调用<code>kbd_intr</code>处理陷阱 <code>IRQ_OFFSET+IRQ_KBD</code>和<code>serial_intr</code>处理陷阱<code>IRQ_OFFSET+IRQ_SERIAL</code>。</p>
<p>我们在<code>lib/console.c 中</code>为您实现了控制台输入&#x2F;输出文件类型。<code>kbd_intr</code>并<code>serial_intr</code> 在控制台文件类型耗尽缓冲区时用最近读取的输入填充缓冲区（控制台文件类型默认用于 stdin&#x2F;stdout，除非用户重定向它们）。</p>
<p>通过运行make run-testkbd并键入几行来测试您的代码。当您完成它们时，系统应该将您的台词回显给您。尝试在控制台和图形窗口中输入，如果两者都可用的话</p>
<p>copy_shared_pages</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">copy_shared_pages</span><span class="params">(<span class="type">envid_t</span> child)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="type">uintptr_t</span> addr;</span><br><span class="line">	<span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">				(uvpt[PGNUM(addr)] &amp; PTE_U) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="type">void</span>*)addr, child, (<span class="type">void</span>*)addr, (uvpt[PGNUM(addr)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h2><p>shell 不支持 I&#x2F;O 重定向。运行sh &lt;script而不是像上面那样手动输入脚本中的所有命令会很好 。为 &lt; to 添加 I&#x2F;O 重定向 <code>user/sh.c</code>。</p>
<p>通过sh &lt;script在 shell 中键入内容来测试您的实现</p>
<p>运行make run-testshell以测试您的外壳。 <code>testshell</code>只是将上述命令（也可以在<code>fs/testshell.sh 中</code>找到 ）输入 shell，然后检查输出是否与<code>fs/testshell.key</code>匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				cprintf(<span class="string">&quot;open %s for write: %e&quot;</span>, t, fd);</span><br><span class="line">				<span class="built_in">exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">				dup(fd, <span class="number">0</span>);</span><br><span class="line">				close(fd);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203291923608.png"></p>
<p>代码在这：<a href="https://github.com/sakura-mac/mit_6.828_jos">Source Code</a></p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>lab4：PartC</title>
    <url>/2024/03/08/lab4%EF%BC%9APartC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="C-部分：抢占式多任务和进程间通信-IPC"><a href="#C-部分：抢占式多任务和进程间通信-IPC" class="headerlink" title="C 部分：抢占式多任务和进程间通信 (IPC)"></a>C 部分：抢占式多任务和进程间通信 (IPC)</h1><p>我们现在需要实行抢占式调度，并且实现具有权限检查的进程通信。</p>
<span id="more"></span>

<h2 id="Exercise13"><a href="#Exercise13" class="headerlink" title="Exercise13"></a>Exercise13</h2><p>外部中断（即设备中断）称为 IRQ。有 16 个可能的 IRQ，编号为 0 到 15。从 IRQ 编号到 IDT 条目的映射不是固定的。 <code>pic_init</code>在<code>picirq.c</code>映射的IRQ 0-15到IDT入口<code>IRQ_OFFSET</code>通过<code>IRQ_OFFSET+15</code>。</p>
<p>在<code>inc/trap.h 中</code>， <code>IRQ_OFFSET</code>定义为十进制 32。因此，IDT 条目 32-47 对应于 IRQ 0-15。例如，时钟中断是IRQ 0。因此，IDT[IRQ_OFFSET+0]（即IDT[32]）包含内核中时钟中断处理程序的地址。<code>IRQ_OFFSET</code>选择此选项是为了使设备中断不会与处理器异常重叠，这显然会导致混淆。（事实上，在运行MS-DOS的PC的初期，<code>IRQ_OFFSET</code>有效地<em>是</em>零，这的确造成处理硬件中断和处理处理器异常之间巨大的混乱！）</p>
<p>在 JOS 中，与 xv6 Unix 相比，我们做了一个关键的简化。外部设备中断在内核中<em>总是被</em>禁用（并且像 xv6 一样，在用户空间中启用）。外部中断由寄存器的<code>FL_IF</code>标志位控制<code>%eflags</code>（参见<code>inc/mmu.h</code>）。当该位被设置时，外部中断被使能。虽然可以通过多种方式修改该位，但由于我们的简化，我们将仅通过在<code>%eflags</code>进入和离开用户模式时保存和恢复寄存器的过程来处理它。</p>
<p>我们必须确保<code>FL_IF</code>在用户环境运行时在用户环境中设置该标志，以便在中断到达时将其传递给处理器并由您的中断代码处理。</p>
<p>处理器在调用硬件中断处理程序时从不推送错误代码。此时，您可能需要重新阅读<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm"> 80386 参考手册的</a>第 9.2 节 或<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf"> IA-32 英特尔架构软件开发人员手册第 3 卷的</a>第 5.8 节 。</p>
<p>修改<code>kern/ trapentry.S</code>和<code>kern/trap.c</code>初始化所述IDT中的相应条目，并通过15提供为IRQs 0处理程序</p>
<p>然后修改代码中的<code>env_alloc()</code>在<code>kern/ env.c</code>，以确保用户环境总是在启用中断的情况下运行。</p>
<p>不要忘了还要取消注释<code>sched_halt() 中</code>的<code>sti</code>指令</p>
<p>kern&#x2F; trapentry.S</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(th32, IRQ_OFFSET)</span><br><span class="line">TRAPHANDLER_NOEC(th33, IRQ_OFFSET + <span class="number">1</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th34, IRQ_OFFSET + <span class="number">2</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th35, IRQ_OFFSET + <span class="number">3</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th36, IRQ_OFFSET + <span class="number">4</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th37, IRQ_OFFSET + <span class="number">5</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th38, IRQ_OFFSET + <span class="number">6</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th39, IRQ_OFFSET + <span class="number">7</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th40, IRQ_OFFSET + <span class="number">8</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th41, IRQ_OFFSET + <span class="number">9</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th42, IRQ_OFFSET + <span class="number">10</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th43, IRQ_OFFSET + <span class="number">11</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th44, IRQ_OFFSET + <span class="number">12</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th45, IRQ_OFFSET + <span class="number">13</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th46, IRQ_OFFSET + <span class="number">14</span>)</span><br><span class="line">TRAPHANDLER_NOEC(th47, IRQ_OFFSET + <span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>kern&#x2F;trap.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trap_init function:添加IDT的支持</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[IRQ_OFFSET], <span class="number">0</span>, GD_KT, th32, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">1</span>], <span class="number">0</span>, GD_KT, th33, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">2</span>], <span class="number">0</span>, GD_KT, th34, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">3</span>], <span class="number">0</span>, GD_KT, th35, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">4</span>], <span class="number">0</span>, GD_KT, th36, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">5</span>], <span class="number">0</span>, GD_KT, th37, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">6</span>], <span class="number">0</span>, GD_KT, th38, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">7</span>], <span class="number">0</span>, GD_KT, th39, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">8</span>], <span class="number">0</span>, GD_KT, th40, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">9</span>], <span class="number">0</span>, GD_KT, th41, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">10</span>], <span class="number">0</span>, GD_KT, th42, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">11</span>], <span class="number">0</span>, GD_KT, th43, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">12</span>], <span class="number">0</span>, GD_KT, th44, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">13</span>], <span class="number">0</span>, GD_KT, th45, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">14</span>], <span class="number">0</span>, GD_KT, th46, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + <span class="number">15</span>], <span class="number">0</span>, GD_KT, th47, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>





<p>env_alloc:中断是IF flag，所以我们添加即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>

<h2 id="Exericse14"><a href="#Exericse14" class="headerlink" title="Exericse14"></a>Exericse14</h2><p>抢占式调度：我们会通过时钟的IRQ来强迫进入内核态，进而切换用户环境。</p>
<p>修改内核<code>trap_dispatch()</code>函数，使其<code>sched_yield()</code> 在发生时钟中断时调用查找并运行不同的环境。</p>
<p>到这里会得到65&#x2F;80的分数</p>
<p>trap_dispatch</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">		lapic_eoi();</span><br><span class="line">		sched_yield();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15"></a>Exercise 15</h2><p>我们将会通过两个系统调用来实现IPC，<code>sys_ipc_recv</code>以及 <code>sys_ipc_try_send</code>. 他们被两个库包装器 <code>ipc_recv</code>和<code>ipc_send</code>调用.</p>
<p> IPC 机制相互发送的“消息”由两个组件组成：单个 32 位值和可选的单个页面映射。</p>
<h3 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h3><p>要接收消息，环境调用 <code>sys_ipc_recv</code>. 这个系统调用取消了当前环境的调度，并且在收到消息之前不会再次运行它。当一个环境正在等待接收消息时， <em>任何</em>其他环境都可以向它发送消息 - 不仅仅是特定环境，也不仅仅是与接收环境有父&#x2F;子安排的环境。</p>
<p>为了尝试发送一个值，环境调用 <code>sys_ipc_try_send</code>，参数是接收者的环境 ID 和要发送的值。如果目标环境实际上正在等待接收（它已调用 <code>sys_ipc_recv</code>但尚未获得值），则我们可以发送消息并返回 0。否则发送返回<code>-E_IPC_NOT_RECV</code>以指示目标环境当前不期望接收值。</p>
<p><code>ipc_recv</code>用户空间中的 库函数将负责调用<code>sys_ipc_recv</code>，然后在当前环境的<code>struct Env</code>.</p>
<p>同样，库函数<code>ipc_send</code>将负责重复调用，<code>sys_ipc_try_send</code> 直到发送成功。</p>
<h3 id="传输页面"><a href="#传输页面" class="headerlink" title="传输页面"></a>传输页面</h3><p>当环境<code>sys_ipc_recv</code> 使用有效<code>dstva</code>参数（如下<code>UTOP</code>）调用时，环境表示它愿意接收页面映射。如果发送方发送一个页面，那么该页面应该被映射<code>dstva</code> 到接收方的地址空间中。如果接收方已经在 处映射了一个页面<code>dstva</code>，则该前一个页面将被取消映射。</p>
<p>当环境<code>sys_ipc_try_send</code> 使用有效<code>srcva</code>（如下<code>UTOP</code>）调用时，这意味着发送方希望将当前映射<code>srcva</code>到的页面发送给接收方，并具有权限<code>perm</code>。IPC 成功后，发送方<code>srcva</code>在其地址空间中保留其对 at 页面的原始映射，但接收方也在<code>dstva</code>接收方地址空间中的接收方最初指定的同一物理页面上获得了该物理页面的映射。因此，此页面在发送方和接收方之间共享。</p>
<p>如果发送方或接收方未指示应传送页面，则不传送页面。<strong>在任何 IPC 之后</strong>，内核将<code>env_ipc_perm</code> 接收者<code>Env</code>结构中的新字段<strong>设置为接收到的页面的权限</strong>，如果没有接收到页面，则为零。</p>
<h3 id="实现-IPC"><a href="#实现-IPC" class="headerlink" title="实现 IPC"></a>实现 IPC</h3><p>我们的进程通信只是进程之间的mapping page而已，不过比较复杂的是权限检查。</p>
<p>简单来说如何IPC？</p>
<ol>
<li>当环境调用sys_ipc_recv()后，该环境会阻塞（ENV_NOT_RUNNABLE），直到接受消息。并且sys_ipc_recv()传入dstva参数时，代表请求接受。</li>
<li>环境调用sys_ipc_try_send()向目标环境发送“消息”，根据请求消息的参数决定发送，然后返回0，否则返回-E_IPC_NOT_RECV。当传入srcva参数时，将共享srcva映射的物理页。</li>
</ol>
<p>问题：为什么要阻塞？</p>
<p>A：假设环境运行， 或许对应的页面进行新映射，而另一个环境毫不知情，所以必须要有一个signal来通知。而这个阻塞能够完成“我等你”的通知，但是并没有保证“你”是谁，所以存在抢占式的共享。并不是锁，更像是信号机制：”等待某个有缘人“</p>
<p>实现sys_ipc_recv()和sys_ipc_try_send()。包装函数ipc_recv()和 ipc_send()。</p>
<p>细节繁多，请注意查看lab给的注释和lab前面的讲解，否则实验debug会没有头绪。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="type">int</span> r;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">dstenv</span>;</span></span><br><span class="line">  	<span class="type">pte_t</span> * pte;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">  	<span class="comment">//err begin:</span></span><br><span class="line">  	r = envid2env(envid, &amp;dstenv, <span class="number">0</span>);</span><br><span class="line">  	<span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;		<span class="comment">//1.env not exit</span></span><br><span class="line"> 	<span class="keyword">if</span> (!dstenv-&gt;env_ipc_recving)<span class="keyword">return</span> -E_IPC_NOT_RECV;		<span class="comment">//2.target env not blocked:</span></span><br><span class="line"></span><br><span class="line">  		<span class="comment">//if srcva &lt; UTOP,what err will exit?</span></span><br><span class="line">  	<span class="keyword">if</span> ((<span class="type">uint32_t</span>)srcva &lt; UTOP) &#123;</span><br><span class="line">  		pp = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte);<span class="comment">//find pp and pte</span></span><br><span class="line">  		</span><br><span class="line">    		<span class="keyword">if</span> ((<span class="type">uint32_t</span>)srcva &amp; <span class="number">0xfff</span>)<span class="keyword">return</span>  -E_INVAL;		<span class="comment">//3.not page-aligned</span></span><br><span class="line">    		<span class="type">int</span> flag = PTE_U | PTE_P;</span><br><span class="line">    		<span class="keyword">if</span> (flag != (flag &amp; perm)) <span class="keyword">return</span> -E_INVAL;		<span class="comment">//4.perm not appropriate</span></span><br><span class="line"></span><br><span class="line">    		<span class="keyword">if</span> (!pp) <span class="keyword">return</span> -E_INVAL;		<span class="comment">//5.srcva not mapped the same ppage</span></span><br><span class="line"></span><br><span class="line">    		<span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="keyword">return</span> -E_INVAL;		<span class="comment">//6.srcva read-only</span></span><br><span class="line"></span><br><span class="line">      			r = page_insert(dstenv-&gt;env_pgdir, pp, dstenv-&gt;env_ipc_dstva, perm);</span><br><span class="line">      			<span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_NO_MEM;		<span class="comment">//7.not enough memory for new page table</span></span><br><span class="line"></span><br><span class="line">      			dstenv-&gt;env_ipc_perm = perm;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//succeed: update</span></span><br><span class="line">  	dstenv-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">  	dstenv-&gt;env_ipc_value = value;</span><br><span class="line">  	dstenv-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">  	dstenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	dstenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (dstva &lt; (<span class="type">void</span> *)UTOP &amp;&amp; dstva != ROUNDDOWN(dstva, PGSIZE)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	sys_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (pg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		pg = (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> r = sys_ipc_recv(pg);</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;				<span class="comment">//err</span></span><br><span class="line">		<span class="keyword">if</span> (from_env_store) *from_env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (perm_store) *perm_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (from_env_store)</span><br><span class="line">		*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">	<span class="keyword">if</span> (perm_store)</span><br><span class="line">		*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">	<span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (pg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		pg = (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>) &#123;		<span class="comment">//sucess</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == -E_IPC_NOT_RECV) &#123;	<span class="comment">//target env not blocked</span></span><br><span class="line">			sys_yield();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;			<span class="comment">//other err</span></span><br><span class="line">			panic(<span class="string">&quot;ipc_send: sys_ipc_try_send failed\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>happy!</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/20211124125816.png"></p>
<p>代码在这：<a href="https://github.com/sakura-mac/mit_6.828_jos">Source Code</a></p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>lab4：PartB</title>
    <url>/2024/03/08/lab4%EF%BC%9APartB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="B-部分：写时复制fork"><a href="#B-部分：写时复制fork" class="headerlink" title="B 部分：写时复制fork"></a>B 部分：写时复制fork</h1><p>我们这部分实现以下内容</p>
<ol>
<li>用户的pgfault 的upcall机制：从内核到用户处理，再返回用户</li>
<li>COW的流程处理</li>
</ol>
<span id="more"></span>

<p>对于fork的写时复制，jos采用了“复制页表”的方式。而我们也可以用“共享页表”的方式：即在内核页目录中增加用户目录映射到父级，而不是前者：映射到新分配的页面作为子进程的页表，并memcpy复制父子页表。</p>
<p>话说回来，我们的复制页表，这种COW通常设置为read-only，而当我们写时会出现PGFLT，这里给出一些通用（不一定是JOS情况）可能PGFLT的例子：</p>
<ul>
<li><p>COW的修改</p>
</li>
<li><p>如果exec只映射部分？</p>
<ul>
<li>BSS：通常或许先只映射了全为0的一页</li>
<li>STACK：通常先映射了一页而已</li>
<li>HEAP：比如linux下mmp和brk</li>
<li>TEXT：如果代码很长，那么我们有理由考虑先映射部分磁盘内容</li>
</ul>
</li>
</ul>
<p>上述的映射情况在linux下会增加一个vm_area_struct来维护和记录映射，比如brk只是在这个结构体中增加，并没有进行真正的映射（增加页表项）。</p>
<p>回到我们的JOS，我们本部分实验最终关注并实现一个fork，我们的fork简化为第一种情况：将父子USTACKTOP下的所有页都COW映射，因此我们将会不断的产生PGFLT来逐页替换为子进程独有部分。</p>
<h2 id="Exercise8"><a href="#Exercise8" class="headerlink" title="Exercise8"></a>Exercise8</h2><p>我们将注册用户的pagefault处理，我们可以让内核处理，也可以让用户处理，jos使用了用户处理，于是我们的中断流程：当我们pagefault时，中断处理会执行user-mode的exception stack，使用upcall处理，然后在user态下回到中断前的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     Program Data &amp; Heap      |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>我们在这里进行注册upcall函数。</p>
<p>所以我们记得权限检查，不要忘记还有syscall的调用添加（在syscall.h里的syscallno）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;e, <span class="number">1</span>))<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	env-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise9"><a href="#Exercise9" class="headerlink" title="Exercise9"></a>Exercise9</h2><p>用来处理用户页面错误，我们的内核之前处理时将会直接panic，所以我们现在在用户模式进行处理自己的pgfault，主要是对exception stack的判断处理，lab给的note非常详细</p>
<p>给出exception stack布局</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP </span><br><span class="line">trap-time esp </span><br><span class="line">trap-time eflags </span><br><span class="line">trap-time eip </span><br><span class="line">trap-time eax start of <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">ecx</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">edx</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">ebx</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">esp</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">ebp</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">esi</span> </span></span><br><span class="line"><span class="class"><span class="title">trap</span>- <span class="title">time</span> <span class="title">edi</span> <span class="title">end</span> <span class="title">of</span> <span class="keyword">struct</span> <span class="title">PushRegs</span> </span></span><br><span class="line"><span class="class"><span class="title">tf_err</span> (<span class="title">error</span> <span class="title">code</span>) </span></span><br><span class="line"><span class="class"><span class="title">fault_va</span> &lt;</span>-- %esp 当处理程序运行时</span><br></pre></td></tr></table></figure>

<p>我们让这个用户下单异常栈将会被upcall用来回到中断前的代码，而如果本身pagefault处理递归的话，就会多次插入UTrapframe。为什么预留要32bit（4B）？lab10会给出答案：递归时的eip存放。</p>
<p>page_fault_handler</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> * <span class="title">utf</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(ROUNDUP(tf-&gt;tf_esp, PGSIZE) == UXSTACKTOP)&#123;</span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe *)((tf-&gt;tf_esp) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe) - <span class="number">4</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe *)(UXSTACKTOP - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	user_mem_assert(curenv, (<span class="type">void</span> *)utf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe), PTE_W);</span><br><span class="line">	utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">	utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">	utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">	utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">	utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">	utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line">	tf-&gt;tf_eip = (<span class="type">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;<span class="comment">//异常处理时的eip记录</span></span><br><span class="line">	tf-&gt;tf_esp = (<span class="type">uintptr_t</span>)utf;<span class="comment">//下一次</span></span><br><span class="line">	env_run(curenv);<span class="comment">//返回user-mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br></pre></td></tr></table></figure>



<h2 id="Exercise10"><a href="#Exercise10" class="headerlink" title="Exercise10"></a>Exercise10</h2><p>我们使用</p>
<p>lib&#x2F;pfentry.S下_page_fault_upcall</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  +----------USTACKTOP------+   high</span></span><br><span class="line">  <span class="comment">//  |            ...          |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+</span></span><br><span class="line">  <span class="comment">//  |                         |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+   </span></span><br><span class="line">  <span class="comment">//  |   trap-time-esp    (4B) |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+   </span></span><br><span class="line">  <span class="comment">//  |   trap-time-eflags (4B) |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+   </span></span><br><span class="line">  <span class="comment">//  |   trap-time-eip    (4B) |</span></span><br><span class="line">  <span class="comment">//  +-------------------------|   low</span></span><br><span class="line">  <span class="comment">//  |   trap-time-regs   (32B)|</span></span><br><span class="line">  <span class="comment">//  |   ...                   |</span></span><br><span class="line">  <span class="comment">//  |   ...                   |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+   </span></span><br><span class="line">  <span class="comment">//  |   err              (4B) |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+   </span></span><br><span class="line">  <span class="comment">//  |   fault_va         (4B) | </span></span><br><span class="line">  <span class="comment">//  +-------------------------+   &lt;-- cur_esp </span></span><br><span class="line">  <span class="comment">//            (1)</span></span><br><span class="line">  <span class="comment">//  </span></span><br><span class="line">  <span class="comment">//  +----trap-time-stack------+</span></span><br><span class="line">  <span class="comment">//  |            ...          |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+</span></span><br><span class="line">  <span class="comment">//  |   trap-time-eip    (4B) |</span></span><br><span class="line">  <span class="comment">//  +-------------------------+   &lt;-- trap_time_esp</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// LAB 4: Your code here</span></span><br><span class="line">	<span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line">	<span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// trap-time esp -= 4 to push trap-time eip into trap-time stack</span></span><br><span class="line">	movl <span class="number">0x30</span>(%esp), %eax</span><br><span class="line">	subl $<span class="number">0x4</span>, %eax</span><br><span class="line">	movl %eax, <span class="number">0x30</span>(%esp)</span><br><span class="line">	<span class="comment">//push trap-time eip into trap-time stack</span></span><br><span class="line">	movl <span class="number">0x28</span>(%esp), %ebx</span><br><span class="line">	mov %ebx, (%eax)</span><br><span class="line">	<span class="comment">//restore trap-time registers</span></span><br><span class="line">	addl $<span class="number">8</span>, %esp</span><br><span class="line">	popal</span><br><span class="line">	<span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line">	<span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line">	<span class="comment">// modifies eflags.</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	addl $<span class="number">4</span>, %esp</span><br><span class="line">	popfl</span><br><span class="line">	<span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	popl %esp</span><br><span class="line">	<span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//ret: popl %eip</span></span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h2 id="Exercise11"><a href="#Exercise11" class="headerlink" title="Exercise11"></a>Exercise11</h2><p>lib&#x2F;pgfault.c</p>
<p>set_pgfault_handler</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		r = sys_page_alloc(<span class="number">0</span>, (<span class="type">void</span> *)(UXSTACKTOP - PGSIZE), PTE_U | PTE_P | PTE_W;</span><br><span class="line">		<span class="keyword">if</span>(r &lt; <span class="number">0</span>)panic(<span class="string">&quot;set_pgfault_handler: page alloc fault!&quot;</span>);</span><br><span class="line">		r = sys_env_set_pgfault_upcall(<span class="number">0</span>, (<span class="type">void</span> *)_pgfault_upcall);</span><br><span class="line">		<span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;set_pgfault_handler: set pgfault upcall failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise12"><a href="#Exercise12" class="headerlink" title="Exercise12"></a>Exercise12</h2><p>lib&#x2F;fork.c</p>
<p>这里解决一个当初理解错误的问题：UVPT是用户映射，并且分配了4MB虚拟内存（inc&#x2F;memlayout.h），刚好对应了1M的页数。所以uvpt里的index应该是PGNUM的宏而不是PTX，而uvpd是页目录也确实没错，并且是以kern_pgdir模板，并且用户只读不可改。只有uvpd的内核相应函数查找时候才用到PTX。这是一个比较绕的设计想法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">	<span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">	<span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">uint32_t</span> write_err = err &amp; FEC_WR;</span><br><span class="line">	<span class="type">uint32_t</span> COW = uvpt[PGNUM(addr)] &amp; PTE_COW;</span><br><span class="line">	<span class="keyword">if</span>(!(write_err &amp;&amp; COW))panic(<span class="string">&quot;pgfault: not write to the COW page fault!\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">	<span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">	<span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//alloc a page by PFTEMP</span></span><br><span class="line"></span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	r = sys_page_alloc(<span class="number">0</span>, PFTEMP, PTE_U | PTE_P | PTE_W);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)panic(<span class="string">&quot;pgfault: sys_page_alloc failed!\n&quot;</span>);</span><br><span class="line">	<span class="comment">//copy data</span></span><br><span class="line">	memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">	r = sys_page_map(<span class="number">0</span>, PFTEMP, <span class="number">0</span>, addr, PTE_U | PTE_P | PTE_W);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)panic(<span class="string">&quot;pgfault: sys_page_map failed!\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//remove PTE:PFTEMP</span></span><br><span class="line">	r = sys_page_unmap(<span class="number">0</span>, PFTEMP);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)panic(<span class="string">&quot;pgfault: sys_page_unmap failed!\n&quot;</span>);</span><br><span class="line">	<span class="comment">//panic(&quot;pgfault not implemented&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></span><br><span class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></span><br><span class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></span><br><span class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></span><br><span class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></span><br><span class="line"><span class="comment">// this function?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//COW check, map page</span></span><br><span class="line">	<span class="type">pte_t</span> pte = uvpt[pn];</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span> *) (pn * PGSIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint32_t</span> perm = pte&amp;<span class="number">0xfff</span>;</span><br><span class="line">	<span class="keyword">if</span>(perm &amp; (PTE_W | PTE_COW))&#123;</span><br><span class="line">		perm &amp;= ~PTE_W;</span><br><span class="line">		perm |= PTE_COW;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	r = sys_page_map(<span class="number">0</span>, addr, envid, addr, perm &amp; PTE_SYSCALL);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)panic(<span class="string">&quot;duppage: sys_map_page child failed\n&quot;</span>);</span><br><span class="line">	<span class="comment">//map self again : freeze parent and child</span></span><br><span class="line">	r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, perm &amp; PTE_SYSCALL);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)panic(<span class="string">&quot;duppage: sys_map_page self failed\n&quot;</span>);</span><br><span class="line">	<span class="comment">//panic(&quot;duppage not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child&#x27;s envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix &quot;thisenv&quot; in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child&#x27;s user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//1.set page fault handler</span></span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line">	<span class="comment">//2.create a child env	</span></span><br><span class="line">	<span class="type">envid_t</span> envid = sys_exofork();<span class="comment">//just the tf copy	</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;<span class="comment">//must after code below excuted</span></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];<span class="comment">//fix &quot;thisenv&quot; in the child process</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (envid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_exofork: %e failed\n&quot;</span>, envid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//COW mapping:duppage(envid, va&#x27;s page):from 0 - USTACKTOP(under UTOP)</span></span><br><span class="line">	<span class="type">uint32_t</span> addr;</span><br><span class="line">	<span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE)</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr))] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">			duppage(envid, PGNUM(addr));	<span class="comment">//env already has page directory and page table</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//child&#x27;s exception stack</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)	</span><br><span class="line">		panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">	<span class="comment">//set child&#x27;s pgfault_upcall</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall(<span class="type">void</span>);</span><br><span class="line">	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);		</span><br><span class="line">	<span class="comment">//runnable</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)	 </span><br><span class="line">		panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line">	<span class="comment">//panic(&quot;fork not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下PartB的upcall机制和fork处理</p>
<p>1.set upcall</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/2021112380526.png"></p>
<p>2.call upcall </p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/2021112381630.png"></p>
<p>3.COW 机制</p>
<p>​	1.what in ”lib&#x2F;fork.c“?</p>
<ul>
<li>pagefault: user registers <strong>own</strong> handler <strong>supported by syscall</strong></li>
<li>duppage: copy virtual page into appointed env id(<strong>just modify the page table</strong>)</li>
<li>fork: create a child(<strong>COW mapping</strong>)</li>
</ul>
<p>​	2.what “fork” will do? </p>
<ul>
<li>set page fault handler</li>
<li>cread a child </li>
<li>fix child thisenv-&gt;env_id to real env id</li>
<li>COW mapping</li>
<li>child’s page fault handler</li>
<li>set child’s state &#x3D; RUNNABLE</li>
</ul>
<p>​	3.how  “syscall” support the handler？</p>
<ul>
<li>sys_env_set_status</li>
<li>sys_env_set_pgfault_upcall</li>
<li>sys_page_alloc(just check va perm and <strong>alloc a ppage</strong>)</li>
<li>sys_page_map</li>
<li>sys_page_unmap</li>
</ul>
<p>那么问题来了，这个upcall在user-mode下，使kern做出了这么多事情，也让中断的次数增加了很多，到底是为什么？</p>
<p>给出一些我查阅的资料：</p>
<p>关于<em>kernel upcall</em> 引用 <strong><a href="http://lkml.indiana.edu/hypermail/linux/kernel/9809.3/0922.html">lkml</a></strong> 中的一段话 :</p>
<blockquote>
<p>An upcall is a mechanism that allows the kernel to execute a function in userspace, and potentially be returned information as a result.</p>
<p>An upcall is like a signal, except that the kernel may use it at any time, for any purpose, including in an interrupt handler.</p>
<p>A process asks to use upcalls, and passes the kernel the addresses of a series of stacks to execute upcalls on. The kernel wires down down the stacks. The process registers functions associated with a set of predefined events (such as a page fault or blocking I&#x2F;O). When such an event happens, the thread for which the event occured to doesn’t call schedule(), but instead switches to an upcall stack, constructs a dummy trap return so that on return to user space it will execute the upcall, and returns to user space via a trap return.</p>
<p>Even Larry will, I hope, admit that this is a pretty fast process, much faster than a context switch, and way faster than a call to <em>any</em> schedule().</p>
<p>Note however that the function <em>NEVER RETURNS TO THE KERNEL</em>.</p>
</blockquote>
<p>在这个邮件列表里面还给出了 upcall 可以用来实现 scheduler activation 和 timing in user space code :</p>
<blockquote>
<p>Why would you want upcalls ? Well, we implemented upcalls specifically for a thread package that uses an idea called scheduler activations; every time a kernel thread blocks on I&#x2F;O or suffers a page fault, the kernel “activates” the user level thread scheduler and tells it what happened. This way, the user level thread scheduler can continue to use the processor by deciding to run some other thread.</p>
<p>It would also allow much more precise timing for Linux user space code, because a process could register a function (and yes, it has to be a very carefully designed process) to be executed <em>by</em> the timer interrupt (probably the timer code BH), not whenever the process gets woken by the timer interrupt and then run.</p>
</blockquote>
<p>大意就是：</p>
<p>1.对于阻塞I&#x2F;O时候，不再上下文切换，会快</p>
<p>2.对于抢占式切换（时间片），可以随时切换。如果是转到内核处理时，会因为同步问题加锁来禁止切换，导致了时间片效果很差</p>
<a href="/2024/03/08/lab4%EF%BC%9APartC/" title="lab4：PartC">lab4：PartC</a>]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>lab4：抢占式多任务处理(PartA)</title>
    <url>/2024/03/08/lab4%EF%BC%9APartA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上个实验我们使用内核创建了进程，但是并没有实现进程父子创建，调度，和通信。</p>
<p>在本实验中，我们将实现多个进程之间的抢占式切换。</p>
<p>在 A 部分，我们将为 JOS 添加多处理器支持，实现<strong>循环调度</strong>，并添加基本的环境管理系统调用（创建和销毁环境以及分配&#x2F;映射内存的调用）。同时实现了<strong>spinlock</strong>和<strong>sleep lock</strong></p>
<p>在 B 部分，我们将实现一个类 Unix 的<strong>fork</strong>，它允许用户模式环境创建其自身的副本。</p>
<p>在 C 部分，我们将添加对<strong>进程间通信</strong> (IPC) 的支持，允许不同的用户模式环境显式地相互通信和同步。您还将添加对硬件时钟中断和抢占的支持。</p>
<span id="more"></span>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout lab4</span><br><span class="line"><span class="variable">$git</span> merge lab3</span><br></pre></td></tr></table></figure>

<p>实验 4 包含许多新的源文件，您应该在开始之前浏览其中的一些：</p>
<table>
<thead>
<tr>
<th><code>kern/cpu.h</code></th>
<th>多处理器支持的内核私有定义</th>
</tr>
</thead>
<tbody><tr>
<td><code>kern/mpconfig.c</code></td>
<td>读取多处理器配置的代码</td>
</tr>
<tr>
<td><code>kern/lapic.c</code></td>
<td>驱动每个处理器中的LAPIC 单元的内核代码</td>
</tr>
<tr>
<td><code>kern/mpentry.S</code></td>
<td>非引导 CPU 的汇编语言入口代码</td>
</tr>
<tr>
<td><code>kern/spinlock.h</code></td>
<td>自旋锁的内核私有定义，包括大内核锁</td>
</tr>
<tr>
<td><code>kern/spinlock.c</code></td>
<td>实现自旋锁的内核代码</td>
</tr>
<tr>
<td><code>kern/sched.c</code></td>
<td>您将要实现的调度程序的代码框架</td>
</tr>
</tbody></table>
<h1 id="A-部分：多处理器支持和协作多任务处理"><a href="#A-部分：多处理器支持和协作多任务处理" class="headerlink" title="A 部分：多处理器支持和协作多任务处理"></a>A 部分：多处理器支持和协作多任务处理</h1><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>我们将让 JOS 支持“对称多处理”（SMP），这是一种多处理器模型，其中所有 CPU 对系统资源（如内存和 I&#x2F;O 总线）具有同等访问权限。尽管 SMP 中所有 CPU 的功能都相同，但在引导过程中它们可以分为两种类型：</p>
<ol>
<li>引导处理器 (BSP) 负责初始化系统和引导操作系统</li>
<li>并且应用处理器（AP）只有在操作系统启动并运行后才被 BSP 激活。哪个处理器是 BSP 由硬件和 BIOS 决定。到目前为止，您现有的所有 JOS 代码都已在 BSP 上运行。</li>
</ol>
<p>在 SMP 系统中，每个 CPU 都有一个伴随的本地 APIC (LAPIC) 单元。LAPIC 单元负责在整个系统中<strong>传送中断</strong>。LAPIC 还为其连接的 CPU 提供唯一标识符。在本实验中，我们使用 LAPIC 单元（在<code>kern/lapic.c 中</code>）的以下基本功能：</p>
<ul>
<li>读取 LAPIC 标识符 (APIC ID) 以了解我们的代码当前正在哪个 CPU 上运行（请参阅 参考资料<code>cpunum()</code>）。</li>
<li>发送<code>STARTUP</code>从BSP到的AP间中断（IPI）带来的其他CPU（见图 <code>lapic_startap()</code>）。</li>
<li>在 C 部分，我们对 LAPIC 的内置计时器进行编程以触发时钟中断以支持抢占式多任务处理（请参阅 参考资料 <code>apic_init()</code>）。</li>
</ul>
<p>处理器使用内存映射 I&#x2F;O (MMIO) 访问其 LAPIC。在 MMIO 中，一部分<em>物理</em>内存硬连线到一些 I&#x2F;O 设备的寄存器，因此通常用于访问内存的相同加载&#x2F;存储指令可用于访问设备寄存器。您已经在物理地址<code>0xA0000</code>处看到了一个 IO 孔 （我们使用它来写入 VGA 显示缓冲区）。LAPIC 位于从物理地址<code>0xFE000000</code>（32MB 比 4GB 短）开始的一个洞中 ，所以它太高了，我们无法使用我们通常在 KERNBASE 的直接映射来访问。JOS 虚拟内存映射在<code>MMIOBASE</code>上留下了 4MB 的空白,所以我们需要有一个地方可以映射这样的设备。由于后面的实验会引入更多的 MMIO 区域，您将编写一个简单的函数来从该区域分配空间并将设备内存映射到它。</p>
<p>kern&#x2F;lapic中到底什么是有用的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- 读取 LAPIC 标识符 (APIC ID) （lapic=mmio_map_region（...））以了解我们的代码当前正在哪个 CPU 上运行（请参阅 参考资料cpunum()）。</span><br><span class="line">- 发送STARTUP从BSP到的AP间中断（IPI）带来的其他CPU</span><br><span class="line">- 在 C 部分，我们对 LAPIC 的内置计时器进行编程以触发时钟中断以支持抢占式多任务处理</span><br></pre></td></tr></table></figure>

<p>mmio_map_region</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 就像boot_alloc中的nextfree一样，base会在调用之间保存和迭代</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从物理内存[pa,pa+size)映射并分配到虚拟内存[base,base+size)。由于这是设备内存而不是常规的DRAM，所以你应该在页表的位进行“不安全”的设置：PTE_PCD|PTE_PWT(cache-disable and write-through)，添加到PTE_W上。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	<span class="comment">//我们的目的是对CPU进行映射，以便lapic能够被访问和传递中断，所以直接调用boot_map_region就好了</span></span><br><span class="line">	<span class="comment">//size对齐</span></span><br><span class="line">	size = ROUNUP(size+pa, PGSIZE);</span><br><span class="line">	size -= pa;</span><br><span class="line">	<span class="keyword">if</span> (base+size &gt;= MMIOLIM) panic(<span class="string">&quot;mmio_map_region : out of memory&quot;</span>);</span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*) (base - size);<span class="comment">//lapic接受这个base</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BSP到底干了啥：</p>
<p>在启动 AP 之前，BSP 应首先收集有关多处理器系统的信息，例如 CPU 总数、它们的 APIC ID 和 LAPIC 单元的 MMIO 地址。<code>kern/mpconfig.c 中</code>的<code>mp_init()</code>函数 通过读取驻留在 BIOS 内存区域中的 MP 配置表来检索此信息。&#96;&#96;</p>
<p>该<code>boot_aps()</code>函数（在<code>kern/init.c 中</code>）驱动 AP 引导程序。AP 以实模式启动，很像引导加载程序在<code>boot/boot.S</code>中<code>启动的方式</code>，因此<code>boot_aps()</code> 将 AP 入口代码 ( <code>kern/mpentry.S</code> )<code>复制</code>到可在实模式下寻址的内存位置。与引导加载程序不同，我们可以控制 AP 开始执行代码的位置；我们将入口代码复制到<code>0x7000</code> ( <code>MPENTRY_PADDR</code>)，但任何未使用的、页面对齐的低于 640KB 的物理地址都可以使用。</p>
<p>之后<code>boot_aps()</code>，通过向<code>STARTUP</code>相应 AP 的 LAPIC 单元发送IPI 以及<code>CS:IP</code>AP 应开始运行其入口代码（<code>MPENTRY_PADDR</code>在我们的示例中）的初始地址，一个接一个地激活 AP 。<code>kern/mpentry.S 中</code>的入口代码与<code>boot/boot.S 中</code>的入口代码非常相似。经过一些简短的设置后，它会将 AP 置于启用分页的保护模式，然后调用 C 设置例程<code>mp_main()</code>（也在<code>kern/init.c 中</code>）。 在继续唤醒下一个之前，<code>boot_aps()</code>等待 AP<code>CPU_STARTED</code>在<code>cpu_status</code>其字段中发出标志信号 <code>struct CpuInfo</code>。</p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/2021111993857.png">多CPU来完成多线程的实现：每个AP共享内核部分（比如代码，用户页表)，但是又有独有的栈和寄存器等内容。</p>
<p>给出Cpu_Info</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给出AP需要关注的部分：</p>
<p>在编写多处理器操作系统时，区分每个处理器私有的每个 CPU 状态和整个系统共享的全局状态很重要。 <code>kern/cpu.h</code>定义了大部分 per-CPU 状态，包括<code>struct CpuInfo</code>存储 per-CPU 变量的 。 <code>cpunum()</code>总是返回调用它的 CPU 的 ID，它可以用作数组的索引，如 <code>cpus</code>. 或者，该宏<code>thiscpu</code>是当前 CPU 的<code>struct CpuInfo</code>.</p>
<p>以下是应该注意的每个 CPU 状态：</p>
<ul>
<li><p>每个<strong>CPU 内核堆栈</strong>。<br>每个处理器使用单独的内核堆栈，以防止它们干扰彼此的执行。该数组 <code>percpu_kstacks[NCPU][KSTKSIZE]</code>为 NCPU 的内核堆栈保留空间。</p>
<p>将每个 CPU 的内核堆栈映射到该区域，保护页面充当它们之间的缓冲区。CPU 0 的堆栈仍将从<code>KSTACKTOP</code>; CPU 1 的堆栈将从<code>KSTKGAP</code>CPU 0 堆栈底部下方的字节开始，依此类推。<code>inc/memlayout.h</code>显示映射布局。</p>
</li>
<li><p><strong>每个CPU TSS 和 TSS 描述符</strong>。<br>每个 CPU 的任务状态段 (TSS) 也需要用于指定每个 CPU 的内核堆栈所在的位置。CPU <em>i</em>的 TSS存储在 中<code>cpus[i].cpu_ts</code>，相应的 TSS 描述符在 GDT 条目中定义<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>。<code>kern/trap.c 中ts</code>定义的全局变量将不再有用。</p>
</li>
<li><p><strong>每个 CPU 当前环境指针</strong>。<br>由于每个 CPU 可以同时运行不同的用户进程，我们重新定义了符号<code>curenv</code>来引用 <code>cpus[cpunum()].cpu_env</code>（或<code>thiscpu-&gt;cpu_env</code>），它指向<em>当前</em>在<em>当前</em>CPU（运行代码的 CPU）上执行 的环境。</p>
</li>
<li><p><strong>每个 CPU 系统寄存器</strong>。<br>所有寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，例如<code>lcr3()</code>， <code>ltr()</code>，<code>lgdt()</code>，<code>lidt()</code>等，必须进行一次各CPU上执行。函数<code>env_init_percpu()</code> 和<code>trap_init_percpu()</code>就是为此目的而定义的。</p>
</li>
</ul>
<p>给出AP初始化的部分</p>
<p>boot_aps()：</p>
<ol>
<li>分配空闲内存给CPU</li>
<li>按时启动CPU</li>
<li>给定CPU应该访问栈的位置mpentry</li>
<li>等待基本设置</li>
</ol>
<p>mp_main()：</p>
<ol>
<li>为每个在函数里可见的CPU进行kern_pgdir来EIP的切换，并进行独有的lapic，进程，中断初始化</li>
<li>调用sched_yield()</li>
<li>当CPU准备好的时候执行进程（用户环境）</li>
</ol>
<p>AP 引导期间的控制流传输</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于SMP，我们的前面lab都是对这个CPU操作。</span></span><br><span class="line"><span class="comment">//对于AP，我们基本流程为boot_aps-&gt;mpentry.S-&gt;mp_main，</span></span><br><span class="line"><span class="comment">//对于每个AP，我们使用数组来存储cpu，针对每个cpu分配gdt，内存，特定的页表，栈，寄存器，来保证每个cpu陷入内核都是不一样的堆栈。然后我们分配完页表，并检查cpu state之后，我们会执行用户环境。</span></span><br></pre></td></tr></table></figure>

<p>page_init()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于base memroy中需要将MPENTRY_PADDR需要将符合的部分use，所以在修改这部分代码</span></span><br><span class="line"><span class="keyword">if</span>(i == MPENTRY_PADDR / PGSIZE)&#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">	pages[i].pp_link = <span class="literal">NULL</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题</strong></p>
<ol>
<li>将<code>kern/mpentry.S</code>与 <code>boot/boot.S 并排比较</code>。记住<code>kern/mpentry.S</code> 被编译并链接到上面运行，<code>KERNBASE</code>就像内核中的其他东西一样，宏的目的是 <code>MPBOOTPHYS</code>什么？为什么需要在<code>kern/mpentry.S 中</code>而不是在 <code>boot/boot.S 中</code>？换句话说，如果在<code>kern/mpentry.S</code>中省略它会出什么问题？<br>提示：回忆一下我们在实验 1 中讨论过的链接地址和加载地址之间的区别。</li>
</ol>
<p>和boot.S区别</p>
<p>1.不开启A20来进入保护模式</p>
<p>2.不通过linker进行符号表的加载，而是通过.code16来保证实模式下，MPBOOTPHS来计算加载地址</p>
<p>那么省略到底会有什么问题？首先是加载地址会被转换，而不通过宏，就会被linker加载到高地址，而不是低地址（boot时候进入A20保护模式已经有了一个简单的页表来映射到高地址）。</p>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><p>根据exercise2的理解，可以按照memlayout.h来写出代码</p>
<p>mem_init_mp()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 从 KSTACKTOP SMP顶开始向下映射每个cpu的内核栈：for &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 我们对每个CPU从0开始，但是从顶KSTACKTOP向下映射，同时每个栈分成实际部分和缓冲区，来保证“guard”，因此percpu_kstacks[i] 是内核栈的va我们使用宏转换为pa， 想要映射的部分顶是 KSTACKTOP - i * (KSTKSIZE + KSTKGAP)，权限是内核RW：PTE_W</span></span><br><span class="line">	<span class="comment">// mem_init:</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line">	<span class="comment">//          -- backed by physical memory</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line">	<span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line">	<span class="comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span></span><br><span class="line">	<span class="comment">//             Known as a &quot;guard page&quot;.</span></span><br><span class="line">	<span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">		boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP), KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);<span class="comment">//这里的va最为0号不必有gap，否则会报错</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><p><code>trap_init_percpu()</code> ( <code>kern/trap.c</code> ) 中 的代码初始化 BSP 的 TSS 和 TSS 描述符。它在实验 3 中工作，但在其他 CPU 上运行时不正确。更改代码，使其可以在所有 CPU 上运行。（注意：您的新代码不应再使用全局 <code>ts</code>变量。）</p>
<p>完成上述练习后，在带有 4 个 CPU 的 QEMU 中使用make qemu CPUS&#x3D;4(或make qemu-nox CPUS&#x3D;4)运行 JOS ，您应该看到如下输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">物理内存：<span class="number">66556</span>K 可用，base = <span class="number">640</span>K，extended = <span class="number">65532</span>K </span><br><span class="line">check_page_alloc() 成功！</span><br><span class="line">check_page() 成功！</span><br><span class="line">check_kern_pgdir() 成功！</span><br><span class="line">check_page_installed_pgdir() 成功！</span><br><span class="line">SMP：CPU <span class="number">0</span> 发现 <span class="number">4</span> 个 CPU</span><br><span class="line">启用中断：<span class="number">1</span> <span class="number">2</span> </span><br><span class="line">SMP：CPU <span class="number">1</span> 启动</span><br><span class="line">SMP：CPU <span class="number">2</span> 启动</span><br><span class="line">SMP：CPU <span class="number">3</span> 启动</span><br></pre></td></tr></table></figure>

<p>对于gdt简单总结：gdt存放了cpu的Taskstate里的tss，而用户环境则通过CPUInfo里的env指针来找到，tss顺序存放，而不是linux初版本的那样LDT和TSS成对顺序存放</p>
<p>trap_init_percpu()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> i = thiscpu-&gt;cpu_id;</span><br><span class="line">	<span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">	<span class="comment">// when we trap to the kernel.</span></span><br><span class="line">	<span class="comment">// 对cpu的特定修改</span></span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">	<span class="comment">//对于gdt也要修改，</span></span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+i] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+i].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">	<span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">	<span class="comment">// 加载tss选择子来找到描述符，否则会报错。。。</span></span><br><span class="line">	<span class="comment">// 其中：我们往后加载时会将tss slector &gt;&gt; 3来忽略3bits作为索引，因此前后都要修改初始化的值确保最终加载正确</span></span><br><span class="line">	ltr(GD_TSS0+(i &lt;&lt; <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><p>我们知道通过多CPU来完成多线程，但是由于大内核锁，因此内核线程切换都是用户环境下才能进行切换。若此而言，一个进程可以约等于一个线程。当我们切换进程时，仍然在同一个线程（内核独有部分不变）。</p>
<p><code>kern/spinlock.h</code>声明了大内核锁，即 <code>kernel_lock</code>. 它还提供<code>lock_kernel()</code> 和<code>unlock_kernel()</code>，获取和释放锁的快捷方式。您应该在四个位置应用大内核锁：</p>
<ul>
<li>在 中<code>i386_init()</code>，在 BSP 唤醒其他 CPU 之前获取锁。</li>
<li>中<code>mp_main()</code>，初始化AP后获取锁，然后调用<code>sched_yield()</code>在该AP上启动运行环境。</li>
<li>在<code>trap()</code>，从用户模式被困时获取锁。要确定陷阱发生在用户模式还是内核模式，请检查<code>tf_cs</code>.</li>
<li>在 中<code>env_run()</code>，<em>在</em> 切换到用户模式<em>之前</em>释放锁定。不要太早或太晚这样做，否则你会遇到竞争或僵局。给出锁的实现代码：jos现在并没有实现sleep（协调）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们将要插入代码原型</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_kernel</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unlock_kernel</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//实际上是调用 了spin_lock(&amp;kernel_lock)，给出关键代码实现xchg</span></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;pause&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面的说明很清楚，这里省略代码粘贴</p>
<p><strong>题</strong></p>
<ol>
<li>似乎使用大内核锁可以保证一次只有一个 CPU 可以运行内核代码。为什么我们仍然需要为每个 CPU 使用单独的内核堆栈？描述一个使用共享内核堆栈会出错的场景，即使有大内核锁的保护。</li>
</ol>
<p>在trapentry.S中，锁之前就压入了部分寄存器，所以如果共享堆栈，另一个CPU抢占使用就会破坏这部分。</p>
<h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h2><p>实现循环调度：env数组中选择一个合适的新环境，进行修改状态，然后调度切换</p>
<p>运行make qemu。在终止之前，您应该看到环境在彼此之间来回切换五次，如下所示。</p>
<p>还使用多个 CPU 进行测试：make qemu CPUS&#x3D;2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">您好，我是环境 <span class="number">00001000</span>。</span><br><span class="line">您好，我是环境 <span class="number">00001001</span>。</span><br><span class="line">您好，我是环境 <span class="number">00001002</span>。</span><br><span class="line">返回环境 <span class="number">00001000</span>，迭代 <span class="number">0</span>。</span><br><span class="line">返回环境 <span class="number">00001001</span>，迭代 <span class="number">0</span>。</span><br><span class="line">返回环境 <span class="number">00001002</span>，迭代 <span class="number">0</span> </span><br><span class="line">。环境 <span class="number">00001000</span>，迭代 <span class="number">1</span>。</span><br><span class="line">回到环境 <span class="number">00001001</span>，迭代 <span class="number">1</span>。</span><br><span class="line">回到环境 <span class="number">00001002</span>，迭代 <span class="number">1</span> </span><br><span class="line">。...</span><br></pre></td></tr></table></figure>

<p>sched_yield()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(curenv)  cur = ENVX(curenv-&gt;env_id);<span class="comment">//这里的curenv无判断即会kernel page fault，原因是env_id不存在，于是内核中断尝试寻找相应的映射，我们的策略应该是从0开始找可运行的进程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; i++)&#123;</span><br><span class="line">	<span class="type">int</span> j = (i + cur) % NENV;</span><br><span class="line">	<span class="keyword">if</span>(envs[j].env_status == RUNNABLE)&#123;</span><br><span class="line">		env_run(&amp;envs[j]);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == RUNNING)env_run(curenv);</span><br></pre></td></tr></table></figure>

<p><strong>题</strong></p>
<ol>
<li>我们的<code>env_run()</code>调用<code>lcr3()</code>. 在调用之前和之后 <code>lcr3()</code>，您的代码会引用e。加载<code>%cr3</code>寄存器后，MMU 使用的寻址上下文会立即更改。为什么指针<code>e</code>在寻址切换之前和之后都可以解引用？</li>
</ol>
<p>e是thiscpu_curenv，对于内核来说不过是对于envs数组的引用。因此kern_pgdir和env_pgdir映射是一样的，实际上编写env_pgdir就是以前者为模板。</p>
<ol start="2">
<li>每当内核从一种环境切换到另一种环境时，它必须确保旧环境的寄存器得到保存，以便以后可以正确恢复。为什么？这是在哪里发生的？</li>
</ol>
<p>trapframe，在环境进入中断时压入寄存器，在trap从内核栈保存入tf，在env_run前pop_tf来读取然后进入新环境。</p>
<h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><p>创造系统调用来使用户能够创建进程，而不是不同CPU下内核里创建env，善用kern&#x2F;env.c中的函数envid2env()，它额外会进行必要检查</p>
<ol>
<li>sys_exofork()：创建子进程，不进行映射，但寄存器复制，使用id和0返回值来区分父子</li>
<li>sys_env_set_status：设置进程状态为ENV_RUNNABLE或ENV_NOT_RUNNABLE。</li>
<li>sys_page_alloc：为进程分配物理页</li>
<li>sys_page_map：拷贝页表来共享映射内存</li>
<li>sys_page_unmap：释放页面映射</li>
</ol>
<p>sys_exofork(void)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line">	<span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line">	<span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line">	<span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">	<span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = env_alloc(&amp;e, curenv-&gt;env_id);    </span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;<span class="comment">//bad env_alloc</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_tf = curenv-&gt;env_tf;			</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;   </span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;		</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">	<span class="comment">//返回user-mode时候pop_tf，父进程返回trap_dispatch后eax设置为id,但是子进程通过env_run才从中断返回，所以eax为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sys_env_set_status(envid_t envid, int status):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span></span><br><span class="line">	<span class="comment">// envid to a struct Env.</span></span><br><span class="line">	<span class="comment">// You should set envid2env&#x27;s third argument to 1, which will</span></span><br><span class="line">	<span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">	<span class="comment">// envid&#x27;s status.</span></span><br><span class="line">	<span class="keyword">if</span> (status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_RUNNABLE) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sys_page_alloc(envid_t envid, void *va, int perm):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">	<span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span> 									</span><br><span class="line">	<span class="type">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;	<span class="comment">//bad_env</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((va &gt;= (<span class="type">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) <span class="keyword">return</span> -E_INVAL;		</span><br><span class="line">	<span class="type">int</span> flag = PTE_U | PTE_P;</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; flag) != flag) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pg</span> =</span> page_alloc(<span class="number">1</span>);			</span><br><span class="line">	<span class="keyword">if</span> (!pg) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	ret = page_insert(e-&gt;env_pgdir, pg, va, perm);	</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		page_free(pg);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sys_page_map(envid_t srcenvid, void *srcva,envid_t dstenvid, void *dstva, int perm):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">	     <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">	<span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">se</span>, *<span class="title">de</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = envid2env(srcenvid, &amp;se, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;	<span class="comment">//bad_env</span></span><br><span class="line">	ret = envid2env(dstenvid, &amp;de, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;	<span class="comment">//bad_env</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line">	<span class="comment">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line">	<span class="keyword">if</span> (srcva &gt;= (<span class="type">void</span>*)UTOP || dstva &gt;= (<span class="type">void</span>*)UTOP || </span><br><span class="line">		ROUNDDOWN(srcva,PGSIZE) != srcva || ROUNDDOWN(dstva,PGSIZE) != dstva) </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	-E_INVAL is srcva is not mapped in srcenvid&#x27;s address space.</span></span><br><span class="line">	<span class="type">pte_t</span> *pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pg</span> =</span> page_lookup(se-&gt;env_pgdir, srcva, &amp;pte);</span><br><span class="line">	<span class="keyword">if</span> (!pg) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line">	<span class="type">int</span> flag = PTE_U|PTE_P;</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; flag) != flag) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid&#x27;s</span></span><br><span class="line">	<span class="comment">//		address space.</span></span><br><span class="line">	<span class="keyword">if</span> (((*pte&amp;PTE_W) == <span class="number">0</span>) &amp;&amp; (perm&amp;PTE_W)) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	-E_NO_MEM if there&#x27;s no memory to allocate any necessary page tables.</span></span><br><span class="line">	ret = page_insert(de-&gt;env_pgdir, pg, dstva, perm);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sys_page_unmap(envid_t envid, void *va):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((va &gt;= (<span class="type">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	page_remove(env-&gt;env_pgdir, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a href="/2024/03/08/lab4%EF%BC%9APartB/" title="lab4：PartB">lab4：PartB</a>]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>lab3：PartB</title>
    <url>/2024/03/08/lab3%EF%BC%9APartB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="B-部分：页面错误、断点异常和系统调用"><a href="#B-部分：页面错误、断点异常和系统调用" class="headerlink" title="B 部分：页面错误、断点异常和系统调用"></a>B 部分：页面错误、断点异常和系统调用</h1><p>改进异常代码，进行更细化的处理。</p>
<p>分别以下实现</p>
<ol>
<li>增加页面错误处理函数</li>
<li>断点监视以便monitor使用</li>
<li>简单的系统调用实现</li>
<li>获取env_id的完善</li>
<li>缺页的简单处理</li>
</ol>
<h3 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h3><span id="more"></span>

<p>1.处理缺页</p>
<p>页错误异常，中断向量 14 ( <code>T_PGFLT</code>)，是一个特别重要的异常，我们将在本实验和下一个实验中大量练习。当处理器发生页面错误时，它会将导致错误的线性（即虚拟）地址存储在特殊的处理器控制寄存器<code>CR2 中</code>。在<code>trap.c 中，</code> 我们提供了一个特殊函数的开头 <code>page_fault_handler()</code>，用于处理页面错误异常。</p>
<p>修改<code>trap_dispatch()</code> 以将页面错误异常分派到<code>page_fault_handler()</code>. 您现在应该能够make grade 在<code>faultread</code>、<code>faultreadkernel</code>、 <code>faultwrite</code>和<code>faultwritekernel</code>测试中取得成功。如果其中任何一个不起作用，请找出原因并修复它们。请记住，您可以使用或 将JOS 引导到特定的用户程序中。例如，运行<em>hello</em>用户程序。 make run-<em>x</em>make run-<em>x</em>-noxmake run-hello-nox。</p>
<p>修改<code>trap_dispatch()</code> 以将页面错误异常分派到<code>page_fault_handler()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;<span class="comment">//缺页中断</span></span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.断点监视</p>
<p>断点异常，中断向量 3 ( <code>T_BRKPT</code>)，通常用于允许调试器通过用特殊的 1 字节<code>int3</code>软件中断指令临时替换相关程序指令来在程序代码中插入断点。</p>
<p>在 JOS 中，我们将稍微滥用此异常，将其转换为任何用户环境都可以用来调用 JOS 内核监视器的原始伪系统调用。</p>
<p>如果我们将 JOS 内核监视器视为原始调试器。例如，<code>panic()</code>在<code>lib/panic.c 中</code>的用户模式实现，在<code>int3</code>显示其panic消息后执行。</p>
<h3 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h3><p><code>trap_dispatch()</code> 添加中断向量 3 ( <code>T_BRKPT</code>)的处理，让用户代码能够调用监视器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">		monitor(tf);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<ol>
<li>断点测试用例将生成断点异常或一般保护错误，具体取决于您如何在 IDT 中初始化断点条目（即，您对SETGATE设置）。为什么？您需要如何设置它才能使断点异常按照上面指定的方式工作，哪些不正确的设置会导致它触发一般保护故障？</li>
</ol>
<p>DPL必须设置成3.因为在中断判断时，必须判断RPL，CPL是优先级高于等于这个门描述符DPL。所以如果int3设置DPL为特权级0，那么就会出发故障。</p>
<p>更一般地说，CPL会更改来进入&#x2F;退出内核态，RPL不会更改，所以当我们判断DPL时，DPL高特权就保证了用户不能访问内核代码和数据（压栈是内核里的中断代码指令，如果保护异常就会提前从中断返回）。因此本lab中只有int3的trap和syscallDPL设置为3，让用户能访问。</p>
<ol start="2">
<li>·你觉得中断机制哪部分最重要，考虑到<code>user/softint</code>测试程序的作用？</li>
</ol>
<p>特权检查和保护现场</p>
<p>3.系统调用</p>
<p>用户进程通过调用系统调用来要求内核为它们做事。当用户进程调用系统调用时，处理器进入内核模式，处理器和内核协同保存用户进程的状态，内核执行适当的代码以进行系统调用，然后恢复用户进程。</p>
<p>在 JOS 内核中，我们将使用<code>int</code> 导致处理器中断的指令。特别是，我们将<code>int $0x30</code> 用作系统调用中断。我们已经<code>T_SYSCALL</code>为您定义了常量 为 48 (0x30)。您必须设置中断描述符以允许用户进程引起该中断。注意，中断 0x30 不能由硬件产生，所以不会因为允许用户代码产生而造成歧义。</p>
<p>应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中四处游荡。系统调用号会去<code>%eax</code>，和参数（其中最多5个）将去<code>%edx</code>， <code>%ecx</code>，<code>%ebx</code>，<code>%edi</code>，和<code>%esi</code>分别。内核将返回值传回<code>%eax</code>. 调用系统调用的汇编代码已为您编写， <code>syscall()</code>在<code>lib/syscall.c 中</code>。你应该通读它并确保你理解发生了什么。</p>
<h3 id="Exercise7"><a href="#Exercise7" class="headerlink" title="Exercise7"></a>Exercise7</h3><p><code>int $0x30</code> 用作系统调用中断。已经<code>T_SYSCALL</code>为您定义了常量 为 48 (0x30)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(th_syscall, T_SYSCALL)<span class="comment">//trapentry.S的中断预处理</span></span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, th_syscall, <span class="number">3</span>);<span class="comment">//trap.c的trap_init()的IDT向量设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL) &#123; <span class="comment">//trap.c的trap_dispatch()用来跳转到syscall系统调用</span></span><br><span class="line">		tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">			tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>syscall()：就是系统调用跳转表的简单实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="type">int32_t</span> ret;</span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;    <span class="comment">//eax保存的系统调用号</span></span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="type">char</span> *)a1, (<span class="type">size_t</span>)a2);</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			ret = sys_cgetc();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			ret = sys_getenvid();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			ret = sys_env_destroy((<span class="type">envid_t</span>)a1);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.获取env_id</p>
<p>用户程序开始运行在<code>lib/entry.S</code>的顶部 。经过一些设置后，此代码<code>libmain()</code>在<code>lib/libmain.c 中</code>调用, 。您应该修改<code>libmain()</code>以初始化全局指针 <code>thisenv</code>以指向数组<code>struct Env</code>中的此环境 <code>envs[]</code>。（请注意，<code>lib/entry.S</code>已经定义<code>envs</code> 为指向<code>UENVS</code>您在 A 部分中设置的映射。）提示：查看<code>inc/env.h</code>并使用 <code>sys_getenvid</code>.</p>
<p><code>libmain()</code>然后调用<code>umain</code>，在 hello 程序的情况下，它在 <code>user/hello.c 中</code>。请注意，在打印“ <code>hello, world</code> ”后，它会尝试访问 <code>thisenv-&gt;env_id</code>. 这就是它较早出错的原因。现在您已经<code>thisenv</code>正确初始化，它应该不会出错。如果它仍然有问题，您可能没有映射<code>UENVS</code>用户可读的 区域（回到<code>pmap.c 的</code>A 部分 ；这是我们第一次实际使用该<code>UENVS</code>区域）。</p>
<h3 id="Exercise8"><a href="#Exercise8" class="headerlink" title="Exercise8"></a>Exercise8</h3><p>确保make grade 在<code>hello</code>测试中取得成功。</p>
<p><code>libmain()</code>以初始化全局指针 <code>thisenv</code>以指向数组<code>struct Env</code>中的此环境 <code>envs[]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="type">envid_t</span> envid = sys_getenvid();    <span class="comment">//系统调用，最终会被syscall处理</span></span><br><span class="line">	thisenv = envs + ENVX(envid);      <span class="comment">//获取Env结构指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">		binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call user main routine</span></span><br><span class="line">	umain(argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// exit gracefully</span></span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>user&#x2F;hello.c应该thisenv就有效了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	cprintf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">	cprintf(<span class="string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.缺页</p>
<p>您现在将使用一种机制来解决这两个问题，该机制会检查从用户空间传递到内核的所有指针。当程序向内核传递一个指针时，内核将检查地址是否在地址空间的用户部分，以及页表是否允许内存操作。</p>
<p>因此，内核永远不会因为取消引用用户提供的指针而遭受页面错误。如果内核发生页面错误，它应该panic</p>
<h3 id="Exercise9"><a href="#Exercise9" class="headerlink" title="Exercise9"></a>Exercise9</h3><p>更改<code>kern/trap.c</code>，如果页面错误在内核模式下发生的，panic。</p>
<p>提示：判断故障是发生在用户态还是内核态，检查<code>tf_cs</code>.</p>
<p>读<code>user_mem_assert</code>入<code>kern/pmap.c</code> 并<code>user_mem_check</code>在同一个文件中实现。</p>
<p>将<code>kern/syscall.c</code>更改为系统调用的完整性检查参数。</p>
<p>启动内核，运行<code>user/buggyhello</code>。环境应予以销毁，内核应该<em>不会</em>panic。你应该看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">00001000</span>] va <span class="number">00000001</span> 的 user_mem_check 断言失败</span><br><span class="line">[<span class="number">00001000</span>] 免费环境 <span class="number">00001000</span></span><br><span class="line">破坏了唯一的环境——无事可做！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，改变<code>debuginfo_eip</code>在 <code>kern/ kdebug.c</code>调用<code>user_mem_check</code>上 <code>usd</code>，<code>stabs</code>和 <code>stabstr</code>。如果您现在运行 <code>user/breakpoint</code>，应该能够backtrace从内核监视器运行 并在内核因页面错误而恐慌之前看到回溯遍历到<code>lib/libmain.c</code>。</p>
<p>接下来给出代码：</p>
<p>更改<code>kern/trap.c/page_fault_handler</code>处理缺页中断:如果页面错误在内核模式下发生的应该panic</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) </span><br><span class="line">		panic(<span class="string">&quot;page_fault_handler():page fault in kernel mode!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后按照要求补全一些细节：</p>
<p>kern&#x2F;pmap.c&#x2F;user_mem_check()进行检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	cprintf(<span class="string">&quot;user_mem_check va: %x, len: %x\n&quot;</span>, va, len);</span><br><span class="line">	<span class="type">uint32_t</span> start = (<span class="type">uint32_t</span>) ROUNDDOWN(va, PGSIZE); </span><br><span class="line">	<span class="type">uint32_t</span> end = (<span class="type">uint32_t</span>) ROUNDUP(va+len, PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> i = start; i &lt; end; i += PGSIZE) &#123;</span><br><span class="line">		<span class="type">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, (<span class="type">void</span>*)i, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> ((i &gt;= ULIM) || !pte || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm)) &#123;        </span><br><span class="line">			user_mem_check_addr = (i &lt; (<span class="type">uint32_t</span>)va ? (<span class="type">uint32_t</span>)va : i);                </span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(<span class="string">&quot;user_mem_check success va: %x, len: %x\n&quot;</span>, va, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kern&#x2F;syscall.c进行我们的sys_cputs的检查curenv指针指向的函数调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">	<span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	user_mem_assert(curenv, s, len, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">	cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise10"><a href="#Exercise10" class="headerlink" title="Exercise10"></a>Exercise10</h3><p>启动内核，运行<code>user/evilhello</code>。你应该看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">00000000</span>] 新环境 <span class="number">00001000</span></span><br><span class="line">...</span><br><span class="line">[<span class="number">00001000</span>] va f010000c 的 user_mem_check 断言失败</span><br><span class="line">[<span class="number">00001000</span>] 免费环境 <span class="number">00001000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上细节补充完毕后实验10也完成了</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/008i3skNly1gw126btkwij30ie0jamzw.jpg"></p>
<p>总结一下我们的中断处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>trap_init初始化中断向量表</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>handler宏的预处理和_alltraps处理负责中断的保护现场：trapframe压栈，然后call trap</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>trap调用trap_dispatch</span><br><span class="line">trap_dispatch负责中断向量跳转，实验只实现了syscall，缺页，trap,特权保护的跳转或直接处理</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>syscall负责调用内核函数，实验采用<span class="keyword">switch</span>只实现了几个内核函数的call</span><br><span class="line"></span><br><span class="line">handler-&gt;_alltraps-&gt;trap-&gt;trap_dispatch-&gt;syscall-&gt;sys_cputs-&gt;cprintf</span><br><span class="line">																			 -&gt;monitor</span><br><span class="line">																			 -&gt;page_fault_handler</span><br></pre></td></tr></table></figure>

<p>总结一下整个流程</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">系统调用-&gt;（实际上进入了内核）中断处理-&gt;调用内核函数-&gt;调用后ret返回trap函数-&gt;env<span class="built_in">_</span>run返回用户环境</span><br><span class="line"></span><br><span class="line">一些问题</span><br><span class="line">1.为什么有lib/syscall和kern/syscall分别？</span><br><span class="line">因为是系统调用和中断处理跳转内核函数的区别</span><br><span class="line"></span><br><span class="line">2.为什么压栈保护现场要分两次？</span><br><span class="line">因为第一次压栈有错误码的分别，第二次cs，ds段寄存器和通用寄存器，节省代码量，并且通用寄存器这样的部分trapframe还没存储</span><br><span class="line"></span><br><span class="line">3.为什么trap需要保存栈的trapframe到env的trapframe结构？已经有栈不行吗？</span><br><span class="line">因为当fork时候也同样要从中断结尾处返回，因此设计了env<span class="built_in">_</span>run，在fork后和trap结尾都被调用，通过env的trapframe“返回”用户态，从而保证了合理。对于栈的trapframe就忽略，也是跟函数返回的不同。</span><br><span class="line"></span><br><span class="line">4.什么是CPL，RPL，DPL？</span><br><span class="line">RPL是选择子的末2位，CPL就是cs寄存器（存放代码段选择子）的末两位，所以后者是前者的特例。并且当我们从用户态进入内核RPL认为是调用门的特权级，会被区分。DPL是描述符的特权级。我们要求max&#123;CPL,RPL&#125;和DPL比较。举个例子，当我们中断处理时，中断是内核的函数，CPL=0，但是RPL=3，所以我们中断判断特权才要让int和syscall保持DPL为3，否则会就会产生保护出错，exercise6问题就是问这个的。</span><br><span class="line"></span><br><span class="line">5.CPL和DPL和PTE<span class="built_in">_</span>X有什么区别？不都是特权保护？</span><br><span class="line">对，但是还是有不同。由于我们跟linux一样，JOS放弃了分段管理转向了分页管理。但是硬件强行要求分段。所以段选择子，段描述符里的特权保留，但是描述符里的地址（16位）全部都是0.因此当我们必须规定在分页管理下页的访问权限（PTE<span class="built_in">_</span>U这样），至于CPL，RPL，DPL权限检查，除了在中断时候有用（因为没访问页所以可以用得上），其他情况下设置不应该影响分页的检查才行。具体来说，16位的访问段大小实在是太小了，所以除了访问GDT，IDT的响应检查等以外。其他的情况下比如guard page，对于用户的特权级就是通过，但是PTE检查就是失败，无论是内核还是用户都会经历这样的过程。从而合理。</span><br><span class="line"></span><br><span class="line">6.用户访问内存为什么会中断？</span><br><span class="line">并不是读写内存就会中断，大部分情况下是你使用系统调用才会中断，你对text，data，栈，堆读写都不会中断。甚至如果你绕过对文件的读写的系统调用，使用mmap直接映射到用户空间，那么你的读写也不会有系统调用，也就不会中断了。</span><br><span class="line">不要弄混特权检查和中断，是中断需要对特权检查来保证用户进入内核后的约束，而特权检查是访问内存的必经之路。</span><br></pre></td></tr></table></figure>

<p>代码在这：<a href="https://github.com/sakura-mac/mit_6.828_jos">Source Code</a></p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>lab3：用户环境(PartA)</title>
    <url>/2024/03/08/lab3%EF%BC%9APartA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<p>作者说：从这个实验开始，我逐渐开始感觉到随着理论的补充和实验能力的提升，此后将直接按照exercise顺序记录实验: 将按情况删减“关键文件注释”部分，取而代之是实验笔记中的更直接，简短的数据结构和函数。</p>
<p>大家应该要多看课程，理论书籍，而不是一开始直接上实验：因为大部分实验都是理论的简化实现（逃）。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，我们将实现运行受保护的用户模式环境（即“进程”）所需的基本内核工具。</p>
<p>第一部分将实现内核中创建进程，手动加载磁盘代码中（没有文件系统），中断初始化。</p>
<p>第二部分将实现系统调用，特权保护，缺页的基本处理。</p>
<p>后续实验将丰富中断处理。</p>
<span id="more"></span>

<p><strong>注意：</strong> 在本实验中，术语<em>用户环境</em>和<em>进程</em>可互换 - 两者均指允许您运行程序的抽象。我们引入术语“环境”而不是传统术语“进程”是为了强调 JOS 环境和 UNIX 进程提供不同的接口，并且不提供相同的语义。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git checkout lab3</span><br><span class="line">$git merge lab2</span><br></pre></td></tr></table></figure>

<p>实验 3 包含许多新的源文件，您应该浏览这些文件：</p>
<table>
<thead>
<tr>
<th><code>inc/</code></th>
<th><code>env.h</code></th>
<th>用户模式环境的公共定义</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><code>trap.h</code></td>
<td>陷阱处理的公共定义</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>从用户环境到内核的系统调用的公共定义</td>
</tr>
<tr>
<td></td>
<td><code>lib</code></td>
<td>用户模式库的公共定义</td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code></td>
<td>用户模式环境的内核私有定义</td>
</tr>
<tr>
<td></td>
<td><code>env.c</code></td>
<td>实现用户模式环境的内核代码</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>内核私有陷阱处理定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.c</code></td>
<td>陷阱处理代码</td>
</tr>
<tr>
<td></td>
<td><code>Traentry.S</code></td>
<td>汇编语言陷阱处理程序入口点</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>系统调用处理的内核私有定义</td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>系统调用实现代码</td>
</tr>
<tr>
<td><code>lib/</code></td>
<td>Makefrag</td>
<td>构建用户模式库的 Makefile 片段： <code>obj/lib/libjos.a</code></td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>用户环境的汇编语言入口点</td>
</tr>
<tr>
<td></td>
<td><code>libmain</code></td>
<td>从<code>entry.S 调用的</code>用户模式库设置代码</td>
</tr>
<tr>
<td></td>
<td><code>syscall</code></td>
<td>用户模式系统调用存根函数</td>
</tr>
<tr>
<td></td>
<td><code>console</code></td>
<td><code>putchar</code>和<code>getchar 的</code> 用户模式实现 ，提供控制台 I&#x2F;O</td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td><code>exit</code> 用户模式实现</td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td><code>panic</code> 用户模式实现</td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>用于检查内核实验室 3 代码的各种测试程序</td>
</tr>
</tbody></table>
<p>此外，我们为 lab2 分发的一些源文件在 lab3 中进行了修改。要查看差异，您可以键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff lab2</span><br></pre></td></tr></table></figure>

<p>您可能还想再看看<a href="https://pdos.csail.mit.edu/6.828/2017/labguide.html">实验室工具指南</a>，因为它包含有关调试与本实验室相关的用户代码的信息。</p>
<p>在本实验中，我们至少应该学会看内联汇编，尽管也可以不使用它来完成实验。至少，您需要能够理解我们提供给您的源代码中已经存在的内联汇编语言（“ <code>asm</code> ”语句）的片段。您可以在类<a href="https://pdos.csail.mit.edu/6.828/2017/reference.html">参考资料</a>页面上找到有关 GCC 内联汇编语言的多个信息来源。</p>
<h1 id="A-部分：用户环境和异常处理"><a href="#A-部分：用户环境和异常处理" class="headerlink" title="A 部分：用户环境和异常处理"></a>A 部分：用户环境和异常处理</h1><p>新的包含文件<code>inc/env.h</code> 包含 JOS 中用户环境的基本定义。内核使用<code>Env</code>数据结构来跟踪每个用户环境。在本实验中，您最初将只创建一个环境，但您需要设计 JOS 内核以支持多个进程；实验 4 将通过允许用户环境进入<code>fork</code>其他环境来完成。</p>
<p>正如您在<code>kern/env.c 中</code>看到的，内核维护着三个与env相关的主要全局变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Env *envs = NULL; // 所有进程</span><br><span class="line">struct Env *curenv = NULL; // 当前进程</span><br><span class="line">static struct Env *env_free_list; // 空闲进程表</span><br></pre></td></tr></table></figure>

<p>一旦 JOS 启动并运行，<code>envs</code>指针就会指向<code>Env</code>代表系统中所有环境的结构数组。在我们的设计中，JOS 内核将支持最多<code>NENV</code> 同时处于活动状态的环境，尽管在任何给定时间运行的环境通常会少得多。（<code>NENV</code>为常数宏定义在<code>inc / env.h</code>。）一旦它被分配，该<code>envs</code>阵列会包含的单个实例<code>Env</code>的数据结构为每个的<code>NENV</code>可能的环境。</p>
<p>JOS 内核将所有非活动<code>Env</code>结构保存在<code>env_free_list</code>. 这种设计允许轻松分配和释放环境，因为它们只需添加到空闲表或从空闲表中删除。</p>
<p>内核在任何给定时间使用该<code>curenv</code>符号来跟踪<em>当前正在执行的</em>环境。在启动期间，在运行第一个环境之前， <code>curenv</code>最初设置为<code>NULL</code>.</p>
<p>因此我们知道，这个设置跟lab2的PageInfo数组和free_list是一样的，只是“空闲”的定义不同：本实验中为未占用CPU的意思。</p>
<p><code>Env</code>结构在<code>inc/env.h 中</code>定义如下（尽管在未来的实验中将添加更多字段）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span> <span class="comment">// 保存的寄存器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span> <span class="comment">// 下一个自由环境</span></span><br><span class="line">	<span class="type">env_t</span> env_id; <span class="comment">// 唯一的环境标识符</span></span><br><span class="line">	<span class="type">env_t</span> env_parent_id; <span class="comment">// 此 env 的父级的 env_id</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span> <span class="comment">// 表示特殊的系统环境</span></span><br><span class="line">	<span class="type">unsigned</span> env_status; <span class="comment">// 环境状态</span></span><br><span class="line">	<span class="type">uint32_t</span> env_runs; <span class="comment">// 环境运行的次数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 地址空间</span></span><br><span class="line">	<span class="type">pde_t</span> *env_pgdir; <span class="comment">// 页目录的内核虚拟地址</span></span><br></pre></td></tr></table></figure>

<p>以下是这些<code>Env</code>字段的用途：</p>
<ul>
<li><p><strong>env_tf</strong>：</p>
<p>这个在<code>inc/trap.h 中</code>定义的结构保存了该环境<em>未</em>运行时为该环境保存的寄存器值：即，当内核或其他环境正在运行时。当从用户模式切换到内核模式时，内核会保存这些信息，以便稍后可以从中断处恢复环境。</p>
</li>
<li><p><strong>env_link</strong>：</p>
<p> <code>env_free_list</code>指向列表中的第一个空闲环境,然后每个空闲环境指向下一个空闲环境，从而构造空闲表，因此我们同样也知道curenv指向的环境此项为NULL。</p>
</li>
<li><p><strong>env_id</strong>：</p>
<p>内核在此处存储一个值，该值唯一标识当前使用此<code>Env</code>结构的环境（即，使用<code>envs</code>数组中的此特定插槽）。在用户环境终止后，内核可能会将相同的<code>Env</code>结构重新分配给不同的环境 - 但是这种重复利用至少会改变env_id来区分环境。即unix系统里的pid</p>
</li>
<li><p><strong>env_parent_id</strong>：</p>
<p>内核在此处存储<code>env_id</code> 创建此环境的环境的 。通过这种方式，环境可以形成一个“家谱”，这将有助于做出关于允许哪些环境对谁做什么的安全决策。这就构建了一个反向链表。</p>
</li>
<li><p><strong>env_type</strong>：</p>
<p>这用于区分特殊环境。对于大多数环境，它将是<code>ENV_TYPE_USER</code>. 我们将在后面的实验中为特殊系统服务环境引入更多类型。</p>
</li>
<li><p><strong>env_status</strong>：</p>
<p>此变量包含以下值之一：</p>
<p>1.<code>ENV_FREE</code>：表示<code>Env</code>结构处于非活动状态，因此在<code>env_free_list</code>.<code>ENV_RUNNABLE</code>：表示该<code>Env</code>结构表示等待在处理器上运行的环境。<strong>这就是“就绪态”</strong></p>
<p>2.<code>ENV_RUNNING</code>：表示<code>Env</code>结构代表当前运行的环境。<strong>这就是“运行态”</strong></p>
<p>3.<code>ENV_NOT_RUNNABLE</code>：表示该<code>Env</code>结构表示当前处于活动状态的环境，但它当前尚未准备好运行：例如，因为它正在等待来自另一个环境的进程间通信 (IPC)。<strong>这就是“阻塞态”</strong></p>
<p>4.<code>ENV_DYING</code>：表示该<code>Env</code>结构代表僵尸环境。僵尸环境将在下一次陷入内核时被释放。在实验 4 之前我们不会使用这个标志。<strong>这就是“僵尸态”</strong></p>
</li>
<li><p><strong>env_pgdir</strong> :</p>
<p>这个变量保存了 这个环境页面目录的内核<em>虚拟地址</em>。**(注意不是kern_pgdir，后面会创建这个部分)**</p>
</li>
</ul>
<p>与 Unix 进程一样，JOS 环境将“进程”和“地址空间”的概念结合在一起。线程主要由保存的寄存器（<code>env_tf</code>字段）定义，地址空间由 指向的页目录和页表定义 <code>env_pgdir</code>。运行环境，内核必须设置CPU与<em>两个</em>保存的寄存器和相应的地址空间。</p>
<p>我们<code>struct Env</code>的类似于xv6中<code>struct proc</code> 。两个结构都在一个结构中保存环境（即进程的）用户模式寄存器状态<code>Trapframe</code> 。在 JOS 中，单个环境没有像 xv6 中的进程那样拥有自己的内核堆栈。只能有一个JOS环境中进行活动在时间的内核，所以需要JOS只有一个 <em>单一的</em>内核堆栈。这点是和正常os不同的地方之一。</p>
<h2 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a>Exercise1</h2><p>在实验 2 中，我们在<code>mem_init()</code> 为<code>pages[]</code>数组分配了内存，该数组是内核用来跟踪哪些页是空闲的，哪些不是的表。您现在需要<code>mem_init()</code>进一步修改以分配一个类似的<code>Env</code>结构数组，称为<code>envs</code>.</p>
<p><code>mem_init()</code>在<code>kern/pmap.c 中</code> 修改 以分配和映射<code>envs</code>数组。这个数组完全由分配结构的<code>NENV</code>实例组成，<code>Env</code>就像你分配 <code>pages</code>数组的方式一样。与<code>pages</code>数组一样，内存支持 <code>envs</code>也应该映射到用户只读 <code>UENVS</code>（在<code>inc/memlayout.h 中</code>定义），以便用户进程可以从该数组中读取。</p>
<p>运行测试脚本确保 <code>check_kern_pgdir()</code>成功。</p>
<p>在写exercise代码前，给你这些部分函数的调用关系，希望对你有帮助</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">env_init()</span><br><span class="line">env_create()</span><br><span class="line">	env_alloc()</span><br><span class="line">		env_setup_vm()</span><br><span class="line">	load_icode()</span><br><span class="line">		region_alloc()</span><br><span class="line">env_run()</span><br><span class="line">	pop_tf()</span><br></pre></td></tr></table></figure>

<p>我们就像分配pages数组那样分配envs数组，做三件事</p>
<p>1.虚拟alloc，初始化0</p>
<p>2.页面分配，建立映射</p>
<p>3.权限设置</p>
<p>mem_init():分配用户环境表，建立映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">	envs = (<span class="keyword">struct</span> Env*)boot_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br><span class="line">	<span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br><span class="line"><span class="number">2</span>/<span class="number">3.</span></span><br><span class="line">	boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>

<h2 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a>Exercise2</h2><p>在文件<code>env.c 中</code>，完成以下函数的编码：</p>
<ul>
<li><p><code>env_init()</code></p>
<p>初始化数组<code>Env</code>中的所有结构<code>envs</code>并将它们添加到<code>env_free_list</code>. 还调用<code>env_init_percpu</code>，它使用单独的段为权限级别 0（内核）和权限级别 3（用户）配置分段硬件。</p>
</li>
<li><p><code>env_setup_vm()</code></p>
<p>为新环境分配页目录并初始化新环境地址空间的内核部分。</p>
</li>
<li><p><code>region_alloc()</code></p>
<p>为环境分配和映射物理内存</p>
</li>
<li><p><code>load_icode()</code></p>
<p>您将需要解析一个 ELF 二进制映像，就像引导加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。</p>
</li>
<li><p><code>env_create()</code></p>
<p>分配环境<code>env_alloc</code> 并调用<code>load_icode</code>将 ELF 二进制文件加载到其中。</p>
</li>
<li><p><code>env_run()</code></p>
<p>启动在用户模式下运行的给定环境。</p>
</li>
</ul>
<p>在编写这些函数时，您可能会发现新的 cprintf 的<code>%e</code> 很有用——它会打印与错误代码对应的描述。例如，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r = -E_NO_MEM;</span><br><span class="line">panic(<span class="string">&quot;env_alloc: %e&quot;</span>, r);</span><br></pre></td></tr></table></figure>

<p>会给出消息“env_alloc：out of memory”。</p>
<p>下面是调用用户代码之前的代码调用图。确保您了解每个步骤的目的。</p>
<ul>
<li><p><code>start</code>( <code>kern/entry.S</code>)</p>
</li>
<li><p><code>i386_init</code>( <code>kern/init.c</code>)</p>
<ul>
<li><p><code>cons_init</code></p>
</li>
<li><p><code>mem_init</code></p>
</li>
<li><p><code>env_init</code></p>
</li>
<li><p><code>trap_init</code> （此时仍不完整）</p>
</li>
<li><p><code>env_create</code></p>
</li>
<li><p><code>env_run</code></p>
<ul>
<li><code>env_pop_tf</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>完成后，您应该编译内核并在 QEMU 下运行它。如果一切顺利，您的系统应该进入用户空间并执行 <code>hello</code>二进制文件，直到它使用该<code>int</code>指令进行系统调用 。那时会有麻烦，因为 JOS 还没有设置硬件来允许从用户空间到内核的任何类型的转换。当CPU发现它没有设置处理这个系统调用中断时，就会产生一个通用保护异常，发现它不能处理一场，就会产生一个双故障异常，发现它也不能处理第二个异常，并最终放弃所谓的“三重故障”。通常，您会看到 CPU 复位和系统重新启动。虽然这对于遗留应用程序很重要（请参阅<a href="http://blogs.msdn.com/larryosterman/archive/2005/02/08/369243.aspx"> 此博客文章</a>原因的解释），这对内核开发来说很痛苦，所以使用 6.828 修补的 QEMU，您将看到寄存器转储和“三重故障”。信息。</p>
<p>给出env_pop_tf，他的作用就是中断返回时通过env里的trapframe恢复现场：<strong>因此当我们创建一个用户环境或者返回用户环境时，都会调用这个函数。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_pop_tf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tmovl %0,%%esp\n&quot;</span>				</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopal\n&quot;</span>						<span class="comment">//通用寄存器的pop</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%es\n&quot;</span>					</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%ds\n&quot;</span>					</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tiret\n&quot;</span>						<span class="comment">//从Trapframe pop tf_eip,tf_cs,tf_eflags,tf_esp,tf_ss到寄存器</span></span></span><br><span class="line"><span class="params">		: : <span class="string">&quot;g&quot;</span> (tf) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	panic(<span class="string">&quot;iret failed&quot;</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们很快就会解决这个问题，但现在我们可以使用调试器来检查我们是否正在进入用户模式。在 处使用make qemu-gdb并设置 GDB 断点<code>env_pop_tf</code>，这应该是您在实际进入用户模式之前点击的最后一个函数。使用si;单步执行此功能 处理器应在<code>iret</code>指令后进入用户模式。然后，您应该看到在用户环境中的可执行文件，这是第一个指令<code>cmpl</code>在标签说明书<code>start</code> 中<code>的lib / entry.S中</code>。现在用于在<code>hello</code>中的inb *0x…处设置断点 （请参阅<code>obj/user/hello.asm</code>以获取用户空间地址）。这个<code>int $0x30``sys_cputs()``````int</code>是向控制台显示字符的系统调用。如果你不能执行到<code>int</code>，那么你的地址空间设置或程序加载代码有问题；在继续之前返回并修复它。</p>
<p>env_init():就像我们前面构建free_list一样，保证每一次从env_free_list取出的都是最小的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	env_free_list = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;	<span class="comment">//如果你的直接让env_link指向i+1，最后env_free_list指向i=0，部分也行，不过实际情况并不是顺序分配，所以我们使用前插法</span></span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();    <span class="comment">//加载GDT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Env_setup_vm():给定struct Env *e指针，初始化用户页目录</p>
<p>做三件事</p>
<p>1.分配页，初始化页</p>
<p>2.将e-&gt;env_pgdir指向页，并将此页当作页目录初始化（模仿lab2的内核页目录）</p>
<p>3.权限设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))  <span class="comment">//分配一页，page alloc只会从空闲表中找一页，修改link部分为NULL，因此我们需要增加ref</span></span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	e-&gt;env_pgdir = (<span class="type">pde_t</span> *) page2kva(p);  <span class="comment">//页目录指向</span></span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE); <span class="comment">//模仿内核页目录</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;  <span class="comment">//模仿，修改页目录项为用户的</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>region_alloc():为每个用户，通过页目录e-&gt;env_pgdir和page_insert，为[va, va+len)分配物理内存,建立多页映射</p>
<p>做三件事</p>
<p>1.确定分配页的范围：va如果在页中就应该找到页基址，va+len反而应该在下一页的基址</p>
<p>2.page_alloc循环分配物理页</p>
<p>3..page_insert建立映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *start = ROUNDDOWN(va, PGSIZE), </span><br><span class="line">	<span class="type">void</span> *end = ROUNDUP(va+len, PGSIZE);</span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;<span class="comment">//开区间所以不等</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> page_alloc(<span class="number">0</span>); <span class="comment">//分配一个物理页</span></span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			panic(<span class="string">&quot;fault: region_alloc: page_alloc failed\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(page_insert(e-&gt;env_pgdir, p, start, PTE_W | PTE_U) != <span class="number">0</span>)&#123;<span class="comment">//建立映射,成功返回0</span></span><br><span class="line">			panic(<span class="string">&quot;fault: region_alloc: page_insert failed\n&quot;</span>);</span><br><span class="line">		&#125;;   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>load_icode():当内核初始化时，前面所说用户文件二进制插入：解析binary地址开始处的ELF文件，紧接着我们才能进入用户环境</p>
<p>做三件事</p>
<p>1.得到ELF header和其他有用的指针</p>
<p>2.模仿boot&#x2F;main.c,按照ELF头设置（ph-&gt;p_type &#x3D;&#x3D; ELF_PROG_LOAD）加载ELF段到用户虚拟内存（ph-&gt;p_va，大小ph-&gt;p_memsz），初始化bss为0（把binary + ph-&gt;p_offset，大小ph-&gt;p_filesz复制到ph-&gt;p_va，剩余部分置为0）</p>
<p>3.设置eip为entry，为用户的main栈分配内存，建立映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">ELF</span> =</span> (<span class="keyword">struct</span> Elf *) binary;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>;</span>				<span class="comment">//ELF header</span></span><br><span class="line">	<span class="type">int</span> ph_cnt;						<span class="comment">//load counter</span></span><br><span class="line">	<span class="keyword">if</span> (ELF-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">		panic(<span class="string">&quot;fault: The binary is not ELF format\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ELF-&gt;e_entry == <span class="number">0</span>)&#123;</span><br><span class="line">     panic(<span class="string">&quot;fault: The ELF file can&#x27;t be executed.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELF + ELF-&gt;e_phoff);<span class="comment">//得到ELF header指针</span></span><br><span class="line">	ph_cnt = ELF-&gt;e_phnum;<span class="comment">//得到load counter</span></span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));			<span class="comment">//设置cr3为用户页目录</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ph_cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ph[i].p_type == ELF_PROG_LOAD) &#123;		<span class="comment">//只加载LOAD类型的Segment</span></span><br><span class="line">			region_alloc(e, (<span class="type">void</span> *)ph[i].p_va, ph[i].p_memsz);<span class="comment">//用户态建立映射</span></span><br><span class="line">			<span class="built_in">memset</span>((<span class="type">void</span> *)ph[i].p_va, <span class="number">0</span>, ph[i].p_memsz);	<span class="comment">//分配为0</span></span><br><span class="line">			<span class="built_in">memcpy</span>((<span class="type">void</span> *)ph[i].p_va, binary + ph[i].p_offset, ph[i].p_filesz); <span class="comment">//不为0的部分</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	e-&gt;env_tf.tf_eip = ELF-&gt;e_entry;</span><br><span class="line">	<span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	region_alloc(e, (<span class="type">void</span> *) (USTACKTOP - PGSIZE), PGSIZE);<span class="comment">//建立main stack映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>env_create()：</p>
<p>1.申请一个env，设置用户type</p>
<p>2.加载ELF：使用load_icode</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span>((rc = env_alloc(&amp;e, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create failed: env_alloc failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>env_run(struct Env *e)：开始运行用户环境（按照jos注释要求写即可）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curenv = e;</span><br><span class="line">    curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    curenv-&gt;env_runs++;</span><br><span class="line">    lcr3(PADDR(curenv-&gt;env_pgdir));<span class="comment">//页目录切换</span></span><br><span class="line">    env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h2><p>我们应该让<code>int $0x30</code>的系统调用中断生效</p>
<p>阅读 <a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm">第9章，异常和中断</a> 的 <a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm">80386程序员手册</a> （或第5章的<a href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf"> IA-32开发者手册</a>）。</p>
<p>在本实验中，我们通常遵循 Intel 的中断、异常等术语。但是，异常、陷阱、中断、故障和中止等术语在架构或操作系统之间没有标准含义，并且经常在不考虑它们在特定架构（例如 x86）上的细微区别的情况下使用。当您在本实验室之外看到这些术语时，其含义可能略有不同。</p>
<h3 id="中断的意义"><a href="#中断的意义" class="headerlink" title="中断的意义"></a>中断的意义</h3><p>异常和中断都是“受保护的控制传输”，它们会导致处理器从用户模式切换到内核模式 (CPL&#x3D;0)，我们通常认为中断时外部处理器异步的信息传输，而异常一般是内部问题，比如除0异常。</p>
<p>但实际上对于代码，无论是硬件中断，还是CPU处理异常，都会进入统一的函数入口，在中断向量选择后进行不同处理。并且处理必须进行检查，以此保护内核。在 x86 上，两种机制协同工作以提供这种保护：</p>
<ol>
<li><p><strong>中断描述符表IDT。</strong> 处理器确保中断和异常只能<em>在内核本身确定</em>的几个特定的、定义良好的入口点处进入 <em>内核</em>，而不是在发生中断或异常时运行的代码。</p>
<p>x86 允许多达 256 个不同的中断或异常入口点进入内核，每个都有不同的<em>中断向量</em>。向量是 0 到 255 之间的数字。中断向量由中断源决定：不同的设备、错误条件和对内核的应用程序请求会生成具有不同向量的中断。CPU 使用向量作为处理器<em>中断描述符表</em>(IDT)的索引，内核在内核私有内存中设置该<em>表</em>，很像 GDT。处理器从该表中的相应条目加载：</p>
<ul>
<li>要加载到指令指针 ( <code>EIP</code> ) 寄存器中的值，指向指定用于处理该类型异常的内核代码。</li>
<li>要加载到代码段 ( <code>CS</code> ) 寄存器中的值，该值在位 0-1 中包含异常处理程序运行的特权级别。（在 JOS 中，所有异常都在内核模式下处理，特权级别为 0。）</li>
</ul>
</li>
<li><p><strong>任务状态段TSS。</strong> 处理器需要一个地方来保存中断或异常发生之前的<em>旧</em>处理器状态，例如 处理器调用异常处理程序之前的<code>EIP</code>和<code>CS</code>的原始值，以便异常处理程序稍后可以恢复旧状态并恢复中断代码从它停止的地方开始。但是这个旧处理器状态的保存区域必须反过来保护不受非特权用户模式代码的影响；否则错误或恶意的用户代码可能会危及内核。</p>
<p>出于这个原因，当 x86 处理器接受导致特权级别从用户模式更改为内核模式的中断或陷阱时，它也会切换到内核内存中的堆栈。称为<em>任务状态段</em>(TSS) 的结构指定了此堆栈所在的段选择器和地址。处理器推送（在这个新堆栈上） <code>SS</code>、<code>ESP</code>、<code>EFLAGS</code>、<code>CS</code>、<code>EIP</code>和一个可选的错误代码。然后它从中断描述符中加载<code>CS</code>和<code>EIP</code>，并设置<code>ESP</code>和<code>SS</code>以引用新堆栈。</p>
<p>尽管 TSS 很大并且可能有多种用途，但 JOS 仅使用它来定义处理器从用户模式转换到内核模式时应切换到的内核堆栈。由于“内核模式”是JOS特权级别0在x86，处理器使用<code>ESP0</code>和<code>SS0</code>的TSS的字段中输入内核模式时，以限定内核栈。JOS 不使用任何其他 TSS 字段。</p>
</li>
</ol>
<h3 id="异常和中断的类型"><a href="#异常和中断的类型" class="headerlink" title="异常和中断的类型"></a>异常和中断的类型</h3><p>x86 处理器可以在内部生成的所有同步异常都使用 0 到 31 之间的中断向量，因此映射到 IDT 条目 0-31。例如，页面错误总是通过向量 14 引起异常。大于 31 的中断向量仅用于 <em>软件中断</em>，它可以由<code>int</code>指令产生，或者异步<em>硬件中断</em>，由外部设备在需要注意时引起。</p>
<p>在本节中，我们将扩展 JOS 以处理向量 0-31 中内部生成的 x86 异常。在下一节中，我们将使 JOS 处理软件中断向量 48 (0x30)，JOS（相当随意）将其用作其系统调用中断向量。在实验 4 中，我们将扩展 JOS 以处理外部生成的硬件中断，例如时钟中断。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>让我们将这些部分放在一起并通过一个示例进行跟踪。假设处理器正在用户环境中执行代码并遇到试图除以零的除法指令。</p>
<ol>
<li><p>所述处理器切换到由定义的堆栈 <code>SS0</code>和<code>ESP0</code>的TSS的字段，它们在书将保存的值 <code>GD_KD</code>和<code>KSTACKTOP</code>分别。</p>
</li>
<li><p>处理器将异常参数推送到内核堆栈上，从地址开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KSTACKTOP</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| <span class="number">0x00000</span> | 旧SS | ” - <span class="number">4</span></span><br><span class="line">| 旧ESP | ” - <span class="number">8</span></span><br><span class="line">| 旧 EFLAGS | ” - <span class="number">12</span></span><br><span class="line">| <span class="number">0x00000</span> | 旧CS | “ - <span class="number">16</span></span><br><span class="line">| 旧EIP | <span class="string">&quot; - 20 &lt;---- ESP</span></span><br><span class="line"><span class="string">+--------------------+             </span></span><br><span class="line"><span class="string">   	</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为我们正在处理除法错误，即 x86 上的中断向量 0，处理器读取 IDT 条目 0 并将 <code>CS:EIP 设置</code>为指向条目描述的处理程序函数。</p>
</li>
<li><p>处理程序函数取得控制权并处理异常，例如通过终止用户环境。</p>
</li>
</ol>
<p>对于某些类型的 x86 异常，除了上面的五个word外，处理器还会将另一个包含*错误代码的word压入堆栈。页错误异常，编号 14，是一个重要的例子。请参阅 80386 手册以确定处理器推送错误代码的异常编号，以及错误代码在这种情况下的含义。当处理器推送错误代码时，当从用户模式进入时，堆栈将在异常处理程序的开头如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| <span class="number">0x00000</span> | 老SS | ” - <span class="number">4</span></span><br><span class="line">| 旧ESP | ” - <span class="number">8</span></span><br><span class="line">| 旧 EFLAGS | ” - <span class="number">12</span></span><br><span class="line">| <span class="number">0x00000</span> | 老CS | “ - <span class="number">16</span></span><br><span class="line">| 旧EIP | “ - <span class="number">20</span></span><br><span class="line">| 错误代码 | <span class="string">&quot; - 24 &lt;---- ESP</span></span><br><span class="line"><span class="string">+--------------------+             </span></span><br><span class="line"><span class="string">	</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套异常和中断"><a href="#嵌套异常和中断" class="headerlink" title="嵌套异常和中断"></a>嵌套异常和中断</h3><p>处理器可以从内核和用户模式接受异常和中断。然而，只有当从用户模式进入内核时，x86 处理器才会在将其旧寄存器状态推送到堆栈并通过 IDT 调用适当的异常处理程序之前自动切换堆栈。如果在中断或异常发生时处理器<em>已经</em>处于内核模式（<code>CS</code>寄存器的低 2 位已经为零），那么 CPU 只会在同一内核堆栈上压入更多值。通过这种方式，内核可以优雅地处<em>理由</em> 内核本身内的代码引起的<em>嵌套异常</em>。此功能是实施保护的重要工具，我们将在稍后有关系统调用的部分中看到。</p>
<p>如果处理器已经处于内核模式并出现嵌套异常，由于不需要切换堆栈，它不会保存旧的<code>SS</code>或<code>ESP</code>寄存器。对于不推送错误代码的异常类型，内核堆栈因此在异常处理程序入口处如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+--------------------+ &lt;---- 旧 ESP</span><br><span class="line">| 旧 EFLAGS | ” - <span class="number">4</span></span><br><span class="line">| <span class="number">0x00000</span> | 旧CS | ” - <span class="number">8</span></span><br><span class="line">| 旧EIP | ” - <span class="number">12</span></span><br><span class="line">+--------------------+             </span><br></pre></td></tr></table></figure>

<p>对于推送错误代码的异常类型，处理器会像以前一样在旧的<code>EIP</code>之后立即推送错误代码。</p>
<p>处理器的嵌套异常功能有一个可能的问题。如果处理器在已经处于内核模式时发生异常，并且由于任何原因（例如堆栈空间不足）而<em>无法将其旧状态推送到内核堆栈上</em>，那么处理器无法进行任何恢复，因此它只会重置自己。不用说，内核的设计应该避免这种情况发生。</p>
<h2 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h2><p>您现在应该拥有在 JOS 中设置 IDT 和处理异常所需的基本信息。现在，您将设置 IDT 来处理中断向量 0-31（处理器异常）。我们将在本实验的稍后部分处理系统调用中断，并在稍后的实验中添加中断 32-47（设备 IRQ）。</p>
<p>头文件<code>inc/trap.h</code>和<code>kern/trap.h</code> 包含与您需要熟悉的中断和异常相关的重要定义。文件<code>kern/trap.h</code>包含对内核严格私有的定义，而<code>inc/trap.h</code> 包含对用户级程序和库也可能有用的定义。</p>
<p>注意：0-31 范围内的一些异常由 Intel 定义为保留。由于它们永远不会由处理器生成，因此您如何处理它们并不重要。</p>
<p>您应该实现的总体控制流程如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      IDT trapentry.S trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">| &amp;handler1 |---------&gt; handler1: trap (<span class="keyword">struct</span> Trapframe *tf)</span><br><span class="line">| | <span class="comment">// code &#123;</span></span><br><span class="line">| | call trap <span class="comment">// 处理异常/中断</span></span><br><span class="line">| | <span class="comment">// ... &#125;</span></span><br><span class="line">+----------------+</span><br><span class="line">| &amp;handler2 |--------&gt; handler2：</span><br><span class="line">| | <span class="comment">// code</span></span><br><span class="line">| | call陷阱</span><br><span class="line">| | <span class="comment">// ...</span></span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">| &amp;handlerX |--------&gt; handlerX：</span><br><span class="line">| | <span class="comment">// code</span></span><br><span class="line">| | call陷阱</span><br><span class="line">| | <span class="comment">// ...</span></span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure>

<p>每个异常或中断都应该在<code>trapentry.S 中</code>有自己的处理程序， 并且<code>trap_init()</code>应该用这些处理程序的地址初始化 IDT。每个处理程序都应该在堆栈上构建一个<code>struct Trapframe</code> （参见<code>inc/trap.h</code>）并使用指向 Trapframe 的指针调用 <code>trap()</code>（在<code>trap.c 中</code>）。 <code>trap()</code>然后处理异常&#x2F;中断或分派到特定的处理程序函数。</p>
<p>编辑<code>trapentry.S</code>和<code>trap.c</code>并实现上述功能。</p>
<p><code>_alltraps</code>应该做的事：</p>
<ol>
<li>保存现场：压入值使堆栈使看起来像一个结构体 Trapframe</li>
<li>加载<code>GD_KD</code>到<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code> 将指向 Trapframe 的指针作为参数传递给 trap()</li>
<li><code>call trap</code>（能返回吗？）</li>
</ol>
<p>考虑使用<code>pushal</code> 指令；它非常适合<code>struct Trapframe</code>.</p>
<p>先给出trapframe的结构定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> tf_es;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="type">uint32_t</span> tf_err;</span><br><span class="line">	<span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="type">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.IDT设置：定义每一种中断向量，为trapentry.S的handler预处理提供向量定义</p>
<p>这部分代码参考了网络上的，主要是一开始global name不知道是啥。</p>
<p>其中，0-16号中断号设置为异常部分，比如除0错误。页面错误，保护错误，tss错误等。</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/s09_08.htm">0-16异常</a>这部分先看完，决定下面的设置，以及错误码是否需要的预处理。</p>
<p>trap.c&#x2F;trap_init()（包含了partB的代码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">th0</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th1</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th3</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th4</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th5</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th6</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th7</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th8</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th9</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th10</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th11</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th12</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th13</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th14</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th16</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">void</span> <span class="title function_">th_syscall</span><span class="params">()</span>;</span><br><span class="line">	SETGATE(idt[<span class="number">0</span>], <span class="number">0</span>, GD_KT, th0, <span class="number">0</span>);		<span class="comment">//定义在inc/mmu.h中</span></span><br><span class="line">	SETGATE(idt[<span class="number">1</span>], <span class="number">0</span>, GD_KT, th1, <span class="number">0</span>);  </span><br><span class="line">	SETGATE(idt[<span class="number">3</span>], <span class="number">0</span>, GD_KT, th3, <span class="number">3</span>);    <span class="comment">//DPL必须是3</span></span><br><span class="line">	SETGATE(idt[<span class="number">4</span>], <span class="number">0</span>, GD_KT, th4, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">5</span>], <span class="number">0</span>, GD_KT, th5, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">6</span>], <span class="number">0</span>, GD_KT, th6, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">7</span>], <span class="number">0</span>, GD_KT, th7, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">8</span>], <span class="number">0</span>, GD_KT, th8, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">9</span>], <span class="number">0</span>, GD_KT, th9, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">10</span>], <span class="number">0</span>, GD_KT, th10, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">11</span>], <span class="number">0</span>, GD_KT, th11, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">12</span>], <span class="number">0</span>, GD_KT, th12, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">13</span>], <span class="number">0</span>, GD_KT, th13, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">14</span>], <span class="number">0</span>, GD_KT, th14, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">16</span>], <span class="number">0</span>, GD_KT, th16, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, th_syscall, <span class="number">3</span>);		<span class="comment">//DPL定义为3，因为中断判断DPL只能低特权级调用高特权级，partB部分</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trapentry.S：插入内联汇编(包含了partB的代码)</p>
<p>2.使用宏来预处理每种中断向量，预处理后都会跳转到alltraps进行处理，最后跳转到trap函数</p>
<p>其中，._alltraps应该做的事：</p>
<ol>
<li>保存现场：压入值使堆栈使看起来像一个结构体 Trapframe</li>
<li>加载<code>GD_KD</code>到<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code> 将指向 Trapframe 的指针作为参数传递给 trap()</li>
<li><code>call trap</code>（想想能返回吗？）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	TRAPHANDLER_NOEC(th0, <span class="number">0</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th1, <span class="number">1</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th3, <span class="number">3</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th4, <span class="number">4</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th5, <span class="number">5</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th6, <span class="number">6</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th7, <span class="number">7</span>)</span><br><span class="line">	TRAPHANDLER(th8, <span class="number">8</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th9, <span class="number">9</span>)</span><br><span class="line">	TRAPHANDLER(th10, <span class="number">10</span>)</span><br><span class="line">	TRAPHANDLER(th11, <span class="number">11</span>)</span><br><span class="line">	TRAPHANDLER(th12, <span class="number">12</span>)</span><br><span class="line">	TRAPHANDLER(th13, <span class="number">13</span>)</span><br><span class="line">	TRAPHANDLER(th14, <span class="number">14</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(th16, <span class="number">16</span>)</span><br><span class="line">	</span><br><span class="line">	TRAPHANDLER_NOEC(th_syscall, T_SYSCALL)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	_alltraps:</span><br><span class="line">	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal</span><br><span class="line">	pushl $GD_KD</span><br><span class="line">	popl %ds</span><br><span class="line">	pushl $GD_KD</span><br><span class="line">	popl %es</span><br><span class="line">	pushl %esp	</span><br><span class="line">	call trap       </span><br></pre></td></tr></table></figure>

<p>确保应该能够make grade 在<code>divzero</code>、<code>softint</code>和<code>badsegment</code>测试中取得成功。</p>
<p>Happy!<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211139873.png"></p>
<ol>
<li>为每个异常&#x2F;中断设置单独的处理函数的目的是什么？（即，如果所有异常&#x2F;中断都传递给同一个处理程序，则无法提供当前实现中存在的哪些功能？）</li>
</ol>
<p>首先内核的嵌套中断不需要推送错误号，因为能直接处理，其次内核中断为了避免内存不够问题，必须直接panic。最后，并且用户态中断处理返回，内核则不必返回。</p>
<ol start="2">
<li>您是否必须采取任何措施才能使<code>user/softint</code>程序正确运行？等级脚本预计它会产生一般保护错误（trap 13），但<code>softint</code>的代码会使用中断 <code>int $14</code>。 <em>为什么</em>这会产生中断向量 13？如果内核实际上允许<code>softint</code>的 <code>int $14</code>指令调用内核的页面错误处理程序（即中断向量 14）会发生什么？</li>
</ol>
<p>14是缺页中断，这是用户态到内核的唯一方法。用户态是不允许直接调用内核函数。会产生保护错误trap 13:特权级保护错误。</p>
<a href="/2024/03/08/lab3%EF%BC%9APartB/" title="lab3：PartB">lab3：PartB</a>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>实验 2：内存管理</title>
    <url>/2024/03/08/lab2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，将为操作系统编写内存管理代码。内存管理有两个组成部分。</p>
<p>第一部分是内核的物理内存分配器，以便内核可以分配内存并稍后释放它。分配器将以 4096 字节为一页运行。我们将维护数据结构，记录哪些物理页面是空闲的，哪些已分配，以及有多少进程正在共享每个分配的页面。并且还将编写分配和释放内存页的代码。</p>
<p>第二部分是<em>虚拟内存</em>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86 硬件的内存管理单元 (MMU) 在指令使用内存时执行映射，查询一组页表。我们将编写页表填写的代码。</p>
<span id="more"></span>

<h3 id="进入新的实验代码"><a href="#进入新的实验代码" class="headerlink" title="进入新的实验代码"></a>进入新的实验代码</h3><p>实验采取了git来管理代码，因此我们对于远程的labx进行切换，合并lab（x-1）的代码，这样就能在原有代码基础上引入新实验必要的代码框架，进行进一步的修改和提交，以此类推一直到最后的lab6.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout lab2</span><br><span class="line"><span class="variable">$git</span> merge lab1</span><br></pre></td></tr></table></figure>

<p>实验 2 包含以下新源文件，您应该浏览这些文件：（看关键文件代码注释）</p>
<ul>
<li><code>inc/memlayout.h</code></li>
<li><code>kern/pmap.c</code></li>
<li><code>kern/pmap.h</code></li>
<li><code>kern/kclock.h</code></li>
<li><code>kern/kclock.c</code></li>
</ul>
<p><code>memlayout.h</code>描述了必须通过修改<code>pmap.c</code>来实现的虚拟地址空间的布局。 <code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code> 用于跟踪哪些物理内存页面空闲的结构。 <code>kclock.c</code>和<code>kclock.h</code> 操作 PC 的电池供电时钟和 CMOS RAM 硬件，其中 BIOS 记录 PC 包含的物理内存量等。<code>pmap.c 中</code>的代码需要读取这个设备硬件，以便计算出有多少物理内存，但这部分代码是为你完成的：你不需要知道 CMOS 硬件如何工作的细节。</p>
<p>请特别注意<code>memlayout.h</code>和<code>pmap.h</code>，因为本实验要求您使用并理解它们包含的许多定义。您可能还想查看<code>inc/mmu.h</code>，因为它还包含许多对本实验有用的定义。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%./grade-lab2</span><br></pre></td></tr></table></figure>

<p>会给你一个评分和错误显示。</p>
<p><strong>首先</strong>你必须明白一个道理：当你写代码的时候，代码里的给定<strong>地址操作</strong>中地址都会被mmu进行转换。因此即便是内核代码：假如你编写页表时候，你根据基址和偏移取页表项这个动作，也应该给出虚拟基址而不是物理地址，否则你直接变量名。为什么用变量名可以呢？前面的lab中已经知道了ELF规定里内核的代码也按照虚拟内存布局来存放。因此当你创建一个数组a的时候，数组自然存放在物理内存中，但是如果你把a当作地址，那么很不幸你只能得到虚拟地址，除非你做更多的转换动作。</p>
<p>那么内核的地址到底怎么在页表创立之前进行高低转换呢？前面的lab给出了答案：位移</p>
<p>如果没有明白以上的内容，你将完全看不懂本实验。</p>
<h2 id="第-1-部分：物理页面管理"><a href="#第-1-部分：物理页面管理" class="headerlink" title="第 1 部分：物理页面管理"></a>第 1 部分：物理页面管理</h2><p>操作系统必须跟踪物理 RAM 的哪些部分是空闲的，哪些是当前正在使用的。JOS 以<em>页面粒度</em>管理 PC 的物理内存， 以便它可以使用 MMU 来映射和保护每块分配的内存。</p>
<p>您现在将编写物理页面分配器。它通过一个<code>struct PageInfo</code>对象链接列表来跟踪哪些页面是空闲的（与 xv6 不同的是，它们<em>没有</em>嵌入到空闲页面本身中），每个页面对应一个物理页面。您需要先编写物理页分配器，然后才能编写其余的虚拟内存实现，因为页表管理代码需要分配物理内存来存储页表。</p>
<h3 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a><strong>Exercise1</strong></h3><p>在文件<code>kern/pmap.c 中</code>，您必须为以下函数实现代码（可以按照给定的顺序）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init()（仅限于调用`check_page_free_list(<span class="number">1</span>)`）</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>

<p><code>check_page_free_list()</code>并 <code>check_page_alloc()</code>测试您的物理页面分配器。您应该启动 JOS 并查看是否<code>check_page_alloc()</code> 报告成功。修复您的代码，使其通过。您可能会发现添加您自己的<code>assert()</code> 以验证您的假设是否正确很有帮助。</p>
<h2 id="第-2-部分：虚拟内存"><a href="#第-2-部分：虚拟内存" class="headerlink" title="第 2 部分：虚拟内存"></a>第 2 部分：虚拟内存</h2><p>在做任何其他事情之前，先熟悉 x86 的保护模式内存管理架构：即<em>分段</em>和<em>页面转换</em>。</p>
<h3 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a><strong>Exercise2</strong></h3><p>查看<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm"> Intel 80386 参考手册的</a>第 5 章和第 6 章 ，如果您还没有这样做的话。仔细阅读有关页面转换和基于页面的保护的部分（5.2 和 6.4）。我们建议您还浏览有关细分的部分；虽然 JOS 使用分页硬件进行虚拟内存和保护，但不能在 x86 上禁用段转换和基于段的保护，因此您需要对其有基本的了解。</p>
<h3 id="虚拟、线性和物理地址"><a href="#虚拟、线性和物理地址" class="headerlink" title="虚拟、线性和物理地址"></a>虚拟、线性和物理地址</h3><p>jos和linux一样，放弃了段的管理，只是用来描述符和选择子的权限检查。因此内存管理主要是针对分页管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们通常把指针是当作虚拟地址的“偏移量”。在<code>boot/boot.S 中</code>，我们安装了一个全局描述符表 (GDT)，它通过将所有段基地址设置为 0 并将限制设置为 来有效地禁用段转换<code>0xffffffff</code>。因此“选择子”不起作用，线性地址总是等于虚拟地址的偏移量。在实验 3 中，我们将不得不与分段进行更多交互以设置权限级别，但是对于地址映射，我们可以在整个 JOS 实验中忽略分段，而只关注页表映射。</p>
<p>回想一下，在实验 1 的第 3 部分中，我们安装了一个简单的页表，以便内核可以在其链接地址 0xf0100000 处运行，即使它实际上加载到 ROM BIOS 上方 0x00100000 处的物理内存中。这个页表只映射了 4MB 的内存。在本实验中您要为 JOS 设置的虚拟地址空间布局中，我们将扩展它以映射从虚拟地址 0xf0000000 开始的前 256MB 物理内存，并映射虚拟地址空间的许多其他区域。</p>
<h3 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a><strong>Exercise3</strong></h3><p>虽然 GDB 只能通过虚拟地址访问 QEMU 的内存，但在设置虚拟内存时能够检查物理内存通常很有用。查看实验室工具指南中的 QEMU<a href="https://pdos.csail.mit.edu/6.828/2017/labguide.html#qemu">监视器命令</a>。</p>
<p>从在 CPU 上执行的代码来看，一旦我们处于保护模式（我们首先在<code>boot/boot.S 中输入</code>），就无法直接使用线性或物理地址。 <em>所有</em>内存引用都被解释为虚拟地址并由 MMU 翻译，这意味着 C 中的<strong>所有指针都是虚拟地址</strong>。</p>
<p>JOS 内核通常需要将地址作为不透明值或整数进行操作，而不是取消引用它们，例如在物理内存分配器中。有时这些是虚拟地址，有时它们是物理地址。为了帮助记录代码，JOS 源区分了两种情况：类型<code>uintptr_t</code>表示虚拟地址，和<code>physaddr_t</code>表示物理地址。这两种类型实际上只是 32 位整数 ( <code>uint32_t</code>) 的同义词。所以你应该自己做好识别。</p>
<p>JOS 内核可以<code>uintptr_t</code>通过首先将其转换为指针类型来取消引用 a 。相比之下，内核无法合理地取消引用物理地址，因为 MMU 会转换所有内存引用。如果您将 a<code>physaddr_t</code>转换为指针并取消引用它，您可能能够加载并存储到结果地址（硬件会将其解释为虚拟地址），但您可能无法获得您想要的内存位置。</p>
<p>总结一下：</p>
<table>
<thead>
<tr>
<th>类型声明</th>
<th>地址类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>T*</code></td>
<td>虚拟</td>
</tr>
<tr>
<td><code>uintptr_t</code></td>
<td>虚拟</td>
</tr>
<tr>
<td><code>physaddr_t</code></td>
<td>物理</td>
</tr>
</tbody></table>
<p><strong>问题</strong></p>
<ol>
<li><p>假设下面的 JOS 内核代码是正确的，变量x应该是什么类型： unitptr_t,还是physaddr_？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value= 10；</span><br><span class="line">x = (mysetyry_t)value；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>JOS 内核有时需要读取或修改，它只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核无法绕过虚拟地址转换，因此无法直接加载和存储到物理地址。JOS 重新映射从物理地址 0 开始到虚拟地址 0xf0000000 的所有物理内存的原因之一是帮助内核读取和写入它只知道物理地址的内存。为了将一个物理地址转换成内核可以实际读写的虚拟地址，内核必须在物理地址上加上0xf0000000（也就是位移），才能在重映射的区域中找到其对应的虚拟地址。你应该使用<code>KADDR(pa)</code> 做那个加法。</p>
<p>给定存储内核数据结构的内存的虚拟地址，JOS 内核有时也需要能够找到物理地址。内核全局变量和分配的内存 <code>boot_alloc()</code>位于加载内核的区域，从 0xf0000000 开始，也就是我们映射所有物理内存的区域。因此，要将这个区域中的虚拟地址转换为物理地址，内核可以简单地减去 0xf0000000。你应该<code>PADDR(va)</code> 用来做那个减法。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在未来的实验中，您通常会将相同的物理页面同时映射到多个虚拟地址（或多个环境的地址空间中）。您将在物理页面对应的<code>pp_ref</code>字段中记录对每个物理页面的引用次数<code>struct PageInfo</code>。当一个物理页面的这个计数变为零时，该页面可以被释放，因为它不再被使用。一般来说，这个计数应该等于物理页在所有页表中出现*在下面 <code>UTOP</code>*的次数（上面的映射 <code>UTOP</code>大部分在启动时由内核设置，永远不应该被释放，所以没有必要对它们进行引用计数）。我们还将使用它来跟踪我们保留的指向页表的指针的数量，进而跟踪页目录对页表页的引用数量。</p>
<p>使用<code>page_alloc</code>时要小心。它返回的页面将<strong>始终具有 0 的引用计数</strong>，因此，只要您对返回的页面进行了某些操作（例如将其插入到页表中），就应该增加<code>pp_ref</code>。有时这由其他函数处理（例如，<code>page_insert</code>），有时调用<code>page_alloc</code>的函数必须直接执行此操作。</p>
<h3 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h3><p>现在您将编写一组例程来管理页表：插入和删除线性到物理映射，以及在需要时创建页表页。</p>
<h3 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a><strong>Exercise4</strong></h3><p>在文件<code>kern/pmap.c 中</code>，您必须实现以下函数的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br></pre></td></tr></table></figure>

<p><code>check_page()</code>调用  <code>mem_init()</code>，测试您的页表管理。在继续之前，您应该确保它报告成功。</p>
<h2 id="第-3-部分：内核地址空间"><a href="#第-3-部分：内核地址空间" class="headerlink" title="第 3 部分：内核地址空间"></a>第 3 部分：内核地址空间</h2><p>JOS 将处理器的 32 位线性地址空间分为两部分。我们将在实验 3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。分割线由符号定义ULIM在 <code>inc/memlayout.h</code>，保留约256MB的虚拟地址空间是内核。这就解释了为什么我们需要在lab 1 中给内核一个如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境。</p>
<p>您会发现参考<code>inc/memlayout.h 中</code>的 JOS 内存布局图 对本部分和后续实验<code>很有帮助</code>。</p>
<h3 id="权限和故障隔离"><a href="#权限和故障隔离" class="headerlink" title="权限和故障隔离"></a>权限和故障隔离</h3><p>由于内核和用户内存都存在于每个环境的地址空间中，我们将不得不在 x86 页表中使用权限位来允许用户代码仅访问地址空间的用户部分。否则用户代码中的错误可能会覆盖内核数据，导致崩溃或更微妙的故障；用户代码也可能窃取其他环境的私人数据。请注意，可写权限位 ( <code>PTE_W</code> ) 会影响用户和内核代码！</p>
<p>用户环境对上面的任何内存都没有权限<code>ULIM</code>，而内核将能够读写这块内存。对于地址范围 <code>[UTOP,ULIM)</code>，内核和用户环境都拥有相同的权限：可以读但不能写这个地址范围。该地址范围用于向用户环境公开某些只读的内核数据结构。最后，下面的地址空间 <code>UTOP</code>是供用户环境使用的；用户环境将设置访问此内存的权限。</p>
<h3 id="初始化内核地址空间"><a href="#初始化内核地址空间" class="headerlink" title="初始化内核地址空间"></a>初始化内核地址空间</h3><p>现在您将设置上面的地址空间<code>UTOP</code>：地址空间的内核部分。 <code>inc/memlayout.h</code>显示您应该使用的布局。您将使用刚刚编写的函数来设置适当的线性到物理映射。</p>
<h3 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a><strong>Exercise5</strong></h3><p>在<code>mem_init()</code>调用 之后填写缺少的代码<code>check_page()</code>。</p>
<p>您的代码现在应该通过<code>check_kern_pgdir()</code> 和<code>check_page_installed_pgdir()</code>检查。</p>
<p><strong>问题</strong></p>
<ol>
<li><p>页面目录中的哪些条目（行）此时已被填充？它们映射哪些地址以及指向何处？换句话说，尽可能多地填写这张表：</p>
<table>
<thead>
<tr>
<th>入口</th>
<th>基本虚拟地址</th>
<th>指向（逻辑上）：</th>
</tr>
</thead>
<tbody><tr>
<td>1023</td>
<td>?</td>
<td>前 4MB 物理内存的页表</td>
</tr>
<tr>
<td>1022</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>2</td>
<td>0x00800000</td>
<td>?</td>
</tr>
<tr>
<td>1</td>
<td>0x00400000</td>
<td>?</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td>[见下一个问题]</td>
</tr>
</tbody></table>
</li>
<li><p>我们已经将内核和用户环境放在相同的地址空间中。为什么用户程序不能读写内核内存？什么具体机制保护内核内存？</p>
</li>
<li><p>此操作系统可以支持的最大物理内存量是多少？为什么？</p>
</li>
<li><p>如果我们实际上拥有最大数量的物理内存，那么管理内存有多少空间开销？这个开销是如何分解的？</p>
</li>
<li><p>重新访问<code>kern/entry.S</code>和 <code>kern/entrypgdir.c 中</code>的页表设置。在我们打开分页后，EIP 仍然是一个很小的数字（略高于 1MB）。我们在什么时候过渡到在 KERNBASE 之上的 EIP 上运行？是什么让我们可以在启用分页和开始在高于 KERNBASE 的 EIP 上运行之间继续以低 EIP 执行？为什么需要这种转变？</p>
</li>
</ol>
<h1 id="回答问题汇总"><a href="#回答问题汇总" class="headerlink" title="回答问题汇总"></a>回答问题汇总</h1><h3 id="Exercise1-1"><a href="#Exercise1-1" class="headerlink" title="Exercise1"></a>Exercise1</h3><p>boot_alloc:分配虚拟地址，实际分配为page_alloc，（因为只是增加指针而已，页表项，PageInfo等都没有设置）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// 下一个空页虚拟地址，static非常重要，接下来有用</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化nextfree ：第一次被boot_alloc时候</span></span><br><span class="line">	<span class="comment">// &#x27;end&#x27; 指向.bss节最高处:</span></span><br><span class="line">	<span class="comment">// 从此代码和数据分配完成，接下来自由分配</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//你应该1.分配足够大的内存，2.并更新nextfree，确保了nextfree（地址）以PGSIZE倍数对齐，如果不明白对齐含义，你应该看《深入理解操作系统》中虚拟内存里堆malloc地址对齐的讲解</span></span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP(result + n, PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;<span class="comment">//分配页的va</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mem_init：创建二级页表，填充页表项，建立映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line">	<span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到这个机器以页为单位到底有多大 (npages &amp; npages_basemem).</span></span><br><span class="line">	i386_detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当你准备好测试的时候，把这一行注释：因为是报错用</span></span><br><span class="line">	<span class="comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 创建初始页目录表</span></span><br><span class="line">	kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 插入 PD 作为页表映射：</span></span><br><span class="line">	<span class="comment">// 目前而言，下面这行，不用太多的理解，即：</span></span><br><span class="line">	<span class="comment">// 权限: 内核 R, 用户 R</span></span><br><span class="line">	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 你应该分配一个PageInfo的数组，你应该知道这个结构体定义，什么用：所有能分配和访问的物理页</span></span><br><span class="line">	<span class="comment">// 内核通过这个数组追踪页， &#x27;npages&#x27; 代表了数组的长度：页面总数。 你应该使用 memset，来完成初始化页面为0。同时虚拟页表映射部分pages数组</span></span><br><span class="line">	<span class="comment">// 你的代码:模仿上面的页目录表设置即可</span></span><br><span class="line">	pages = (<span class="keyword">struct</span> PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages);</span><br><span class="line">	<span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 完成了内核的页目录表，页表，空页分配，初始化后，以后的操作将会通过 page_* functions. 完成。其中的操作，指映射内存：boot_map_region或者page_insert</span></span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">1</span>);</span><br><span class="line">	check_page_alloc();</span><br><span class="line">	check_page();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 现在我们解决以下虚拟内存sd：flags</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 对于线性地址 UPAGES （用户只读）进行页面映射</span></span><br><span class="line">	<span class="comment">// 权限设定:</span></span><br><span class="line">	<span class="comment">//    -  UPAGES 的新快照--权限 内核 读，用户 读</span></span><br><span class="line">	<span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">	<span class="comment">//    - 页面本身权限 -- 内核 RW, 用户无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line">	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//  使用 &#x27;bootstack&#x27; 引用的物理内存作为内核栈.  内核栈从虚拟地址 KSTACKTOP 开始向下增长.</span></span><br><span class="line">	<span class="comment">// 从 [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">	<span class="comment">// 作为内核栈, 但是划分为两块:</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- 有物理内存作为映射</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- 没有物理内存对应; 所以如果内核栈溢出, 会出错而不是覆写溢出对应的内存，比如guard page</span></span><br><span class="line">	<span class="comment">//     权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line">	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 映射所有 KERNBASE 开始的物理内存.</span></span><br><span class="line">	<span class="comment">// Ie.  虚拟地址范围 [KERNBASE, 2^32) 应该映射</span></span><br><span class="line">	<span class="comment">//      到实际物理地址范围 [0, 2^32 - KERNBASE)</span></span><br><span class="line">	<span class="comment">// 我们可能实际没有这么大： 2^32 - KERNBASE 物理内存的字节, but</span></span><br><span class="line">	<span class="comment">// 但是你应该还是要设置这个映射.</span></span><br><span class="line">	<span class="comment">// 权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br><span class="line">	<span class="comment">// 检查初始化的页目录表是否正确设置</span></span><br><span class="line">	check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从小页表转换到 我们创建的全kern_pgdir</span></span><br><span class="line">	<span class="comment">// 页目录表.	我们的pc现在应该指向</span></span><br><span class="line">	<span class="comment">// 在 KERNBASE and KERNBASE+4MB , 那么两个页表都会有这样的地址映射</span></span><br><span class="line">	<span class="comment">// 如果机器这时候重启了, 你应该就是设置kern_pgdir页目录表的时候错了.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// entry.S 设置了cr0中的 flags  (包括了小页表建立).  我们这里设置一些我们需要的flags</span></span><br><span class="line">	cr0 = rcr0();</span><br><span class="line">	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">	cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">	lcr0(cr0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些更多的设置,只有当kern_pgdir页目录表初始化后才能起效果</span></span><br><span class="line">	check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_init：对pages数组初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">			&#123;	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">				pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; i&lt;npages_basemem)</span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">			pages[i].pp_link = page_free_list; </span><br><span class="line">			page_free_list = &amp;pages[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=IOPHYSMEM/PGSIZE &amp;&amp; i&lt; EXTPHYSMEM/PGSIZE )</span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">			pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( i &gt;= EXTPHYSMEM / PGSIZE &amp;&amp; </span><br><span class="line">				i &lt; ( (<span class="type">int</span>)(boot_alloc(<span class="number">0</span>)) - KERNBASE)/PGSIZE)<span class="comment">//KERNBASE注意要加，pages里i就是物理地址从0开始的页数</span></span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">			pages[i].pp_link =<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">			pages[i].pp_link = page_free_list;</span><br><span class="line">			page_free_list = &amp;pages[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_alloc：从空闲表中分配一页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">res</span> =</span> page_free_list;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;page_alloc: out of free memory\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	page_free_list = res-&gt;pp_link;</span><br><span class="line">	res-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(res), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>page_free释放页到空闲表中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="comment">// Hint: 你应该调用panic如果 pp-&gt;pp_ref 非0（有被引用） 或pp-&gt;pp_link 非空（找不到空闲表就无法找到要做空的页面）.</span></span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;page_free: pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;<span class="comment">//放入空闲表头部</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise3-1"><a href="#Exercise3-1" class="headerlink" title="Exercise3"></a>Exercise3</h3><p>虚拟地址：我们的代码都会被mmu进行转换，因此指针只能作为虚拟地址（或者偏移量）</p>
<h3 id="Exercise4-1"><a href="#Exercise4-1" class="headerlink" title="Exercise4"></a>Exercise4</h3><p>page_walk从页目录开始找到va point to PTE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pte_t *</span><br><span class="line">pgdir_walk(pde_t *pgdir, const void *va, int create)</span><br><span class="line">&#123;</span><br><span class="line">	// Fill this function in</span><br><span class="line">	pde_t* ppde = pgdir + PDX(va);</span><br><span class="line">	if (!(*ppde &amp; PTE_P)) &#123;								</span><br><span class="line">		if (create) &#123;</span><br><span class="line">			struct PageInfo *pp = page_alloc(1);</span><br><span class="line">			if (pp == NULL) &#123;</span><br><span class="line">				return NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			pp-&gt;pp_ref++;</span><br><span class="line">			*ppde = (page2pa(pp)) | PTE_P | PTE_U | PTE_W;	</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return (pte_t *)KADDR(PTE_ADDR(*ppde)) + PTX(va);		//注意返回的是页表项虚址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boot_map_region给定范围进行映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">size_t</span> pgs = size / PGSIZE;</span><br><span class="line">	<span class="keyword">if</span> (size % PGSIZE != <span class="number">0</span>) &#123;<span class="comment">//多一页</span></span><br><span class="line">		pgs++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pgs; i++) &#123;<span class="comment">//对页表进行映射：填充页表项</span></span><br><span class="line">		<span class="type">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (pte == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			panic(<span class="string">&quot;boot_map_region(): out of memory\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		*pte = pa | PTE_P | perm;<span class="comment">//填充页表项</span></span><br><span class="line">		pa += PGSIZE;</span><br><span class="line">		va += PGSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_insert插入一页：页表项的创建或者替换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);<span class="comment">//我们可能新建了一个页表项</span></span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	pp-&gt;pp_ref++;										</span><br><span class="line">	<span class="keyword">if</span> ((*pte) &amp; PTE_P) &#123;								<span class="comment">//替换这个页表项</span></span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pa = page2pa(pp);</span><br><span class="line">	*pte = pa | perm | PTE_P;</span><br><span class="line">	pgdir[PDX(va)] |= perm;<span class="comment">//页目录也要同步权限</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_lookup根据虚拟地址找到PageInfo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="type">pte_t</span> *pte =  pgdir_walk(pgdir, va, <span class="number">0</span>);			<span class="comment">//不允许创建页表项</span></span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(*pte) &amp; PTE_P) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pa = PTE_ADDR(*pte);					</span><br><span class="line">	pp = pa2page(pa);								</span><br><span class="line">	<span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		*pte_store = pte;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>page_remove删除一页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span> *pte_store;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pte_store);</span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	page_decref(pp);</span><br><span class="line">	*pte_store = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>happy！代码在这：<a href="https://github.com/sakura-mac/mit_6.828_jos">Source Code</a></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211121500.png"></p>
<h3 id="Exercise5-1"><a href="#Exercise5-1" class="headerlink" title="Exercise5"></a>Exercise5</h3><ol>
<li>我们的虚拟内存包含了内核和用户空间映射. 为什么用户程序不能访问内核空间?有什么机制？</li>
</ol>
<p>A：页表的PTE_U做权限保护。</p>
<ol start="2">
<li>操作系统最大能支持多大的物理空间？为什么？</li>
</ol>
<p>A：总共有4KB * 1K &#x3D; 4MB的大小，用来存放pages数组，PageInfo有8B，也就是总共可以存4MB&#x2F;8B&#x3D;0.5M个页面，页大小4KB，那么内存支持为0.5M*4KB&#x3D;2GB，所以最多提供2GB。之所以不是4GB是因为这里最终使用pages（UPAGES）来管理内存并且只有4MB，所以二级页表好像有点拉垮？总之如果pages扩展到8MB就会有4GB</p>
<ol start="3">
<li>如果物理内存尽可能用，那么我们能有多大的地方来管理内存?</li>
</ol>
<p>A：pages数组4MB，总页表对应页表项4B*0.5M&#x3D;2MB，对应只用了内核页目录2KB，所以6MB+2KB。</p>
<ol start="4">
<li>是什么时候EIP从低地址到KERNBASE上开始运行？是什么导致了这种转变？为什么？</li>
</ol>
<p>A：是页表设置完毕之后。mmu会将每个地址访问（数据&#x2F;代码）通过cr3来进行转换。原先给定的偏移只能映射4MB，但是代码会给出高于这个偏移能力的地址。因此只能通过划分地址，访问编写的多级页表，根据所给的<strong>填写物理地址的页表&#x2F;页目录项</strong>来完成映射。</p>
<h2 id="关键文件代码注释"><a href="#关键文件代码注释" class="headerlink" title="关键文件代码注释"></a>关键文件代码注释</h2><p>本实验中有用的东西快速回忆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">宏 </span><br><span class="line">PADDR(kva)</span><br><span class="line">kDDR(pa)</span><br><span class="line">UVPT</span><br><span class="line">UPAGES</span><br><span class="line">KERNBASE</span><br><span class="line">IOPHYSMEM</span><br><span class="line">PGSIZE</span><br><span class="line">PTSIZE</span><br><span class="line">PTE_ADDR</span><br><span class="line"><span class="title function_">PDX</span><span class="params">(la)</span></span><br><span class="line"><span class="title function_">PTX</span><span class="params">(la)</span></span><br><span class="line">npages</span><br><span class="line">npages_basemem</span><br><span class="line">npages_extmem</span><br><span class="line"></span><br><span class="line">函数</span><br><span class="line"><span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line"><span class="title function_">pa2page</span><span class="params">(pa)</span></span><br><span class="line"><span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line"></span><br><span class="line">定义</span><br><span class="line"><span class="type">unit32_t</span> <span class="type">pte_t</span></span><br><span class="line"><span class="type">unit32_t</span> <span class="type">pde_t</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"><span class="type">int</span> pp_ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="type">pde_t</span> *kern_pgdir</span><br></pre></td></tr></table></figure>



<h3 id="inc-x2F-memlayout-h"><a href="#inc-x2F-memlayout-h" class="headerlink" title="inc&#x2F;memlayout.h"></a>inc&#x2F;memlayout.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_INC_MEMLAYOUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_INC_MEMLAYOUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* not __ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个文件定义了实验os中的虚拟空间布局,</span></span><br><span class="line"><span class="comment"> * 包括了内核空间和用户空间布局.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符的存放偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_KT     0x08     <span class="comment">// 内核代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_KD     0x10     <span class="comment">// 内核数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_UT     0x18     <span class="comment">// 用户代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_UD     0x20     <span class="comment">// 用户数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_TSS0   0x28     <span class="comment">// 对于CPU0的段选择子</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *           虚拟空间   :                              权限</span></span><br><span class="line"><span class="comment"> *                                                    kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4 G   --------&gt;  +------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     |   内核空间：映射lab1放的物理地址 | RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *    内核空间起点, ----&gt;  +------------------------------+ 0xf0000000      </span></span><br><span class="line"><span class="comment"> *                     |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span></span><br><span class="line"><span class="comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span></span><br><span class="line"><span class="comment"> *                     |  Cur. 页表存放：（用户只读）     | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span></span><br><span class="line"><span class="comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span></span><br><span class="line"><span class="comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    用户栈顶    ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |              用户栈           | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     用户代码，数据 &amp; 堆         |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |  User 符号表 Data (可选)       |                 PTSIZE</span></span><br><span class="line"><span class="comment"> *    用户数据起始 ----&gt;  +------------------------------+ 0x00200000        |</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *    0 ------------&gt;  +------------------------------+                 --+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) Note: 内核保证invalid memory永远不会被映射.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; 可以用于需要情况下的映射</span></span><br><span class="line"><span class="comment"> *     如果有必要，用户程序可以暂时占用虚拟内存内存UTEMP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页目录结构从这个地址开始</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERNBASE	0xF0000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// At IOPHYSMEM (640K) 有个 384K 空洞留给 I/O.  From the kernel,</span></span><br><span class="line"><span class="comment">// IOPHYSMEM 可以指定为 KERNBASE + IOPHYSMEM.  空洞</span></span><br><span class="line"><span class="comment">// 在物理地址 EXTPHYSMEM 截止</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOPHYSMEM	0x0A0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTPHYSMEM	0x100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP	KERNBASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTKSIZE	(8*PGSIZE)   		<span class="comment">// 内核栈大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTKGAP		(8*PGSIZE)   		<span class="comment">// guard内核栈大小：防止访问越界</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射IO虚址.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOLIM		(KSTACKTOP - PTSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOBASE	(MMIOLIM - PTSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM		(MMIOBASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只读的用户映射！ 从这里往下直到UTOP都是用户只读</span></span><br><span class="line"><span class="comment"> * 在env分配时候，这是全局页表的映射地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户只读的页表基虚址 (see &#x27;uvpt&#x27; below)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT		(ULIM - PTSIZE)</span></span><br><span class="line"><span class="comment">// 只读的页表复制</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPAGES		(UVPT - PTSIZE)</span></span><br><span class="line"><span class="comment">// 只读的全局env页表虚址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENVS		(UPAGES - PTSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用户虚址顶部，用户可以从 UTOP-1 开始向下访问!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户访问虚址顶</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTOP		UENVS</span></span><br><span class="line"><span class="comment">// 用户的异常栈顶部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UXSTACKTOP	UTOP</span></span><br><span class="line"><span class="comment">// Next page left invalid to guard against exception stack overflow; then:</span></span><br><span class="line"><span class="comment">// Top of normal user stack</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTACKTOP	(UTOP - 2*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Where user programs generally begin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEXT		(2*PTSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used for temporary page mappings.  Typed &#x27;void*&#x27; for convenience</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEMP		((void*) PTSIZE)</span></span><br><span class="line"><span class="comment">// Used for temporary page mappings for the user page-fault handler</span></span><br><span class="line"><span class="comment">// (should not conflict with other temporary page mappings)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFTEMP		(UTEMP + PTSIZE - PGSIZE)</span></span><br><span class="line"><span class="comment">// The location of the user-level STABS data structure</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTABDATA	(PTSIZE / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pde_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> JOS_USER</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 首先根据虚拟地址进入页目录（lib/entry.S里看设定pte_t/pde_t结构（uvpd和uvpt）），从</span></span><br><span class="line"><span class="comment"> * [UVPT, UVPT + PTSIZE) 范围，找到页表物理地址。因此</span></span><br><span class="line"><span class="comment"> * 页目录表同时也可以认为是页表：实际上就这么干了，具体代码看下面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 简单来说，进程自有的页表映射由于内存问题被分为两部分：页目录表和页表，我们根据虚拟地址就可以进入自有页表，根据uvpt[N]（得到uvpt[N]方法： (UVPT + (UVPT &gt;&gt; PGSHIFT))）得到”页“pa，完成物理映射</span></span><br><span class="line"><span class="comment"> * 不过还有问题：1.从虚拟地址访问的页目录表，那么他的物理地址在哪？2.页表直接访问页的地址吗？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//1.进行位移来映射：PADDR，KADDR来完成</span></span><br><span class="line"> <span class="comment">//2.页表访问了pages数组，用于管理页的申请，引用，释放</span></span><br><span class="line"> <span class="comment">//说句题外话，xv6设计为内核/用户的页表切换，但是linux不进行切换页表，因为内核/用户切换开销大。并且对于内核页表，有两种方式：1.共享2.复制。linux选择了后者，并且统一内核/用户的页表。并且访问得到”物理地址“后，并没有直接访问页。还需要一个空闲表（哈希队列）来完成页的管理，所以很麻烦。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];     <span class="comment">// 页表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];     <span class="comment">// 页目录表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在UPAGES里存储的PageInfo，可以认为是个描述符，实际上就是个链表：</span></span><br><span class="line"><span class="comment"> * Read/write 内核, read-only 用户.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们知道每个页表项唯一映射一个虚页和物理页的地址</span></span><br><span class="line"><span class="comment"> * 但是这里的PageInfo没有存储物理页，只是有个指针，具体物理地址去kern/pmap.h里的page2pa()找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> &#123;</span></span><br><span class="line">	<span class="comment">// 物理内存空闲（未被进程使用：让我们考虑生产者-消费者问题）表的第一个页指针：注意这两种PageInfo的不同使用情景：页表项存放PageInfo-&gt;空闲表的头-&gt;空闲表访问</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp_ref是指向空闲表里空闲页面的引用计数：考虑多个paddr映射同一个vaddr，如果为0，我们就可以认为这个物理页可以被重新分配给任何进程使用</span></span><br><span class="line">	<span class="comment">// 通过 page_alloc来分配内存，还有映射</span></span><br><span class="line">	<span class="comment">// 在boot时候就会使用pamp.c来分配内存映射，做一个小页表</span></span><br><span class="line">	<span class="comment">// boot_alloc 并没有有效的引用计数，所以可以认为是个”小“页表，第一个实验就要实现这个</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !JOS_INC_MEMLAYOUT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="kern-x2F-pmap-h"><a href="#kern-x2F-pmap-h" class="headerlink" title="kern&#x2F;pmap.h"></a>kern&#x2F;pmap.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"><span class="comment">//pmap一般用来分配内存，建立/删除映射，所以相当于虚拟空间和物理空间之间的接口：接受/返回 虚拟地址/物理地址，从而进行内存交互。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERN_PMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_KERN_PMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERNEL</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> <span class="string">&quot;This is a JOS kernel header; user programs should not #include it&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> bootstacktop[], bootstack[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> npages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pde_t</span> *kern_pgdir;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个宏 接受虚拟的内核地址--当然指向KERNEBASE上, 返回相应的物理地址.  如果传递非内核地址，报错。其中，他最高能够达到256MB物理地址的映射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line">_paddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">void</span> *kva)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">uint32_t</span>)kva &lt; KERNBASE)</span><br><span class="line">		_panic(file, line, <span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">physaddr_t</span>)kva - KERNBASE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个宏 接受物理地址，返回虚拟地址.  如果物理地址是错误的，就报错</span></span><br><span class="line"><span class="comment">#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline void*</span></span><br><span class="line"><span class="comment">_kaddr(const char *file, int line, physaddr_t pa)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if (PGNUM(pa) &gt;= npages)</span></span><br><span class="line"><span class="comment">		_panic(file, line, &quot;KADDR called with invalid pa %08lx&quot;, pa);</span></span><br><span class="line"><span class="comment">	return (void *)(pa + KERNBASE);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">enum &#123;</span></span><br><span class="line"><span class="comment">	// 对于分配内存页, 我们对所有的内存进行置0.（当然很多内存分配不置0，比如malloc这样的，也有置0的，比如linux中，mmap加载ELF只分配虚拟地址，访问.bss节时，没有页表项，中断分配内存时就并不访问磁盘，而是找个物理内存页，置0）</span></span><br><span class="line"><span class="comment">	ALLOC_ZERO = 1&lt;&lt;0,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void	mem_init(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void	page_init(void);</span></span><br><span class="line"><span class="comment">struct PageInfo *page_alloc(int alloc_flags);</span></span><br><span class="line"><span class="comment">void	page_free(struct PageInfo *pp);</span></span><br><span class="line"><span class="comment">int	page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);</span></span><br><span class="line"><span class="comment">void	page_remove(pde_t *pgdir, void *va);</span></span><br><span class="line"><span class="comment">struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);</span></span><br><span class="line"><span class="comment">void	page_decref(struct PageInfo *pp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void	tlb_invalidate(pde_t *pgdir, void *va);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline physaddr_t</span></span><br><span class="line"><span class="comment">page2pa(struct PageInfo *pp)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return (pp - pages) &lt;&lt; PGSHIFT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline struct PageInfo*</span></span><br><span class="line"><span class="comment">pa2page(physaddr_t pa)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if (PGNUM(pa) &gt;= npages)</span></span><br><span class="line"><span class="comment">		panic(&quot;pa2page called with invalid pa&quot;);</span></span><br><span class="line"><span class="comment">	return &amp;pages[PGNUM(pa)];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline void*</span></span><br><span class="line"><span class="comment">page2kva(struct PageInfo *pp)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return KADDR(page2pa(pp));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#endif /* !JOS_KERN_PMAP_H */</span></span><br></pre></td></tr></table></figure>



<h3 id="kern-x2F-pmap-c"><a href="#kern-x2F-pmap-c" class="headerlink" title="kern&#x2F;pmap.c"></a>kern&#x2F;pmap.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"><span class="comment">//在这里我们将会建立完整的页面映射，你会填写以下代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*exercise1</span></span><br><span class="line"><span class="comment">* 1.boot_alloc() 启动的时候给内核分配虚拟页</span></span><br><span class="line"><span class="comment">* 2.mem_init()（仅限于调用`check_page_free_list(1)`）给内核建立页目录，并建立pages数组，然后建立映射</span></span><br><span class="line"><span class="comment">* 3.page_init() 建立空闲表</span></span><br><span class="line"><span class="comment">* 4.page_alloc() 从空闲表中找到空页并分配</span></span><br><span class="line"><span class="comment">* 5.page_free() 释放页面为空页放入空闲表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*exercise 4</span></span><br><span class="line"><span class="comment">* 1.pgdir_walk() 访问两级”页表“，找到PDE的虚拟地址</span></span><br><span class="line"><span class="comment">* 2.boot_map_region() 填充映射</span></span><br><span class="line"><span class="comment">* 3.page_lookup() 根据虚拟地址，得到PageInfo的虚拟地址</span></span><br><span class="line"><span class="comment">* 4.page_remove() 删除页</span></span><br><span class="line"><span class="comment">* 5.page_insert() 插入页</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/kclock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些变量由i386_detect_memory()设定</span></span><br><span class="line"><span class="type">size_t</span> npages;			<span class="comment">// 物理页数量 (in pages)</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> npages_basemem;	<span class="comment">// 基础内存页数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些变量由 mem_init()设定</span></span><br><span class="line"><span class="type">pde_t</span> *kern_pgdir;		<span class="comment">// 内核的初始页目录虚基址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span>		<span class="comment">// 能够管理的页面</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page_free_list</span>;</span>	<span class="comment">// 空闲表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 检测机器的物理内存配置</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nvram_read</span><span class="params">(<span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> mc146818_read(r) | (mc146818_read(r + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">i386_detect_memory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> basemem, extmem, ext16mem, totalmem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用CMOS调用来测量基本和扩展内存</span></span><br><span class="line">	<span class="comment">// (CMOS calls 以KB单位返回结果.)</span></span><br><span class="line">	basemem = nvram_read(NVRAM_BASELO);</span><br><span class="line">	extmem = nvram_read(NVRAM_EXTLO);</span><br><span class="line">	ext16mem = nvram_read(NVRAM_EXT16LO) * <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算可用物理页数量：基本和扩展内存中</span></span><br><span class="line">	<span class="keyword">if</span> (ext16mem)</span><br><span class="line">		totalmem = <span class="number">16</span> * <span class="number">1024</span> + ext16mem;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (extmem)</span><br><span class="line">		totalmem = <span class="number">1</span> * <span class="number">1024</span> + extmem;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		totalmem = basemem;</span><br><span class="line"></span><br><span class="line">	npages = totalmem / (PGSIZE / <span class="number">1024</span>);</span><br><span class="line">	npages_basemem = basemem / (PGSIZE / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;Physical memory: %uK available, base = %uK, extended = %uK\n&quot;</span>,</span><br><span class="line">		totalmem, basemem, totalmem - basemem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 从 UTOP ：内核上开始建立页表映射.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page_free_list</span><span class="params">(<span class="type">bool</span> only_low_memory)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page_alloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_kern_pgdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">physaddr_t</span> <span class="title function_">check_va2pa</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page_installed_pgdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的boot内存分配调用page_alloc() 来实现.注：为了区分，空页意味着未被分配，空闲页则可能是空页；也可能不是，只是未被进程使用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果指定内存大小n字节&gt;0, 分配连续的内存，一般是稍大一点，来足够满足n字节的大小需求</span></span><br><span class="line"><span class="comment">// 但是并没有初始化这个内存. 返回内核的虚拟地址.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果n==0, 返回紧邻着的下一个空页（一开始分配，一定是引用计数为0的空闲表结点）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果内存耗尽, boot_alloc 应该报错</span></span><br><span class="line"><span class="comment">// 这个函数仅在boot给内核分配内存使用,</span></span><br><span class="line"><span class="comment">// 在 page_free_list 空闲表完成之前调用函数.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// 下一个空页虚拟地址</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化nextfree ：第一次被boot_alloc时候</span></span><br><span class="line">	<span class="comment">// &#x27;end&#x27; 指向.bss节最高处:</span></span><br><span class="line">	<span class="comment">// 从此代码和数据分配完成，紧接着自由分配</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//你应该1.分配足够大的内存，2.并更新nextfree，确保了nextfree（地址）以PGSIZE倍数对齐，如果不明白对齐，你应该看《深入理解操作系统》中虚拟内存里堆malloc地址对齐的讲解</span></span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立两级页表和pages数组</span></span><br><span class="line"><span class="comment">//    对于内核：kern_pgdir 是是内核页目录表虚拟基址</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个部分仅仅分配了内核的映射</span></span><br><span class="line"><span class="comment">// (ie. addresses &gt;= UTOP).  用户映射建立会在进程创建的时候发生</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 从 UTOP 到 ULIM, 用户只读</span></span><br><span class="line"><span class="comment">// 在 ULIM 上，用户禁止访问</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line">	<span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到这个机器以页为单位到底有多大 (npages &amp; npages_basemem).</span></span><br><span class="line">	i386_detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当你准备好测试的时候，把这一行注释：因为是报错用</span></span><br><span class="line">	panic(<span class="string">&quot;mem_init: This function is not finished\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 创建初始页目录表</span></span><br><span class="line">	kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);<span class="comment">//只有4KB</span></span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 递归插入 PD 作为页表映射：</span></span><br><span class="line">	<span class="comment">// 只设置了一个页目录项，相当于同时只建立了一个页表，剩下暂时没有建立映射:这里非常奇怪的是将UVPT通过页目录项映射到了kern_pgdir上，相当于一个4kb虚拟页表映射到了内核页目录上（为什么虚拟内存中要映射页表UVPT和UPAGES呢），而不是映射到新的物理页作为页表的存储。</span></span><br><span class="line">	<span class="comment">// 权限: 内核 , 用户 </span></span><br><span class="line">	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 你应该分配一个PageInfo的数组，你应该知道这个结构体定义，什么用</span></span><br><span class="line">	<span class="comment">// 内核通过这个数组追踪物理页， &#x27;npages&#x27; 代表了数组的长度：页面总数。 你应该使用 memset，来完成初始化页面为0</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 完成了内核的页目录表，页表，空页分配，初始化后，以后的操作将会通过 page_* functions. 完成。其中的操作，指分配内存：boot_map_region或者page_insert？？？</span></span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">1</span>);</span><br><span class="line">	check_page_alloc();</span><br><span class="line">	check_page();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 现在我们解决以下虚拟内存sd：flags</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 对于线性地址 UPAGES （用户只读）进行页面映射</span></span><br><span class="line">	<span class="comment">// 权限设定:</span></span><br><span class="line">	<span class="comment">//    -  UPAGES 的新快照-- 内核 读，用户 读</span></span><br><span class="line">	<span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">	<span class="comment">//    - 页面本身权限 -- 内核 RW, 用户无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//  使用 &#x27;bootstack&#x27; 引用的物理内存作为内核栈.  内核栈从虚拟地址 KSTACKTOP 开始向下增长.</span></span><br><span class="line">	<span class="comment">// 从 [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">	<span class="comment">// 作为内核栈, 但是划分为两块:</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- 有物理内存作为映射</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- 没有物理内存对应; 所以如果内核栈溢出, 会出错而不是覆写溢出对应的内存，比如guard page</span></span><br><span class="line">	<span class="comment">//     权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 映射所有 KERNBASE 开始的物理内存.</span></span><br><span class="line">	<span class="comment">// Ie.  虚拟地址范围 [KERNBASE, 2^32) 应该映射</span></span><br><span class="line">	<span class="comment">//      到实际物理地址范围 [0, 2^32 - KERNBASE)</span></span><br><span class="line">	<span class="comment">// 我们可能实际没有这么大： 2^32 - KERNBASE 物理内存的字节, but</span></span><br><span class="line">	<span class="comment">// 但是你应该还是要设置这个映射.</span></span><br><span class="line">	<span class="comment">// 权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查初始化的页目录表是否正确设置</span></span><br><span class="line">	check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从小页表转换到 我们创建的全kern_pgdir</span></span><br><span class="line">	<span class="comment">// 页目录表.	我们的pc现在应该指向</span></span><br><span class="line">	<span class="comment">// 在 KERNBASE and KERNBASE+4MB , 那么两个页表都会有这样的地址映射</span></span><br><span class="line">	<span class="comment">// 如果机器这时候重启了, 你应该就是设置kern_pgdir页目录表的时候错了.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// entry.S 设置了cr0中的 flags  (包括了小页表建立).  我们这里设置一些我们需要的flags</span></span><br><span class="line">	cr0 = rcr0();</span><br><span class="line">	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">	cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">	lcr0(cr0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些更多的设置,只有当kern_pgdir页目录表初始化后才能起效果</span></span><br><span class="line">	check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 追踪物理页表.</span></span><br><span class="line"><span class="comment">// 不要忘记我们的页表项PageInfo数组已经建立，但是空闲表还没建立</span></span><br><span class="line"><span class="comment">// 页面应该在空闲表里, 并且空闲表里存在空页结点</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化页结构，还有空闲表</span></span><br><span class="line"><span class="comment">// 完成之后, 不应该再使用boot_alloc. 而是应该使用下面的allocator函数来通过空闲表来分配，重分配物理页面</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">// 现在我们的页面都是空的：引用计数为0.</span></span><br><span class="line">	<span class="comment">// 但是这当然不正确.  什么样的内存是真的空的?</span></span><br><span class="line">	<span class="comment">//  1)将物理页面0标记为正在使用（非空闲）。这样我们就保留了实模式的IDT和基本输入输出系统结构，以防我们需要它们。(目前我们没有，但是...)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 2)基础内存的剩余部分，[PGSIZE，npages_basemem * PGSIZE)认为空闲。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 3)然后是IO空[IOPHYSMEM，EXTPHYSMEM)，它必须从不被分配。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 4)然后扩展内存[EXTPHYSMEM，...).</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//既然有的页正在被使用，有的是空闲的。那么</span></span><br><span class="line">	<span class="number">1.</span>内核在物理内存中的哪里？</span><br><span class="line">	<span class="number">2.</span>哪些页面已经在使用页表和其他数据结构？</span><br><span class="line">	<span class="comment">// 请你修改代码？？来回答这一点.</span></span><br><span class="line">	<span class="comment">// 注意: 请不要碰那些和空闲页对应的物理内存</span></span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一页物理页.  如果 (alloc_flags &amp; ALLOC_ZERO), 那么你就应该多做一点：填充0</span></span><br><span class="line"><span class="comment">// 返回这个物理页面必须以 &#x27;\0&#x27; 结尾.  不要增加引用计数 - 这是由调用函数做的 (或者通过 page_insert函数来做)，因为分配页面只是空页，还未被使用.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 确保将上述页面设置了 pp_link  为 NULL 以便于</span></span><br><span class="line"><span class="comment">// page_free 这个页面释放函数可以防止重复释放的bug.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果可分配物理内存为0返回 NULL .</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 使用 page2kva 和 memset来完成代码书写</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 向空闲表返回一页.</span></span><br><span class="line"><span class="comment">// (当pp-&gt;pp_ref引用计数为0，代表页面应该释放，于是应该从空闲表拿出，放入头部，方便下次当作空页取出使用)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="comment">// Hint: 你应该调用panic如果 pp-&gt;pp_ref 非0（有被引用） 或pp-&gt;pp_link 非空（找不到空闲表就无法找到要做空的页面）.</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数，当为0时候，free掉它</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> PageInfo* pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (--pp-&gt;pp_ref == <span class="number">0</span>)</span><br><span class="line">		page_free(pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定pgdir作为指向页目录表的指针, pgdir_walk 返回指向页表的虚拟地址&#x27;va&#x27;（pte）.</span></span><br><span class="line"><span class="comment">// 这需要走两级“页表”：进程的”页表“来找到页目录表，页目录表来找到页表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 寻找页表过程中相关的页表项可能并不存在.我们可能就应该创建页表，来开始新的映射建立</span></span><br><span class="line"><span class="comment">// 如果创造新页表失败, 那么 create == false, 那么pgdir_walk 返回NULL.</span></span><br><span class="line"><span class="comment">// 否则, pgdir_walk 通过调用page_alloc分配一个新页作为新页表.</span></span><br><span class="line"><span class="comment">//    - 如果分配失败, pgdir_walk 返回 NULL.</span></span><br><span class="line"><span class="comment">//    - 否则, 增加新页的引用计数,清除页内容</span></span><br><span class="line"><span class="comment">//	然后 pgdir_walk 返回一个新的页表页的指针.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: 你可以把PageInfo * 通过page2pa(在kern/pmap.h里)转换得到页物理地址 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2:  x86 MMU 检查权限位：无论是页目录表还是页表，所以你或许应该放宽你的权限：走个形式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: 看  inc/mmu.h 里有对多级页表（页目录表和页表）的宏定义，有些帮助</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定页目录表的根外设的页表映射 </span></span><br><span class="line"><span class="comment">// 在pgdir中映射虚拟地址 [va, va+size) 到物理地址[pa, pa+size)</span></span><br><span class="line"><span class="comment">// 大小是 PGSIZE, 并且va和pa都要地址页对齐</span></span><br><span class="line"><span class="comment">// 使用权限位 perm|PTE_P 来进行入口时mmu检查.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个函数仅仅为了建立从UTOP上的静态映射（RO ENVS）,比如，我们不应该增加pp_ref引用计数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 通过使用 pgdir_walk解决寻找到页表项填充映射问题</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配页表中：映射物理页 &#x27;pp&#x27; 到虚拟页 &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// 页表PTE权限 (低 12 bits) </span></span><br><span class="line"><span class="comment">// 应该被设置为&#x27;perm|PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//   - 如果已经有虚拟页映射 &#x27;va&#x27;, 应该调用page_remove().</span></span><br><span class="line"><span class="comment">//   - 如果有必要, on demand, 一个页表应该被分配，然后快照插入到pgdir页目录表</span></span><br><span class="line"><span class="comment">//   - 如果插入成功，那么pp-&gt;pp_ref 应该增加：进程引用+1</span></span><br><span class="line"><span class="comment">//   - 如果已经有页表项占用了va，那么我们的页目录表项就应该无效</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  极端情况处理hint: 你应该考虑在同一个页目录表中，同样的物理页地址重复映射同一个虚拟地址，应该怎么处理。然而，不需要在本函数代码中区分，因为会导致无法避免的bug，你应该在多层调用中分散处理。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">//   0 成功插入</span></span><br><span class="line"><span class="comment">//   -E_NO_MEM, 如果页表不能被分配</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 解决办法是调用 pgdir_walk, page_remove,page2pa</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回物理页面的虚拟地址</span></span><br><span class="line"><span class="comment">// 如果页表项 pte_store 不为0, 那么我们就应该认为找到了这个页表项，.它会将被page_remove删除，并且会在系统调用参数的时候验证权限，防止用户直接调用。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果没有页面对应va，那么返回 NULL</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 通过调用 pgdir_walk 和 pa2page来写代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除页表项</span></span><br><span class="line"><span class="comment">// 给定页虚拟地址 &#x27;va&#x27;，来取消映射</span></span><br><span class="line"><span class="comment">// 如果没有物理页被映射，那么就应该什么都不干</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 细节:</span></span><br><span class="line"><span class="comment">//   - 引用计数应该-1</span></span><br><span class="line"><span class="comment">//   - 如果引用计数是0，那么应该做空页面</span></span><br><span class="line"><span class="comment">//   - 页表项存在的话，那么应该被设置为 0.</span></span><br><span class="line"><span class="comment">//   - 同时对于页表项的缓存也应该无效</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 你赢该通过调用page_lookup,tlb_invalidate,  page_decref来帮助代码书写</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  你的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 仅仅当页表项已经被修改之后，才对页表项缓存无效化</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tlb_invalidate</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 仅仅当我们修改这个地址空间，才刷新这个页表项缓存</span></span><br><span class="line">	<span class="comment">// 刷新之后，这只有一个地址空间，所以是无效的？？？没懂</span></span><br><span class="line">	invlpg(va);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 检查函数</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that the pages on the page_free_list are reasonable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page_free_list</span><span class="params">(<span class="type">bool</span> only_low_memory)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> pdx_limit = only_low_memory ? <span class="number">1</span> : NPDENTRIES;</span><br><span class="line">	<span class="type">int</span> nfree_basemem = <span class="number">0</span>, nfree_extmem = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *first_free_page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!page_free_list)</span><br><span class="line">		panic(<span class="string">&quot;&#x27;page_free_list&#x27; is a null pointer!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (only_low_memory) &#123;</span><br><span class="line">		<span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line">		<span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> &#123; &amp;pp1, &amp;pp2 &#125;;</span><br><span class="line">		<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line">			<span class="type">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">			*tp[pagetype] = pp;</span><br><span class="line">			tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">		&#125;</span><br><span class="line">		*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">		page_free_list = pp1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if there&#x27;s a page that shouldn&#x27;t be on the free list,</span></span><br><span class="line">	<span class="comment">// try to make sure it eventually causes trouble.</span></span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link)</span><br><span class="line">		<span class="keyword">if</span> (PDX(page2pa(pp)) &lt; pdx_limit)</span><br><span class="line">			<span class="built_in">memset</span>(page2kva(pp), <span class="number">0x97</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	first_free_page = (<span class="type">char</span> *) boot_alloc(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line">		<span class="comment">// check that we didn&#x27;t corrupt the free list itself</span></span><br><span class="line">		assert(pp &gt;= pages);</span><br><span class="line">		assert(pp &lt; pages + npages);</span><br><span class="line">		assert(((<span class="type">char</span> *) pp - (<span class="type">char</span> *) pages) % <span class="keyword">sizeof</span>(*pp) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// check a few pages that shouldn&#x27;t be on the free list</span></span><br><span class="line">		assert(page2pa(pp) != <span class="number">0</span>);</span><br><span class="line">		assert(page2pa(pp) != IOPHYSMEM);</span><br><span class="line">		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);</span><br><span class="line">		assert(page2pa(pp) != EXTPHYSMEM);</span><br><span class="line">		assert(page2pa(pp) &lt; EXTPHYSMEM || (<span class="type">char</span> *) page2kva(pp) &gt;= first_free_page);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (page2pa(pp) &lt; EXTPHYSMEM)</span><br><span class="line">			++nfree_basemem;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			++nfree_extmem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assert(nfree_basemem &gt; <span class="number">0</span>);</span><br><span class="line">	assert(nfree_extmem &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page_free_list() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check the physical page allocator (page_alloc(), page_free(),</span></span><br><span class="line"><span class="comment">// and page_init()).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>, *<span class="title">pp0</span>, *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="type">int</span> nfree;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">fl</span>;</span></span><br><span class="line">	<span class="type">char</span> *c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pages)</span><br><span class="line">		panic(<span class="string">&quot;&#x27;pages&#x27; is a null pointer!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check number of free pages</span></span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list, nfree = <span class="number">0</span>; pp; pp = pp-&gt;pp_link)</span><br><span class="line">		++nfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to allocate three pages</span></span><br><span class="line">	pp0 = pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">	assert(pp0);</span><br><span class="line">	assert(pp1 &amp;&amp; pp1 != pp0);</span><br><span class="line">	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);</span><br><span class="line">	assert(page2pa(pp0) &lt; npages*PGSIZE);</span><br><span class="line">	assert(page2pa(pp1) &lt; npages*PGSIZE);</span><br><span class="line">	assert(page2pa(pp2) &lt; npages*PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// temporarily steal the rest of the free pages</span></span><br><span class="line">	fl = page_free_list;</span><br><span class="line">	page_free_list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be no free memory</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free and re-allocate?</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	page_free(pp1);</span><br><span class="line">	page_free(pp2);</span><br><span class="line">	pp0 = pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert(pp0);</span><br><span class="line">	assert(pp1 &amp;&amp; pp1 != pp0);</span><br><span class="line">	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);</span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test flags</span></span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp0), <span class="number">1</span>, PGSIZE);</span><br><span class="line">	page_free(pp0);</span><br><span class="line">	assert((pp = page_alloc(ALLOC_ZERO)));</span><br><span class="line">	assert(pp &amp;&amp; pp0 == pp);</span><br><span class="line">	c = page2kva(pp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGSIZE; i++)</span><br><span class="line">		assert(c[i] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// give free list back</span></span><br><span class="line">	page_free_list = fl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free the pages we took</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	page_free(pp1);</span><br><span class="line">	page_free(pp2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of free pages should be the same</span></span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link)</span><br><span class="line">		--nfree;</span><br><span class="line">	assert(nfree == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page_alloc() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Checks that the kernel part of virtual address space</span></span><br><span class="line"><span class="comment">// has been set up roughly correctly (by mem_init()).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function doesn&#x27;t test every corner case,</span></span><br><span class="line"><span class="comment">// but it is a pretty good sanity check.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_kern_pgdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> i, n;</span><br><span class="line">	<span class="type">pde_t</span> *pgdir;</span><br><span class="line"></span><br><span class="line">	pgdir = kern_pgdir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check pages array</span></span><br><span class="line">	n = ROUNDUP(npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo), PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += PGSIZE)</span><br><span class="line">		assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// check phys mem</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages * PGSIZE; i += PGSIZE)</span><br><span class="line">		assert(check_va2pa(pgdir, KERNBASE + i) == i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check kernel stack</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KSTKSIZE; i += PGSIZE)</span><br><span class="line">		assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);</span><br><span class="line">	assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check PDE permissions</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NPDENTRIES; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (i) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="title function_">PDX</span><span class="params">(UVPT)</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="title function_">PDX</span><span class="params">(KSTACKTOP<span class="number">-1</span>)</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="title function_">PDX</span><span class="params">(UPAGES)</span>:</span><br><span class="line">			<span class="title function_">assert</span><span class="params">(pgdir[i] &amp; PTE_P)</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= PDX(KERNBASE)) &#123;</span><br><span class="line">				assert(pgdir[i] &amp; PTE_P);</span><br><span class="line">				assert(pgdir[i] &amp; PTE_W);</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				assert(pgdir[i] == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(<span class="string">&quot;check_kern_pgdir() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function returns the physical address of the page containing &#x27;va&#x27;,</span></span><br><span class="line"><span class="comment">// defined by the page directory &#x27;pgdir&#x27;.  The hardware normally performs</span></span><br><span class="line"><span class="comment">// this functionality for us!  We define our own version to help check</span></span><br><span class="line"><span class="comment">// the check_kern_pgdir() function; it shouldn&#x27;t be used elsewhere.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">check_va2pa</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pte_t</span> *p;</span><br><span class="line"></span><br><span class="line">	pgdir = &amp;pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">if</span> (!(*pgdir &amp; PTE_P))</span><br><span class="line">		<span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">	p = (<span class="type">pte_t</span>*) KADDR(PTE_ADDR(*pgdir));</span><br><span class="line">	<span class="keyword">if</span> (!(p[PTX(va)] &amp; PTE_P))</span><br><span class="line">		<span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> PTE_ADDR(p[PTX(va)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// check page_insert, page_remove, &amp;c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>, *<span class="title">pp0</span>, *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">fl</span>;</span></span><br><span class="line">	<span class="type">pte_t</span> *ptep, *ptep1;</span><br><span class="line">	<span class="type">void</span> *va;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">pde_t</span> entry_pgdir[];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to allocate three pages</span></span><br><span class="line">	pp0 = pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">	assert(pp0);</span><br><span class="line">	assert(pp1 &amp;&amp; pp1 != pp0);</span><br><span class="line">	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// temporarily steal the rest of the free pages</span></span><br><span class="line">	fl = page_free_list;</span><br><span class="line">	page_free_list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be no free memory</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// there is no page allocated at address 0</span></span><br><span class="line">	assert(page_lookup(kern_pgdir, (<span class="type">void</span> *) <span class="number">0x0</span>, &amp;ptep) == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// there is no free memory, so we can&#x27;t allocate a page table</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, <span class="number">0x0</span>, PTE_W) &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free pp0 and try again: pp0 should be used for page table</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, <span class="number">0x0</span>, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(PTE_ADDR(kern_pgdir[<span class="number">0</span>]) == page2pa(pp0));</span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0x0</span>) == page2pa(pp1));</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(pp0-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be no free memory</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to map pp2 at PGSIZE because it&#x27;s already there</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp2 should NOT be on the free list</span></span><br><span class="line">	<span class="comment">// could happen in ref counts are handled sloppily in page_insert</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check that pgdir_walk returns a pointer to the pte</span></span><br><span class="line">	ptep = (<span class="type">pte_t</span> *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));</span><br><span class="line">	assert(pgdir_walk(kern_pgdir, (<span class="type">void</span>*)PGSIZE, <span class="number">0</span>) == ptep+PTX(PGSIZE));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to change permissions too.</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W|PTE_U) == <span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_U);</span><br><span class="line">	assert(kern_pgdir[<span class="number">0</span>] &amp; PTE_U);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to remap with fewer permissions</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_W);</span><br><span class="line">	assert(!(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_U));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should not be able to map at PTSIZE because need free page for page table</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp0, (<span class="type">void</span>*) PTSIZE, PTE_W) &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert pp1 at PGSIZE (replacing pp2)</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(!(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_U));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...</span></span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0</span>) == page2pa(pp1));</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));</span><br><span class="line">	<span class="comment">// ... and ref counts should reflect this</span></span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">2</span>);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp2 should be returned by page_alloc</span></span><br><span class="line">	assert((pp = page_alloc(<span class="number">0</span>)) &amp;&amp; pp == pp2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unmapping pp1 at 0 should keep pp1 at PGSIZE</span></span><br><span class="line">	page_remove(kern_pgdir, <span class="number">0x0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0x0</span>) == ~<span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test re-inserting pp1 at PGSIZE</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) == <span class="number">0</span>);</span><br><span class="line">	assert(pp1-&gt;pp_ref);</span><br><span class="line">	assert(pp1-&gt;pp_link == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unmapping pp1 at PGSIZE should free it</span></span><br><span class="line">	page_remove(kern_pgdir, (<span class="type">void</span>*) PGSIZE);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0x0</span>) == ~<span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == ~<span class="number">0</span>);</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 被 page_alloc 返回</span></span><br><span class="line">	assert((pp = page_alloc(<span class="number">0</span>)) &amp;&amp; pp == pp1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无可分配空页</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制 带回 pp0 ？？？？</span></span><br><span class="line">	assert(PTE_ADDR(kern_pgdir[<span class="number">0</span>]) == page2pa(pp0));</span><br><span class="line">	kern_pgdir[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	assert(pp0-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算检查 pgdir_walk</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	va = (<span class="type">void</span>*)(PGSIZE * NPDENTRIES + PGSIZE);</span><br><span class="line">	ptep = pgdir_walk(kern_pgdir, va, <span class="number">1</span>);</span><br><span class="line">	ptep1 = (<span class="type">pte_t</span> *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));</span><br><span class="line">	assert(ptep == ptep1 + PTX(va));</span><br><span class="line">	kern_pgdir[PDX(va)] = <span class="number">0</span>;</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查新分配的页表是否被清除干净（否则映射会错误，超级难debug ）</span></span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp0), <span class="number">0xFF</span>, PGSIZE);</span><br><span class="line">	page_free(pp0);</span><br><span class="line">	pgdir_walk(kern_pgdir, <span class="number">0x0</span>, <span class="number">1</span>);</span><br><span class="line">	ptep = (<span class="type">pte_t</span> *) page2kva(pp0);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NPTENTRIES; i++)</span><br><span class="line">		assert((ptep[i] &amp; PTE_P) == <span class="number">0</span>);</span><br><span class="line">	kern_pgdir[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回一个新的空闲链表</span></span><br><span class="line">	page_free_list = fl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放页面：引用计数为0</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	page_free(pp1);</span><br><span class="line">	page_free(pp2);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个已经初始化的 kern_pgdir，检查 page_insert, page_remove, &amp;c, </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page_installed_pgdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>, *<span class="title">pp0</span>, *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">fl</span>;</span></span><br><span class="line">	<span class="type">pte_t</span> *ptep, *ptep1;</span><br><span class="line">	<span class="type">uintptr_t</span> va;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查：对于已经初始化的页表，我们应该可以R/W</span></span><br><span class="line">	pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	page_free(pp0);</span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp1), <span class="number">1</span>, PGSIZE);</span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp2), <span class="number">2</span>, PGSIZE);</span><br><span class="line">	page_insert(kern_pgdir, pp1, (<span class="type">void</span>*) PGSIZE, PTE_W);</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(*(<span class="type">uint32_t</span> *)PGSIZE == <span class="number">0x01010101</span>U);</span><br><span class="line">	page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W);</span><br><span class="line">	assert(*(<span class="type">uint32_t</span> *)PGSIZE == <span class="number">0x02020202</span>U);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">	*(<span class="type">uint32_t</span> *)PGSIZE = <span class="number">0x03030303</span>U;</span><br><span class="line">	assert(*(<span class="type">uint32_t</span> *)page2kva(pp2) == <span class="number">0x03030303</span>U);</span><br><span class="line">	page_remove(kern_pgdir, (<span class="type">void</span>*) PGSIZE);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制带回 pp0 </span></span><br><span class="line">	assert(PTE_ADDR(kern_pgdir[<span class="number">0</span>]) == page2pa(pp0));</span><br><span class="line">	kern_pgdir[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	assert(pp0-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放我们带回的页</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page_installed_pgdir() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kern-x2F-kclock-h"><a href="#kern-x2F-kclock-h" class="headerlink" title="kern&#x2F;kclock.h"></a>kern&#x2F;kclock.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERN_KCLOCK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_KERN_KCLOCK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERNEL</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> <span class="string">&quot;This is a JOS kernel header; user programs should not #include it&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_RTC		0x070		<span class="comment">/* RTC port */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MC_NVRAM_START	0xe	<span class="comment">/* start of NVRAM: offset 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MC_NVRAM_SIZE	50	<span class="comment">/* 50 bytes of NVRAM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NVRAM bytes 7 &amp; 8: base memory size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_BASELO	(MC_NVRAM_START + 7)	<span class="comment">/* low byte; RTC off. 0x15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_BASEHI	(MC_NVRAM_START + 8)	<span class="comment">/* high byte; RTC off. 0x16 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NVRAM bytes 9 &amp; 10: extended memory size (between 1MB and 16MB) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXTLO	(MC_NVRAM_START + 9)	<span class="comment">/* low byte; RTC off. 0x17 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXTHI	(MC_NVRAM_START + 10)	<span class="comment">/* high byte; RTC off. 0x18 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NVRAM bytes 38 and 39: extended memory size (between 16MB and 4G) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXT16LO	(MC_NVRAM_START + 38)	<span class="comment">/* low byte; RTC off. 0x34 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXT16HI	(MC_NVRAM_START + 39)	<span class="comment">/* high byte; RTC off. 0x35 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">mc146818_read</span><span class="params">(<span class="type">unsigned</span> reg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mc146818_write</span><span class="params">(<span class="type">unsigned</span> reg, <span class="type">unsigned</span> datum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">// !JOS_KERN_KCLOCK_H</span></span></span><br></pre></td></tr></table></figure>



<h3 id="kern-x2F-kclock-c"><a href="#kern-x2F-kclock-c" class="headerlink" title="kern&#x2F;kclock.c"></a>kern&#x2F;kclock.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了读取现实时间用的硬件交互代码. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/kclock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span></span><br><span class="line"><span class="title function_">mc146818_read</span><span class="params">(<span class="type">unsigned</span> reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	outb(IO_RTC, reg);</span><br><span class="line">	<span class="keyword">return</span> inb(IO_RTC+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mc146818_write</span><span class="params">(<span class="type">unsigned</span> reg, <span class="type">unsigned</span> datum)</span></span><br><span class="line">&#123;</span><br><span class="line">	outb(IO_RTC, reg);</span><br><span class="line">	outb(IO_RTC+<span class="number">1</span>, datum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inc-x2F-mmu-h"><a href="#inc-x2F-mmu-h" class="headerlink" title="inc&#x2F;mmu.h"></a>inc&#x2F;mmu.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_INC_MMU_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_INC_MMU_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个文件定义了x86下的内存管理单元：内存（访问，切换）处理逻辑，内存分配在pmap.c里，sd</span></span><br><span class="line"><span class="comment"> * 包括了使用页表映射，和段相关的数据结构和算法,</span></span><br><span class="line"><span class="comment"> * 还有%cr0, %cr4, and %eflags寄存器，还有中断.</span></span><br><span class="line"><span class="comment"> * 代码书写分为：Part1/Part2/Part3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Part 1.  给定虚址，在虚拟页表，PageInfo，空闲表中，映射处理的所需要的数据结构和算法.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟地址&#x27;la&#x27;根据实际情况划分成三个部分:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | 页目录偏移       |      页表偏移   | 页内偏移             |</span></span><br><span class="line"><span class="comment">// |                |                |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \---------- PGNUM(la) ----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.</span></span><br><span class="line"><span class="comment">// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span></span><br><span class="line"><span class="comment">// use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page number field of address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGNUM(la)	(((uintptr_t) (la)) &gt;&gt; PTXSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page directory index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(la)		((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page table index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(la)		((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// offset in page</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGOFF(la)	(((uintptr_t) (la)) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct linear address from indexes and offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGADDR(d, t, o)	((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Page directory and page table constants.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPDENTRIES	1024		<span class="comment">// page directory entries per page directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPTENTRIES	1024		<span class="comment">// page table entries per page table</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE		4096		<span class="comment">// bytes mapped by a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT		12		<span class="comment">// log2(PGSIZE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTSIZE		(PGSIZE*NPTENTRIES) <span class="comment">// bytes mapped by a page directory entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTSHIFT		22		<span class="comment">// log2(PTSIZE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTXSHIFT	12		<span class="comment">// offset of PTX in a linear address</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDXSHIFT	22		<span class="comment">// offset of PDX in a linear address</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表/页目录存放的项的flags部分.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_P		0x001	<span class="comment">// Present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W		0x002	<span class="comment">// 可写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U		0x004	<span class="comment">// 用户</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PWT		0x008	<span class="comment">// 直写：无缓存下使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PCD		0x010	<span class="comment">// 禁用cache</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A		0x020	<span class="comment">// 可访问</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D		0x040	<span class="comment">// 脏标：配合回写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PS		0x080	<span class="comment">// 页大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G		0x100	<span class="comment">// 全局</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The PTE_AVAIL bits aren&#x27;t used by the kernel or interpreted by the</span></span><br><span class="line"><span class="comment">// hardware, so user processes are allowed to set them arbitrarily.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_AVAIL	0xE00	<span class="comment">// Available for software use</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags in PTE_SYSCALL may be used in system calls.  (Others may not.)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address in page table or page directory entry</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte)	((physaddr_t) (pte) &amp; ~0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Control Register flags</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_PE		0x00000001	<span class="comment">// Protection Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_MP		0x00000002	<span class="comment">// Monitor coProcessor</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_EM		0x00000004	<span class="comment">// Emulation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_TS		0x00000008	<span class="comment">// Task Switched</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_ET		0x00000010	<span class="comment">// Extension Type</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_NE		0x00000020	<span class="comment">// Numeric Errror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_WP		0x00010000	<span class="comment">// Write Protect</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_AM		0x00040000	<span class="comment">// Alignment Mask</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_NW		0x20000000	<span class="comment">// Not Writethrough</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_CD		0x40000000	<span class="comment">// Cache Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_PG		0x80000000	<span class="comment">// Paging</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PCE		0x00000100	<span class="comment">// Performance counter enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_MCE		0x00000040	<span class="comment">// Machine Check Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PSE		0x00000010	<span class="comment">// Page Size Extensions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_DE		0x00000008	<span class="comment">// Debugging Extensions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_TSD		0x00000004	<span class="comment">// Time Stamp Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PVI		0x00000002	<span class="comment">// Protected-Mode Virtual Interrupts</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_VME		0x00000001	<span class="comment">// V86 Mode Extensions</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eflags register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_CF		0x00000001	<span class="comment">// Carry Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_PF		0x00000004	<span class="comment">// Parity Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_AF		0x00000010	<span class="comment">// Auxiliary carry Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_ZF		0x00000040	<span class="comment">// Zero Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_SF		0x00000080	<span class="comment">// Sign Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_TF		0x00000100	<span class="comment">// Trap Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IF		0x00000200	<span class="comment">// Interrupt Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_DF		0x00000400	<span class="comment">// Direction Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_OF		0x00000800	<span class="comment">// Overflow Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_MASK	0x00003000	<span class="comment">// I/O Privilege Level bitmask</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_0	0x00000000	<span class="comment">//   IOPL == 0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_1	0x00001000	<span class="comment">//   IOPL == 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_2	0x00002000	<span class="comment">//   IOPL == 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_3	0x00003000	<span class="comment">//   IOPL == 3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_NT		0x00004000	<span class="comment">// Nested Task</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_RF		0x00010000	<span class="comment">// Resume Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_VM		0x00020000	<span class="comment">// Virtual 8086 mode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_AC		0x00040000	<span class="comment">// Alignment Check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_VIF		0x00080000	<span class="comment">// Virtual Interrupt Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_VIP		0x00100000	<span class="comment">// Virtual Interrupt Pending</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_ID		0x00200000	<span class="comment">// ID flag</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页错误的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEC_PR		0x1	<span class="comment">// Page fault caused by protection violation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEC_WR		0x2	<span class="comment">// Page fault caused by a write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEC_U		0x4	<span class="comment">// Page fault occured while in user mode</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Part 2.  段相关的数据结构和算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 汇编代码：宏定义的GDT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_NULL						\</span></span><br><span class="line"><span class="meta">	.word 0, 0;						\</span></span><br><span class="line"><span class="meta">	.byte 0, 0, 0, 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG(type,base,lim)					\</span></span><br><span class="line"><span class="meta">	.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);	\</span></span><br><span class="line"><span class="meta">	.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),		\</span></span><br><span class="line"><span class="meta">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">// not __ASSEMBLER__</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Segment Descriptors</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> sd_lim_15_0 : <span class="number">16</span>;  <span class="comment">// Low bits of segment limit</span></span><br><span class="line">	<span class="type">unsigned</span> sd_base_15_0 : <span class="number">16</span>; <span class="comment">// Low bits of segment base address</span></span><br><span class="line">	<span class="type">unsigned</span> sd_base_23_16 : <span class="number">8</span>; <span class="comment">// Middle bits of segment base address</span></span><br><span class="line">	<span class="type">unsigned</span> sd_type : <span class="number">4</span>;       <span class="comment">// Segment type (see STS_ constants)</span></span><br><span class="line">	<span class="type">unsigned</span> sd_s : <span class="number">1</span>;          <span class="comment">// 0 = system, 1 = application</span></span><br><span class="line">	<span class="type">unsigned</span> sd_dpl : <span class="number">2</span>;        <span class="comment">// Descriptor Privilege Level</span></span><br><span class="line">	<span class="type">unsigned</span> sd_p : <span class="number">1</span>;          <span class="comment">// Present</span></span><br><span class="line">	<span class="type">unsigned</span> sd_lim_19_16 : <span class="number">4</span>;  <span class="comment">// High bits of segment limit</span></span><br><span class="line">	<span class="type">unsigned</span> sd_avl : <span class="number">1</span>;        <span class="comment">// Unused (available for software use)</span></span><br><span class="line">	<span class="type">unsigned</span> sd_rsv1 : <span class="number">1</span>;       <span class="comment">// Reserved</span></span><br><span class="line">	<span class="type">unsigned</span> sd_db : <span class="number">1</span>;         <span class="comment">// 0 = 16-bit segment, 1 = 32-bit segment</span></span><br><span class="line">	<span class="type">unsigned</span> sd_g : <span class="number">1</span>;          <span class="comment">// Granularity: limit scaled by 4K when set</span></span><br><span class="line">	<span class="type">unsigned</span> sd_base_31_24 : <span class="number">8</span>; <span class="comment">// High bits of segment base address</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 空段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_NULL	&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;</span></span><br><span class="line"><span class="comment">// 错误段：可加载，但是不能用，会出错</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_FAULT	&#123; 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 &#125;</span></span><br><span class="line"><span class="comment">// 正常段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG(type, base, lim, dpl) 					\</span></span><br><span class="line"><span class="meta">&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff,	\</span></span><br><span class="line"><span class="meta">    type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1,		\</span></span><br><span class="line"><span class="meta">    (unsigned) (base) &gt;&gt; 24 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG16(type, base, lim, dpl) (struct Segdesc)			\</span></span><br><span class="line"><span class="meta">&#123; (lim) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff,		\</span></span><br><span class="line"><span class="meta">    type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 16, 0, 0, 1, 0,		\</span></span><br><span class="line"><span class="meta">    (unsigned) (base) &gt;&gt; 24 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 段类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_X		0x8	    <span class="comment">// 可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_E		0x4	    <span class="comment">// Expand down (non-executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_C		0x4	    <span class="comment">// Conforming code segment (executable only)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_W		0x2	    <span class="comment">// Writeable (non-executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_R		0x2	    <span class="comment">// Readable (executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_A		0x1	    <span class="comment">// Accessed</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System segment type bits</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T16A	0x1	    <span class="comment">// Available 16-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_LDT		0x2	    <span class="comment">// Local Descriptor Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T16B	0x3	    <span class="comment">// Busy 16-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_CG16	0x4	    <span class="comment">// 16-bit Call Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG		0x5	    <span class="comment">// Task Gate / Coum Transmitions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG16	0x6	    <span class="comment">// 16-bit Interrupt Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG16	0x7	    <span class="comment">// 16-bit Trap Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T32A	0x9	    <span class="comment">// Available 32-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T32B	0xB	    <span class="comment">// Busy 32-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_CG32	0xC	    <span class="comment">// 32-bit Call Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32	0xE	    <span class="comment">// 32-bit Interrupt Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32	0xF	    <span class="comment">// 32-bit Trap Gate</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Part 3.  中断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task state segment format (as described by the Pentium architecture book)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> ts_link;	<span class="comment">// Old ts selector</span></span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp0;	<span class="comment">// Stack pointers and segment selectors</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_ss0;	<span class="comment">//   after an increase in privilege level</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_padding1;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp1;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ss1;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding2;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp2;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ss2;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding3;</span><br><span class="line">	<span class="type">physaddr_t</span> ts_cr3;	<span class="comment">// Page directory base</span></span><br><span class="line">	<span class="type">uintptr_t</span> ts_eip;	<span class="comment">// Saved state from last task switch</span></span><br><span class="line">	<span class="type">uint32_t</span> ts_eflags;</span><br><span class="line">	<span class="type">uint32_t</span> ts_eax;	<span class="comment">// More saved state (registers)</span></span><br><span class="line">	<span class="type">uint32_t</span> ts_ecx;</span><br><span class="line">	<span class="type">uint32_t</span> ts_edx;</span><br><span class="line">	<span class="type">uint32_t</span> ts_ebx;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_ebp;</span><br><span class="line">	<span class="type">uint32_t</span> ts_esi;</span><br><span class="line">	<span class="type">uint32_t</span> ts_edi;</span><br><span class="line">	<span class="type">uint16_t</span> ts_es;		<span class="comment">// Even more saved state (segment selectors)</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_padding4;</span><br><span class="line">	<span class="type">uint16_t</span> ts_cs;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding5;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ss;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding6;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ds;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding7;</span><br><span class="line">	<span class="type">uint16_t</span> ts_fs;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding8;</span><br><span class="line">	<span class="type">uint16_t</span> ts_gs;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding9;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ldt;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding10;</span><br><span class="line">	<span class="type">uint16_t</span> <span class="type">ts_t</span>;		<span class="comment">// Trap on task switch</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_iomb;	<span class="comment">// I/O map base address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断门描述符：interrupts and traps的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gatedesc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> gd_off_15_0 : <span class="number">16</span>;   <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">	<span class="type">unsigned</span> gd_sel : <span class="number">16</span>;        <span class="comment">// segment selector</span></span><br><span class="line">	<span class="type">unsigned</span> gd_args : <span class="number">5</span>;        <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">	<span class="type">unsigned</span> gd_rsv1 : <span class="number">3</span>;        <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">	<span class="type">unsigned</span> gd_type : <span class="number">4</span>;        <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">	<span class="type">unsigned</span> gd_s : <span class="number">1</span>;           <span class="comment">// must be 0 (system)</span></span><br><span class="line">	<span class="type">unsigned</span> gd_dpl : <span class="number">2</span>;         <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">	<span class="type">unsigned</span> gd_p : <span class="number">1</span>;           <span class="comment">// Present</span></span><br><span class="line">	<span class="type">unsigned</span> gd_off_31_16 : <span class="number">16</span>;  <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 interrupt/trap  门描述符.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF.&quot;</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//	  the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//	  this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;		\</span></span><br><span class="line"><span class="meta">	(gate).gd_sel = (sel);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_args = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_rsv1 = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span></span><br><span class="line"><span class="meta">	(gate).gd_s = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_dpl = (dpl);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_p = 1;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up a call gate descriptor.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETCALLGATE(gate, sel, off, dpl)           	        \</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;		\</span></span><br><span class="line"><span class="meta">	(gate).gd_sel = (sel);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_args = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_rsv1 = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_type = STS_CG32;				\</span></span><br><span class="line"><span class="meta">	(gate).gd_s = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_dpl = (dpl);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_p = 1;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pseudo-descriptors used for LGDT, LLDT and LIDT instructions.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pseudodesc</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> pd_lim;		<span class="comment">// Limit</span></span><br><span class="line">	<span class="type">uint32_t</span> pd_base;		<span class="comment">// Base address</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !JOS_INC_MMU_H */</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>实验1：汇编，工具和引导</title>
    <url>/2024/03/08/lab1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<p>参考官网：<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/">https://pdos.csail.mit.edu/6.828/2017/labs/lab1/</a></p>
<p>AT&amp;T汇编：<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html</a></p>
<h2 id="启动操作系统"><a href="#启动操作系统" class="headerlink" title="启动操作系统"></a>启动操作系统</h2><p>安装lab的os：</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2017/jos.git lab</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#报错处理：fatal:unable to access &lt;url&gt; : server certificate...</span></span><br><span class="line"><span class="comment">#进入你的配置:</span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment">#添加以下代码来让你的电脑信任服务器</span></span><br><span class="line"><span class="built_in">export</span> GIT_SSL_NO_VERIFY=1</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入lab目录</span></span><br><span class="line">make &amp;&amp; make qemu</span><br></pre></td></tr></table></figure>

<p>make之后最后一行出现代表os内核映像编译成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure>

<p>make qemu之后出现如下图说明qemu连接成功</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211114666.png"></p>
<p>打开gdb查看bios</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lab目录下</span></span><br><span class="line">make qemu-gdb</span><br><span class="line"><span class="comment">#再开一个相同路径的terminal</span></span><br><span class="line">make gdb</span><br><span class="line"><span class="comment">#si命令逐步执行</span></span><br><span class="line"><span class="comment">#关闭gdb：q</span></span><br><span class="line"><span class="comment">#关闭qemu-gdb：ctrl + A 和 X,需要注意ctrl 与 A同时按住抬起后再按X,不要三个键同时按</span></span><br></pre></td></tr></table></figure>

<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><p>BIOS：Basic Input&#x2F;Output System</p>
<p>物理内存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>

<p>可以看到bios从1MB结束，早期的PC如8088物理内存只有1MB（0x00000000-0x000fffff），现在这台x86扩展到了4GB。</p>
<p>打开gdb实际运行一些si命令（逐步执行机器码），可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:	ljmp   <span class="variable">$0xf000</span>,<span class="variable">$0xe05b</span></span><br><span class="line"><span class="comment">#从接近bios顶部而不是960k地址进行长跳转到cs:0xf000(bios段基址),ip:0xe05b,反而往回跳</span></span><br><span class="line">0x0000fff0 <span class="keyword">in</span> ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e05b]    0xfe05b:	cmpl   <span class="variable">$0x0</span>,%cs:0x6ac8</span><br><span class="line">0x0000e05b <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>

<p>实验指导告诉我，bios在长跳转之后进行中断描述符表（IDT）的初始化和VGA等各种devices等初始化，于是继续查看得到以下内容：发现存在关中断（clean）命令。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211114662.png"></p>
<p>然后接着BIOS读取boot loader，进行boot驱动</p>
<h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>硬盘或者软盘最小单位为扇区（sector），一个扇区512字节，如果硬盘可以boot，那么这第一个扇区叫做bootsector，存放了boot loader 代码。</p>
<p>bios通过读取bootsector进入内存，从0x7c00-0x7dff.当然，现在不止读取一个扇区，也不止硬盘&#x2F;软盘作为boot来源。</p>
<p>对于boot loader，实验已经准备好了boot&#x2F;boot.S和boot&#x2F;main.c来模拟。</p>
<p>对于boot loader，做两件事：</p>
<ol>
<li><p>从实模式到保护模式，即将物理内存从1MB扩展到4GB，这需要GDT</p>
</li>
<li><p>从硬盘，通过x86的已经写好的IO驱动来使用IDE设备寄存器，从第二个扇区开始读取内核代码（obj&#x2F;kern&#x2F;kernel.asm）</p>
</li>
</ol>
<h3 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a>Exercise3</h3><ol>
<li><p>通过GDB在boot入口0x7c00进行断点设置</p>
</li>
<li><p>看 <code>boot/boot.S</code>里的代码, 看 <code>obj/boot/boot.asm</code> 来确定地址. 显示 boot loader在GDB中反汇编命令,比较三种汇编代码差异</p>
</li>
<li><p>继续看boot&#x2F;main.c 代码执行readsect()，找到c对应的汇编代码，紧接着代码执行回到bootmain函数 , 找到for循环（读取剩余内核代码），在for循环结束地址设置断点，然后单步执行，看看最终会做什么</p>
</li>
</ol>
<p>回答以下问题:</p>
<ul>
<li><p>代码从哪里开始执行32位保护模式？是什么导致了16位到32位到转换？</p>
</li>
<li><p>boot loader最后一个指令是什么,kernel第一个指令是什么？</p>
</li>
<li><p>kernel第一条指令的地址?</p>
</li>
<li><p>boot loader如何决定读取内核的所有扇区?从哪里能找到信息?</p>
</li>
</ul>
<p>我们通过GDB来设置breakpoint来跟踪boot loader过程</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211115296.png"></p>
<p>对比三个文件可以发现：GDB没有数据类型指定，如movb会执行为mov，同时boot.asm相较于boot.S少了头文件的引入标志，同时对于GDT只剩下CR0的开启</p>
<p>然后再看bootmain，调用两个函数：readseg和readsect</p>
<p>先定义了两个eh和eph，eph&#x3D;eh+程序num</p>
<p>然后从硬盘读一页，判定elf的魔数来决定内核是否合乎ELF格式，紧接着根据eph和eh使用for循环来加载剩余内核。</p>
<p>最后进入根据ELF节头表进入内核执行的entry</p>
<h3 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h3><ol>
<li><p>推荐阅读有关C指针内容：<em>C Programming Language</em> by Brian Kernighanand Dennis Ritchie (known as ‘K&amp;R’)</p>
</li>
<li><p>阅读从5.1到5.5，下载运行<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/pointers.c">以下C程序</a>，确保你懂了所有输出结果原因，给出以下标准</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.第一到第六行的输出地址</span><br><span class="line">2.第二到第四行输出结果</span><br><span class="line">3.第五行为什么输出错误</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里还有一个<a href="https://pdos.csail.mit.edu/6.828/2017/readings/pointers.pdf">参考</a>，不过不是很推荐</p>
</li>
<li><p>这个阅读实验一定要做，否则后续的代码编写，你会知道什么叫做 “残忍”</p>
</li>
<li><p>可以从本人的关键文件注释下参考代码解读</p>
</li>
</ol>
<h3 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a>Exercise5</h3><ol>
<li><p>重新看boot loader开始一部分代码，如果你修改链接地址，那么会有一些错误，找到关于链接地址的错误，在boot&#x2F;Makefrag里面修改</p>
</li>
<li><p>使用make clean清除上次make缓存</p>
</li>
<li><p>重新编译，运行代码，解释发生的错误情况</p>
</li>
</ol>
<p>这里对于boot loader再做一些讲解，在main.c里面非常重要的就是那个ELFHDR，是二进制格式，并且对于ELF有以下<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">讲解</a>，布局如下：<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211115296.png"></p>
<p>可以在inc&#x2F;elf.h里查看ELF布局，左边是链接视图，是目标代码格式，比如我们编写，链接重定位过程中使用。右边是可执行视图，在这里加载到内存时使用，并且section header table不是必须。（简单区分section和segment使用时机即可，详细看《深入理解计算机系统》）因此我们的loader根据ELF读取很多段，在硬盘中读取单位为扇区，详细看关键文件注释，先给出部分的解释：</p>
<ul>
<li><p>.text 程序的执行命令集</p>
</li>
<li><p>.rodata 只读数据，比如ASCII，当然硬件并不会禁止写操作（？）</p>
</li>
<li><p>.data 已初始化的全局数据，比如全局定义x&#x3D;5</p>
</li>
<li><p>.bss 未初始化的全局数据，在link阶段会留空间给他，并且.bss在程序运行时候必须全为0</p>
</li>
</ul>
<p>编译时候将每个.c文件编译称.o文件，编码为硬件预期的二进制格式。在obj&#x2F;kern&#x2F;kernel里把所有的.o文件链接成二进制image（映像），转换为ELF格式，因此ELF英文解释为“可执行可链接的格式”。</p>
<p>对于本实验，你只需要考虑它作为header的功能（所需来自ELF header 和program headers table）：将后面的程序节加载入内存。boot loader不区分加载代码还是数据，直接加载然后执行就完事了。</p>
<p>我们可以输入以下指令进入内核program headers看所有节</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -h obj/kern/kernel  </span><br><span class="line">//自己写的工具链就要多加i386-jos-elf-objdump</span><br></pre></td></tr></table></figure>

<p>你会看到很多节，远超上面列出来的。包括program header记录但是没有写进内存的。</p>
<p>重点来了：前面所说出问题的“链接地址”在此称作”VMA“，我们可以看作逻辑地址，由于还没分段，那么逻辑地址应该等于物理地址，也就是加载地址“LMA”。我们输入指令得到</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211115572.png"></p>
<p>看.text节。</p>
<p>接着还有以下两种指令供你参考：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -h obj/boot/boot.out //看boot被加载的section headers</span><br><span class="line">objdump -x obj/kern/kernel   //看内核所有headeres</span><br></pre></td></tr></table></figure>

<p>第二条命令执行后，可以看出Program Headers的字样，加载入内存的节会显示LOAD，和一些其他的信息，比如“paddr”代表物理地址，“vaddr”代表虚拟地址，“-sz”结尾代表大小</p>
<p>假设你已经理解了boot.S文件对于VMA的作用和某某关系（下面会讲），那么我们关注的VMA如何改？在boot&#x2F;Makefrag文件里，比如boot的VMA是0x7c00，那么对应文件里有-Ttext 0x7C00。</p>
<p>我将0x7c00改为0x2c00，会看到编译后的.asm从0x2c00开始boot，但是网上告诉我实际执行蹦过了这一段，头铁地接着从0x7c00开始运。运行一段时间后发现qemu-gdb报错<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211116815.png"></p>
<p>很显然这里的GDT全0，导致了一些错误，那么我们的链接地址VMA对GDT的初始化出现了问题。</p>
<p>对于GDT初始化，查看代码可以发现有以下指令</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211116196.png"></p>
<p>这里的lgdtw命令：将指定内存后的六个字节存放的GDTR寄存器里，发现存放的都是0，本应该是0x7c64，这里是第一个错误。</p>
<p>紧接着看：下面的ljmp会卡死，这条指令意思是以32位模式跳到下一条指令，本应该是0x7c32，但是同样出现了问题，后续的无法执行，即第二个错误。</p>
<h3 id="Exercise6"><a href="#Exercise6" class="headerlink" title="Exercise6"></a>Exercise6</h3><p>接着是内核的VMA，执行地址会指向高地址（VMA）但是实际上boot loader代码执行到低地址（LMA）。</p>
<p>看ELF header，里面的e_entry包含了就是我们的内核的（main.c里最后一句）VMA，可以通过以下指令查看entry的VMA</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -f obj/kern/kernel //查看file header</span><br></pre></td></tr></table></figure>

<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211117403.png"></p>
<p>我们可以看到这里这两个地址的区别，原因就在于ELF得到的有GDT的线性地址，在没有页表下的解决方案：KERNBASE的删减。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The kernel (this code) is linked at address ~(KERNBASE + 1 Meg), </span></span><br><span class="line"><span class="comment"># but the bootloader loads it at address ~1 Meg.</span></span><br></pre></td></tr></table></figure>

<p>假设你现在已经明白了main.c的过程，我们应该做一些事</p>
<ol>
<li><p>通过gdb 的x命令来查看内存，格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/Nx ADDR //从指定地址以N个word（我这台机器里是4B 32位）查看内存</span><br></pre></td></tr></table></figure>

<p>更多命令请看<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB手册</a></p>
</li>
<li><p>在进入boot时候来通过以下指令查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x/8x 0x00100000  //内核代码存放</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再以相同方式看看kernel的进入时候的存放内容，告诉我为什么存放内容不同</p>
</li>
</ol>
<p>在两个阶段查看结果如下：</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211117658.png"></p>
<p>如果你对boot干的事（1.保护模式2.load kernel sector）一清二楚的话，你就会知道，这个地址存放的八个字长内容不同是必然的。</p>
<h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>接下来的exercise中你将要写一些C代码了！</p>
<p><strong>使用虚拟内存来在独立空间里工作</strong></p>
<p>让我们看看LMA和VMA，在进入内核时候我们就发现了VMA和LMA的开始不同：ELF头显示了0x10001c的执行地址但是boot loader给出了0x10018的调用。</p>
<p>不过现在要完成完整的LMA转换：分段分页：内核页表结构的生成</p>
<p>在kern&#x2F;kernel.ld里，你就能看到VMA和LMA，一般内核喜欢让程序链接虚拟地址高地址，但是如何转化为内存物理地址呢？这种机制在lab2里会详细讲解。</p>
<p>对于本内核，VMA会给出0xf0100000，通过map分页得到物理地址0x00100000。现在先不说怎么做到，当然下个lab会教你如何在256MB限定下完成从虚拟地址0xf0000000 - 0xf0400000 映射物理地址0x00000000 - 0x00400000的分页map。</p>
<h3 id="Exercise7"><a href="#Exercise7" class="headerlink" title="Exercise7"></a>Exercise7</h3><ol>
<li>在内核kern&#x2F;kernel.asm代码movl %eax, %cr0处设置断点，看看内存0x00100000 和0xf0100000</li>
<li>单步执行，然后再看这两个内存，理解这其中的变化</li>
<li>如果分页机制的映射错了，那么第一行错的指令是什么，看看源代码文件，找出来</li>
</ol>
<p><strong>控制台的格式化输出</strong></p>
<p>C语言里有print（）格式化输出，同样I&#x2F;O也有，它叫cprintf，阅读</p>
<pre><code>kern/printf.c, lib/printfmt.c,  kern/console.c
</code></pre>
<p>这三个文件（看关键文件注释）来明白怎么这三个文件的关系。如果在后续的lab中你知道了为什么printfmt.c在lib目录下，这个关系就会变得很清楚。</p>
<h3 id="Exercise8"><a href="#Exercise8" class="headerlink" title="Exercise8"></a>Exercise8</h3><ol>
<li>在cprintf（）方法里我们省略了一小段代码：使用“%o”来打印八进制，</li>
</ol>
<p>回答以下问题：</p>
<ol>
<li><p>解释printf.c和console.c之间的接口，详细点：前者调用了什么功能，后者输出了什么功能</p>
</li>
<li><p>解释下列关于console 的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">            <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">                    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            crt_pos -= CRT_COLS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单步执行以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在cprintf（），fmt指向什么，ap指向什么</p>
</li>
<li><p>列出每个对于cons_putc, va_arg, 和vcprintf的调用</p>
</li>
<li><p>cons_putc:列出形参</p>
</li>
<li><p>va_arg:说出ap之前指向与调用之后的指向</p>
</li>
<li><p>vcprintf:列出两个实参</p>
</li>
</ul>
</li>
<li><p>运行以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>输出是什么</p>
</li>
<li><p>单步执行解释输出的由来，有个<a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">ASCII表</a>供你参考</p>
</li>
<li><p>本次假设为小端，如果是大端你该怎么更改i的值？</p>
</li>
</ul>
</li>
<li><p>对于以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>“y&#x3D;”之后应该输出什么（提示：不唯一）？为什么会这样？</p>
</li>
<li><p>假设GCC改变调用约定（栈增长变为低地址-&gt;高地址），在（参数）声明顺序下堆栈传参，你要怎么改cprintf（）或者它的接口，来成功传参数？</p>
</li>
<li><p>提高实验：通过ASCII来显示彩色字符</p>
</li>
</ol>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Exercise9"><a href="#Exercise9" class="headerlink" title="Exercise9"></a>Exercise9</h3><ol>
<li><p>决定内核在哪初始化，并且确定栈的位置</p>
</li>
<li><p>内核代码如何为栈申请空间</p>
</li>
<li><p>栈空间的end是栈指针初始化esp的参考吗？</p>
</li>
</ol>
<p>我们知道栈是向下增长，具体为esp的逐步递减，在32位系统esp可以被4整除，这意味着esp的递减是4（比如0，4，8这样）。大量的指令比如call，通过使用这样的寄存器来访问地址</p>
<p>对于ebp寄存器，我们称之为“栈底”，很显然，指向高地址。比如在.c文件每个函数的调用时候，esp是通过指向ebp来完成函数栈的建立，随后esp递减。所以ebp用来定位多层函数时非常有用。因此相应的栈回溯功能是十分有必要的</p>
<h3 id="Exercise10"><a href="#Exercise10" class="headerlink" title="Exercise10"></a>Exercise10</h3><ol>
<li><p>为了了解函数调用，让我们追踪 <code>test_backtrace</code> 函数地址在 <code>obj/kern/kernel.asm</code>，设置断点，看看内核会做些什呢</p>
</li>
<li><p>每次递归嵌套多少个word通过函数传入栈？他们分别是什么</p>
</li>
<li><p>提示：你必须用本实验匹配的QEMU，不然你得自己翻译线性地址</p>
</li>
</ol>
<h3 id="Exercise11"><a href="#Exercise11" class="headerlink" title="Exercise11"></a>Exercise11</h3><p>monitor函数会在qemu的monitor（显示器）中让你看到一些日志，其中backtrace就能实现这个功能，当你输入：backtrace时候，就会打印日志</p>
<ol>
<li>实现上述指定的backtrace函数。</li>
</ol>
<p>对于这个exercise给你一些提示：你需要实现一个栈回溯功能，意味着你应该实现并调用mon_backtrace()，原型在kern&#x2F;monitor.c里。同时read_ebp() 在inc&#x2F;x86.h很有用。你应该让用户在交互时使用这个函数</p>
<p>这个栈回溯功能应该输出这个格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args <span class="number">00000001</span> f0109e80 f0109e98 f0100ed2 <span class="number">00000031</span></span><br><span class="line">  ebp f0109ed8  eip f01000d6  args <span class="number">00000000</span> <span class="number">00000000</span> f0100058 f0109f28 <span class="number">00000061</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>是不是很眼熟？对。gdb功能里 i r ebp eip也有类似的功能。</p>
<p>每行我们应该有ebp，eip，args。下面对格式进行一个简短的说明</p>
<ul>
<li><p>ebp为函数调用后的栈底</p>
</li>
<li><p>eip为函数返回后的ip，偷偷告诉你，就在ebp上面</p>
</li>
<li><p>args后的五个十六进制是五个参数，可以传参少于这个数，但是仍然列出5个</p>
</li>
</ul>
<p>然后我们对内容进行一个简短对说明</p>
<ul>
<li><p>第一行反应了现在执行函数，也就是mon_backtrace</p>
</li>
<li><p>第二行是调用mon_backtrace对函数</p>
</li>
<li><p>第三行往后即再上层调用，以此类推</p>
</li>
</ul>
<p>你应该打印合适的栈内容，从kern&#x2F;entry.S中，确定什么时候终止打印</p>
<p>接下来是关于接下来实验的理论提示。这是对K&amp;R第五章的一些内容</p>
<ul>
<li><p>Int *p&#x3D; (int *)100, 则（int）p+1&#x3D;101,(int) (p+1)&#x3D;104</p>
</li>
<li><p>p[i]&#x3D;*(p+i)</p>
</li>
<li><p>&amp;p[i]&#x3D;(p+i)</p>
</li>
<li><p>其实指针不难，你画图理解就行了</p>
</li>
</ul>
<p>每当操作系统对内存地址描述时，谨记：是值还是指针（地址址）。</p>
<h3 id="Exercise12"><a href="#Exercise12" class="headerlink" title="Exercise12"></a>Exercise12</h3><ol>
<li><p>monitor修改backtrace函数，增加显示：eip，函数名，源文件名，eip对应行数，在kernel&#x2F;kdebug.c修改debuginfo_eip</p>
</li>
<li><p>问题：在debuginfo_eip 中，_<em>STAB</em>*是哪里来的？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给出以下线索</span><br><span class="line"><span class="number">1.</span>kern/kernel.ld找出_STAB_*</span><br><span class="line"><span class="number">2.</span>运行objdump -h/-G kern/kernel</span><br><span class="line"><span class="number">3.</span>gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c,然后查看init.S</span><br><span class="line"><span class="number">4.</span>确定bootloader在加载内核ELF时候是否把符号表加载进来</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="c">编写代码，让mon_backtrace能够调用debuginfo_eip，实现后者，输出格式如下：
K&gt; backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
         kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
         kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
         kern/entry.S:70: &lt;unknown&gt;+0
K&gt; 
tips：printf(&quot;%.*s&quot;, length, string)可以让你输出指定长度的字符串，对文件名好用

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 回答问题汇总</span><br><span class="line"></span><br><span class="line">### Exercise3</span><br><span class="line"></span><br><span class="line">1.  .code32伪指令开始；ljmp语句切换，从16位地址模式切换到32位地址模式</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    7d81:	ff 15 18 00 01 00    	call   *0x10018</span><br><span class="line">    0x10000c:	movw   $0x1234,0x472</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>由GDB或者kernel&#x2F;entry.S可以得知为0x10000c</p>
</li>
<li><p>ELF存放了程序段数，段基址，段长</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ph每个结点为一个段</span></span><br><span class="line">ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">		<span class="comment">// p_pa 是加载内核的程序段基址</span></span><br><span class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Exercise4-1"><a href="#Exercise4-1" class="headerlink" title="Exercise4"></a>Exercise4</h3><p>1.学习笔记</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>单目运算符结合方向为从右向左。</span><br><span class="line">举例：</span><br><span class="line">*p++;  <span class="comment">// 将指针p的值加1，然后获取指针ip所指向的数据的值</span></span><br><span class="line">(*p)++;  <span class="comment">// 将指针p所指向的数据的值加1</span></span><br><span class="line"><span class="number">2.</span>对于a[i]，C编译器会立即将其转换为*(a+i)。同时对于i[a],计算结果相同。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组名和指针的一个区别：指针是变量，可以进行赋值和加减运算；数组名不是变量，不能进行赋值和加减运算。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>p[<span class="number">-1</span>],在语法上是合法的，只要保证元素存在，因此带来了安全隐患。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>指向同一个数组（包括数组最后一个元素的下一个元素，可能考虑到兼容字符的<span class="string">&#x27;\0&#x27;</span>）的两个指针可以进行大小比较，而对没有指向同一个数组的两个指针进行大小比较的行为是undefined的。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>指针的合法操作：同类指针赋值、指针加减某个整数、指向同一数组的两个指针相减或比较大小（存放的值而不是说指向的值）、将指针赋值为<span class="number">0</span>或与<span class="number">0</span>比较；</span><br><span class="line">指针的非法操作：两个指针相加、相乘、相除，以及指针与浮点数相加减等。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span><span class="type">char</span> *p = <span class="string">&quot;now is the time&quot;</span>；是将一个指向字符数组的指针赋值给p，而不是字符串拷贝。C语言不提供任何对整个字符串作为一个单元进行处理的操作符。</span><br><span class="line"></span><br><span class="line">注意通过字符串指针修改字符串内容的行为是undefined的：</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;now is the time&quot;</span>;  <span class="comment">// an array</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;now is the time&quot;</span>;   <span class="comment">// a pointer</span></span><br></pre></td></tr></table></figure>

<ol>
<li>解读答案看关键文件注释</li>
</ol>
<h3 id="Exercise6-1"><a href="#Exercise6-1" class="headerlink" title="Exercise6"></a>Exercise6</h3><pre><code>刚进入boot时候BIOS上的地址没动过，此时从0x7c00开始boot会通过设置的保护模式将内核代码加载入内存，这时候高地址才会被修改，紧接着进入内核代码。
</code></pre>
<h3 id="Exercise7-1"><a href="#Exercise7-1" class="headerlink" title="Exercise7"></a>Exercise7</h3><p>1.<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211117410.png"></p>
<p>2.单步执行后</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211117952.png"></p>
<p>可以发现二者映射相同</p>
<p>问题：为什么？</p>
<p>A：对于GDB而言，代码地址，数据地址部分都是ELF里规定好的，当我们修改，查看地址内容时候也是有被页表转换查看，否则我一个程序查看比如数组内容，代码显示的内存地址就没用了。</p>
<p>所以无论是ELF存放的是系统的内核代码还是用户代码都一视同仁。但是我们一开始在低地址加载内核代码，也确实应该在低地址修改内存，而不是内核代码指定的高地址，并且没有开启页表没法转换。</p>
<p>之前做的kernbase消除这一问题，等于做了个“假页表”，而题目给出的汇编代码即开启页表，开启之后的映射就会按照页表的页表项进行映射，因此我们就会发现gdb查看的地址内容符合内核代码给的地址操作。</p>
<p>3.关键代码即题目所给代码，如果注释掉，假页表映射有限，会出现访问越界问题</p>
<h3 id="Exercise8-1"><a href="#Exercise8-1" class="headerlink" title="Exercise8"></a>Exercise8</h3><ol>
<li><pre><code class="c">//给出八进制代码
num = getuint(&amp;ap, lflag);
            //设置基数为8
            base = 8;
            goto number;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   其余解释查看关键文件注释</span><br><span class="line"></span><br><span class="line">2. console.c</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">        for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">                crt_buf[i] = 0x0700 | &#x27; &#x27;;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line"> &#125;</span><br><span class="line">* 变量</span><br><span class="line">crt_pos      CRT_SIZE    CRT_COLS          crt_buf</span><br><span class="line">尾字符位置    页char大小    字符列数         字符buf</span><br><span class="line"></span><br><span class="line">* 函数</span><br><span class="line">memcpy 内存复制</span><br><span class="line"></span><br><span class="line">* 过程</span><br><span class="line">如果发现尾字符位置超过一页位置，就应该讲这一页向上一行进行复制，然后清空这腾出来的一行，然后修改尾字符位置向上一行</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="c">int x = 1, y = 3, z = 4;
cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);

* 调用cprintf，fmt什么内容，ap什么内容
&quot;x %d, y %x, z %d\n&quot;，ap为va_list，即所有参数列表，包括了xyz

* 按照执行的顺序列出所有对cons_putc, va_arg，和vcprintf的调用
看注释

* 列出每个对于cons_putc, va_arg, 和vcprintf的调用
看注释

* cons_putc:列出形参
int c

* va_arg:说出ap之前指向与调用之后的指向
ap:1,3,4=&gt;3,4

* vcprintf:列出两个实参
&quot;x %d, y %x, z %d\n&quot;  1,3,4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. ```c</span><br><span class="line">       unsigned int i = 0x00646c72;</span><br><span class="line">           cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">   </span><br><span class="line">   *   输出是什么</span><br><span class="line">   He110 World</span><br><span class="line">   </span><br><span class="line">   *   单步执行解释输出的由来，有个[ASCII表](http://web.cs.mun.ca/\~michael/c/ascii-table.html)供你参考</span><br><span class="line">   1.第一个参数的值是57616，它对应的16进制的表示形式为e110，所以前面就变成的He110。</span><br><span class="line">   2.输出参数所指向的字符串,变量i代表字符串。但是i定义为int，所以我们按字节分析出char</span><br><span class="line">   3.x86是小端模式，高字节放在高地址。所以存放顺序0x72(&#x27;r&#x27;)，0x6c(&#x27;l&#x27;)，0x64(&#x27;d&#x27;)，0x00(&#x27;\0&#x27;).</span><br><span class="line">   5.所以在cprintf将会从i的地址开始一个字节一个字节遍历，正好输出 &quot;World&quot;</span><br><span class="line">   </span><br><span class="line">   *   本次假设为小端，如果是大端你该怎么更改i的值？</span><br><span class="line">   i = 0x726c6400</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">* “y=”之后应该输出什么（提示：不唯一）？为什么会这样？</span><br><span class="line">getint调用va_arg时候，取，更改参数因为没有指定y，所以参数下标越界</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#96;&#96;&#96;c<br>假设GCC改变调用约定（栈增长变为低地址-&gt;高地址），在（参数）声明顺序下堆栈传参，你要怎么改cprintf（）或者它的接口，来成功传参数？<br>形参反序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### Exercise9</span><br><span class="line"></span><br><span class="line">给出obj/kern/kernel.asm中有关代码</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">1.内核为栈的开辟做准备：第一次没有esp，ebp，所以额外准备</span><br><span class="line">f010002f:	bd 00 00 00 00       	mov    $0x0,%ebp</span><br><span class="line"></span><br><span class="line">	# Set the stack pointer</span><br><span class="line">	movl	$(bootstacktop),%esp</span><br><span class="line">f0100034:	bc 00 00 11 f0       	mov    $0xf0110000,%esp</span><br><span class="line"></span><br><span class="line">	# 之前内核的entry作初始化，为栈开辟作准备，然后我们正式开始C代码，为接下来内核的main做准备：先开辟main栈</span><br><span class="line">	call	i386_init</span><br><span class="line">f0100039:	e8 6c 00 00 00       	call   f01000aa &lt;i386_init&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.内核申请第一个栈：</span><br><span class="line">void</span><br><span class="line">i386_init(void)</span><br><span class="line">&#123;</span><br><span class="line">f01000aa:	f3 0f 1e fb          	endbr32 </span><br><span class="line">f01000ae:	55                   	push   %ebp</span><br><span class="line">f01000af:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f01000b1:	53                   	push   %ebx</span><br><span class="line">f01000b2:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">//紧接着为新的ELF加载做准备：.bss,static之类，之前只是确定位置，并没有清零</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Exercise10-1"><a href="#Exercise10-1" class="headerlink" title="Exercise10"></a>Exercise10</h3><p>给出test_backtrace及其有关反汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test_backtrace</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_backtrace</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">f0100040:	f3 <span class="number">0f</span> <span class="number">1</span>e fb          	endbr32 </span><br><span class="line">f0100044:	<span class="number">55</span>                   	push   %ebp</span><br><span class="line">f0100045:	<span class="number">89</span> e5                	mov    %esp,%ebp</span><br><span class="line">f0100047:	<span class="number">56</span>                   	push   %esi<span class="comment">//第一个参数4B</span></span><br><span class="line">f0100048:	<span class="number">53</span>                   	push   %ebx<span class="comment">//第二个参数4B</span></span><br><span class="line">f0100049:	e8 <span class="number">7</span>e <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	call   f01001cc &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">f010004e:	<span class="number">81</span> c3 ba <span class="number">12</span> <span class="number">01</span> <span class="number">00</span>    	add    $<span class="number">0x112ba</span>,%ebx</span><br><span class="line">f0100054:	<span class="number">8b</span> <span class="number">75</span> <span class="number">08</span>             	mov    <span class="number">0x8</span>(%ebp),%esi<span class="comment">//看下面的eax</span></span><br><span class="line">	cprintf(<span class="string">&quot;entering test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">f0100057:	<span class="number">83</span> ec <span class="number">08</span>             	sub    $<span class="number">0x8</span>,%esp</span><br><span class="line">f010005a:	<span class="number">56</span>                   	push   %esi</span><br><span class="line">f010005b:	<span class="number">8</span>d <span class="number">83</span> d8 <span class="number">07</span> ff ff    	lea    <span class="number">-0xf828</span>(%ebx),%eax</span><br><span class="line">f0100061:	<span class="number">50</span>                   	push   %eax</span><br><span class="line">f0100062:	e8 <span class="number">26</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span>       	call   f0100a8d &lt;cprintf&gt;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">f0100067:	<span class="number">83</span> c4 <span class="number">10</span>             	add    $<span class="number">0x10</span>,%esp</span><br><span class="line">f010006a:	<span class="number">85</span> f6                	test   %esi,%esi</span><br><span class="line">f010006c:	<span class="number">7</span>e <span class="number">29</span>                	jle    f0100097 &lt;test_backtrace+<span class="number">0x57</span>&gt;<span class="comment">//x==0</span></span><br><span class="line">		test_backtrace(x<span class="number">-1</span>);</span><br><span class="line">f010006e:	<span class="number">83</span> ec <span class="number">0</span>c             	sub    $<span class="number">0xc</span>,%esp</span><br><span class="line">f0100071:	<span class="number">8</span>d <span class="number">46</span> ff             	lea    <span class="number">-0x1</span>(%esi),%eax<span class="comment">//x-1</span></span><br><span class="line">f0100074:	<span class="number">50</span>                   	push   %eax<span class="comment">//callee会将eax作为返回值使用，caller为callee传入x-1保存在这里</span></span><br><span class="line">f0100075:	e8 c6 ff ff ff       	call   f0100040 &lt;test_backtrace&gt;<span class="comment">//递归调用</span></span><br><span class="line">f010007a:	<span class="number">83</span> c4 <span class="number">10</span>             	add    $<span class="number">0x10</span>,%esp</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="title function_">mon_backtrace</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span>;</span><br><span class="line">	cprintf(<span class="string">&quot;leaving test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">f010007d:	<span class="number">83</span> ec <span class="number">08</span>             	sub    $<span class="number">0x8</span>,%esp</span><br><span class="line">f0100080:	<span class="number">56</span>                   	push   %esi</span><br><span class="line">f0100081:	<span class="number">8</span>d <span class="number">83</span> f4 <span class="number">07</span> ff ff    	lea    <span class="number">-0xf80c</span>(%ebx),%eax</span><br><span class="line">f0100087:	<span class="number">50</span>                   	push   %eax</span><br><span class="line">f0100088:	e8 <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span>       	call   f0100a8d &lt;cprintf&gt;</span><br><span class="line">&#125;</span><br><span class="line">f010008d:	<span class="number">83</span> c4 <span class="number">10</span>             	add    $<span class="number">0x10</span>,%esp</span><br><span class="line">f0100090:	<span class="number">8</span>d <span class="number">65</span> f8             	lea    <span class="number">-0x8</span>(%ebp),%esp</span><br><span class="line">f0100093:	<span class="number">5b</span>                   	pop    %ebx</span><br><span class="line">f0100094:	<span class="number">5</span>e                   	pop    %esi</span><br><span class="line">f0100095:	<span class="number">5</span>d                   	pop    %ebp</span><br><span class="line">f0100096:	c3                   	ret    </span><br><span class="line"></span><br><span class="line"><span class="comment">//		mon_backtrace(0, 0, 0);</span></span><br><span class="line">f0100097:	<span class="number">83</span> ec <span class="number">04</span>             	sub    $<span class="number">0x4</span>,%esp</span><br><span class="line">f010009a:	<span class="number">6</span>a <span class="number">00</span>                	push   $<span class="number">0x0</span></span><br><span class="line">f010009c:	<span class="number">6</span>a <span class="number">00</span>                	push   $<span class="number">0x0</span></span><br><span class="line">f010009e:	<span class="number">6</span>a <span class="number">00</span>                	push   $<span class="number">0x0</span></span><br><span class="line">f01000a0:	e8 <span class="number">0</span>c <span class="number">08</span> <span class="number">00</span> <span class="number">00</span>       	call   f01008b1 &lt;mon_backtrace&gt;</span><br><span class="line">f01000a5:	<span class="number">83</span> c4 <span class="number">10</span>             	add    $<span class="number">0x10</span>,%esp</span><br><span class="line">f01000a8:	eb d3                	jmp    f010007d &lt;test_backtrace+<span class="number">0x3d</span>&gt;<span class="comment">//返回test_backtrace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test_backtrace</span></span><br><span class="line">	<span class="comment">// Test the stack backtrace function (lab 1 only)</span></span><br><span class="line">	test_backtrace(<span class="number">5</span>);</span><br><span class="line">f01000f0:	c7 <span class="number">04</span> <span class="number">24</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movl   $<span class="number">0x5</span>,(%esp)</span><br><span class="line">f01000f7:	e8 <span class="number">44</span> ff ff ff       	call   f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Exercise11-1"><a href="#Exercise11-1" class="headerlink" title="Exercise11"></a>Exercise11</h3><p>给出mon_backtrace的补全代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span><span class="comment">//参数个数，参数列表，还有一个不知道啥，不影响</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *ebp = (<span class="type">int</span> *)read_ebp();<span class="comment">//read得到ebp寄存器的值，然后转为指针：就像寄存器那样干</span></span><br><span class="line">	</span><br><span class="line">	cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>((<span class="type">int</span>)ebp != <span class="number">0x0</span>) &#123;<span class="comment">//end of print：main栈前</span></span><br><span class="line">		cprintf(<span class="string">&quot;  ebp %08x&quot;</span>, *ebp);</span><br><span class="line">		cprintf(<span class="string">&quot;  eip %08x&quot;</span>, *(ebp+<span class="number">1</span>));</span><br><span class="line">		cprintf(<span class="string">&quot;  args&quot;</span>);</span><br><span class="line">		cprintf(<span class="string">&quot; %08x&quot;</span>, *(ebp+<span class="number">2</span>));</span><br><span class="line">		cprintf(<span class="string">&quot; %08x&quot;</span>, *(ebp+<span class="number">3</span>));</span><br><span class="line">		cprintf(<span class="string">&quot; %08x&quot;</span>, *(ebp+<span class="number">4</span>));</span><br><span class="line">		cprintf(<span class="string">&quot; %08x&quot;</span>, *(ebp+<span class="number">5</span>));</span><br><span class="line">		cprintf(<span class="string">&quot; %08x\n&quot;</span>, *(ebp+<span class="number">6</span>));<span class="comment">//5个参数</span></span><br><span class="line">		ebp = (<span class="type">int</span> *)(*ebp);<span class="comment">//别忘了类型转换</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Exercise12-1"><a href="#Exercise12-1" class="headerlink" title="Exercise12"></a>Exercise12</h3><p>给出以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更详细代码看注释</span></span><br><span class="line"><span class="comment">//backtrace</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *ebp = (<span class="type">int</span> *)read_ebp();<span class="comment">//like %ebp</span></span><br><span class="line">	cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span><span class="comment">//文件string信息，定义在kdebug.h</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ebp != <span class="number">0x0</span>) &#123;</span><br><span class="line">		<span class="comment">// 第一行的当前ebp和栈环境是mon_backtrace的</span></span><br><span class="line">		cprintf(<span class="string">&quot;ebp %8x eip %8x args %08x %08x %08x %08x %08x &quot;</span>, </span><br><span class="line">				ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line">		debuginfo_eip(ebp[<span class="number">1</span>], &amp;info);</span><br><span class="line">		cprintf(<span class="string">&quot;%s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, </span><br><span class="line">				info.eip_fn_name, ebp[<span class="number">1</span>]-info.eip_fn_addr);</span><br><span class="line">		ebp = (<span class="type">int</span> *)ebp[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Eipdebuginfo</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *eip_file;		<span class="comment">// Eip所在文件名</span></span><br><span class="line">	<span class="type">int</span> eip_line;			<span class="comment">// eip所在文件源代码行数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *eip_fn_name;	<span class="comment">// eip所在函数名</span></span><br><span class="line">					<span class="comment">//  - Note: not null terminated!</span></span><br><span class="line">	<span class="type">int</span> eip_fn_namelen;		<span class="comment">// 函数长度</span></span><br><span class="line">	<span class="type">uintptr_t</span> eip_fn_addr;		<span class="comment">// 函数开始地址</span></span><br><span class="line">	<span class="type">int</span> eip_fn_narg;		<span class="comment">// 函数的参数个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stab</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> n_strx;	<span class="comment">// index into string table of name</span></span><br><span class="line">	<span class="type">uint8_t</span> n_type;         <span class="comment">// 类型,比如fun，so</span></span><br><span class="line">	<span class="type">uint8_t</span> n_other;        <span class="comment">// misc info (usually empty)</span></span><br><span class="line">	<span class="type">uint16_t</span> n_desc;        <span class="comment">// 给定类型下的描述域,题目下是代码长度</span></span><br><span class="line">	<span class="type">uintptr_t</span> n_value;	<span class="comment">// 符号值，本题当作地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//debuginfo_eip增加内容 </span></span><br><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);<span class="comment">//二分搜索得到代码行数</span></span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定符号表stab的例子更直观查看<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211435651.png"></p>
<p>happy！代码在这里：<a href="https://github.com/sakura-mac/mit_6.828_jos">Source Code</a></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211118460.png"></p>
<h2 id="关键文件注释"><a href="#关键文件注释" class="headerlink" title="关键文件注释"></a>关键文件注释</h2><h3 id="boot-x2F-boot-S"><a href="#boot-x2F-boot-S" class="headerlink" title="boot&#x2F;boot.S"></a>boot&#x2F;boot.S</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt;</span><br><span class="line"></span><br><span class="line"># 转换为32位保护模式，然后跳转到main.c执行</span><br><span class="line"># BIOS从硬盘第一个扇区加载这个代码到内存0x7c00处</span><br><span class="line"># 然后以%cs=0 %ip=7c00开始执行保 护模式</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8         # 内核代码段选择子</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # 内核数据段选择子</span><br><span class="line">.set CR0_PE_ON,      0x1         # 保护模式开关</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     # 汇编为16位模式</span><br><span class="line">  cli                         # 关中断</span><br><span class="line">  cld                         # 字符串增量操作（清eflags里DF，进行一个顺序处理）</span><br><span class="line"></span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">  xorw    %ax,%ax             # 第0段</span><br><span class="line">  movw    %ax,%ds             # -&gt; 代码段</span><br><span class="line">  movw    %ax,%es             # -&gt; 附加段</span><br><span class="line">  movw    %ax,%ss             # -&gt; 栈段</span><br><span class="line"></span><br><span class="line">  # 打开A20:</span><br><span class="line">  #   对于早期PC, 物理地址只有20位地址线，超过则会进位为0，而后来为了兼容即在16位到	 #	 32位转换时打开第21位地址线，从而为GDT做准备</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # 等待不忙</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; 端口 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # 等待不忙</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; 端口 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br><span class="line">  # 转换实模式到保护模式, 通过使用GDT和段转换确保虚拟地址和物理地址一一对应</span><br><span class="line">  # 因此有效mermory map在这个过程中不改变</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  </span><br><span class="line">  # 以32位模式，跳转到下一个指令</span><br><span class="line">  # 即进入32位模式</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">  .code32                     # 汇编伪指令32位模式</span><br><span class="line">protcseg:</span><br><span class="line">  # 设置保护模式到数据寄存器</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # 段选择子</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: 数据段</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: 附加段</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: 栈段</span><br><span class="line">  </span><br><span class="line">  # 把栈顶指针esp指向main.c文件中去</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">  # 当然如果引导gdt返回（失败），那么就死循环</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line"># 引导GDT，也可以认为初始化</span><br><span class="line">.p2align 2                                # 4字节对齐</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				# 空段</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# 代码段</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # 数据段</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # gdt长度-1</span><br><span class="line">  .long   gdt                             # gdt的地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="boot-x2F-main-c"><a href="#boot-x2F-main-c" class="headerlink" title="boot&#x2F;main.c"></a>boot&#x2F;main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> *简易的的boot loader，功能为从第一个IDE硬盘读取ELF格式的内核 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *硬盘格式</span></span><br><span class="line"><span class="comment"> *  * boot.S和main.c是boot loader的全部代码，存放第一个扇区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 第二个扇区开始存放内核</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 内核img必须是ELF格式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * boot 步骤</span></span><br><span class="line"><span class="comment"> *  * 当cpu再BIOS中加载硬盘到内存中时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * BIOS初始化设备,中断描述符表, 读取第一个扇区到内存然后jmp到0x7c00</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 然后boot loader执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 从boot.S开始执行，它将会设置保护模式，然后main.c接管</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  * bootmain()就是本文件，它接管后到任务就是读取内核，跳转内核</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTSIZE	512 <span class="comment">//扇区字节大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="comment">// 判定抓取内核空间</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span>*, <span class="type">uint32_t</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span>, <span class="type">uint32_t</span>, <span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从硬盘中读取一页</span></span><br><span class="line">	readseg((<span class="type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判定是否ELF格式</span></span><br><span class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载每个内核段 (忽略 ph flags)，接下来两行都是源自ELF header</span></span><br><span class="line"><span class="comment">/*ELF program header</span></span><br><span class="line"><span class="comment"> *int type; // loadable code or data, dynamic linking info, etc. </span></span><br><span class="line"><span class="comment"> *int offset; // ELF里段偏移</span></span><br><span class="line"><span class="comment"> *int virtaddr; // virtual address to map segment </span></span><br><span class="line"><span class="comment"> *int physaddr; // physical address, not used 还没分页所以没用</span></span><br><span class="line"><span class="comment"> *int filesize; // size of segment in file </span></span><br><span class="line"><span class="comment"> *int memsize; // size of segment in memory (bigger if contains BSS) </span></span><br><span class="line"><span class="comment"> *int flags; // Read, Write, Execute bits</span></span><br><span class="line"><span class="comment"> *int align; // required alignment, invariably hardware page size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">	ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">		<span class="comment">// p_pa 是加载内核的程序段偏移，接下来一行源自program header</span></span><br><span class="line">    <span class="comment">//加载每个程序段（忽略ph标志）</span></span><br><span class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从ELF头得到信息进入内核执行entry,源自ELF header</span></span><br><span class="line">	<span class="comment">// notes：不返回！，汇编指令call   *0x10018</span></span><br><span class="line">	((<span class="type">void</span> (*)(<span class="type">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		<span class="comment">/* 什么都不干 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从‘offset’在内核中读取‘count’字节数，返回到地址‘pa’</span></span><br><span class="line"><span class="comment">// 可能复制量超过要求！</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">	end_pa = pa + count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向下取到扇区边界</span></span><br><span class="line">	pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把字节转换为扇区，然后内核从扇区1开始执行</span></span><br><span class="line">	offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果太慢，可以一次读很多扇区</span></span><br><span class="line">	<span class="comment">// 我们可以写内存超过要求，但是没关系 --</span></span><br><span class="line">	<span class="comment">// 因为可以递增加载</span></span><br><span class="line">	<span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">		<span class="comment">// 因为还没开启分页，并且使用了指定段表 (see boot.S),所以可以直接访问物理地 			//址.  当然JOS如果使用了MMU就不行了</span></span><br><span class="line">		readsect((<span class="type">uint8_t</span>*) pa, offset);</span><br><span class="line">		pa += SECTSIZE;</span><br><span class="line">		offset++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 等待硬盘就绪</span></span><br><span class="line">	<span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 等待硬盘就绪</span></span><br><span class="line">	waitdisk();</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1</span></span><br><span class="line">	outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">	outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// 硬件读取命令cmd 0x20 - 来读取扇区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待硬盘就绪</span></span><br><span class="line">	waitdisk();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读一个扇区</span></span><br><span class="line">	insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pointers-c"><a href="#Pointers-c" class="headerlink" title="Pointers.c"></a>Pointers.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//a,b,c,i相邻存放，存放顺序取决于本身计算机大端还是小端,假设小端存放</span></span><br><span class="line"><span class="comment">//第一行 1: a = %p, b = %p, c = %p 输出各自的值，由于没有定义所以不确定</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	a[i] = <span class="number">100</span> + i;	<span class="comment">//a[0...3]= 100, 101, 102, 103</span></span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;	<span class="comment">//a[0]=200</span></span><br><span class="line"><span class="comment">//第二行 2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;	<span class="comment">// a[1]=300</span></span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;	<span class="comment">// a[2]=301</span></span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;	<span class="comment">// *（3+c）即a[3]=302</span></span><br><span class="line"><span class="comment">//第三行 3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;</span><br><span class="line">    *c = <span class="number">400</span>;<span class="comment">//a[1]=400</span></span><br><span class="line"><span class="comment">//第四行 4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">int</span> *) ((<span class="type">char</span> *) c + <span class="number">1</span>); </span><br><span class="line">    *c = <span class="number">500</span>;<span class="comment">//301=16*(2+16)+13</span></span><br><span class="line">    <span class="comment">//a[1]=0x190,a[2]=0x12d,500=0x1f4小端存放: 90 f4 01 00 00 01 00 00 </span></span><br><span class="line">    <span class="comment">//a[1]=0x1f490=0+144+1024+61140+65536=127844</span></span><br><span class="line">    <span class="comment">//：90 f4 01 00 00 01 00 00-&gt;a[1]=127844,a[2]=256</span></span><br><span class="line"><span class="comment">//第五行 5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">int</span> *) a + <span class="number">1</span>;<span class="comment">//b指向a[1]</span></span><br><span class="line">    c = (<span class="type">int</span> *) ((<span class="type">char</span> *) a + <span class="number">1</span>);<span class="comment">//同上，从a[0]第二个字节开始修改，影响a[0]与a[1]</span></span><br><span class="line"><span class="comment">//第六行 6: a = %p, b = %p, c = %p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span> **av)</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kern-x2F-printf-c"><a href="#kern-x2F-printf-c" class="headerlink" title="kern&#x2F;printf.c"></a>kern&#x2F;printf.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于printfmt格式化和cputchar内核控制台输出，来完成内核输出到控制台的功能</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">putch</span><span class="params">(<span class="type">int</span> ch, <span class="type">int</span> *cnt)</span><span class="comment">//3.调用cputchar</span></span><br><span class="line">&#123;</span><br><span class="line">	cputchar(ch);<span class="comment">//内核态向控制台输出</span></span><br><span class="line">	*cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vcprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span><span class="comment">//2.调用vprintfmt，输入putch返回值作参数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	vprintfmt((<span class="type">void</span>*)putch, &amp;cnt, fmt, ap);<span class="comment">//四个参数：1.函数指针2.计数3.格式4.参数列表</span></span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><span class="comment">//1.调用cprintf</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list ap;<span class="comment">//参数列表</span></span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">	va_start(ap, fmt);<span class="comment">//把xyz这样的参数使用ap指向</span></span><br><span class="line">	cnt = vcprintf(fmt, ap);<span class="comment">//传入格式，参数列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="lib-x2F-printfmt-c"><a href="#lib-x2F-printfmt-c" class="headerlink" title="lib&#x2F;printfmt.c"></a>lib&#x2F;printfmt.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分析输出格式：词法分析的感觉，根据格式要求来决定参数的合法判定，输出格式</span></span><br><span class="line"><span class="comment">// 常见于printf, sprintf, fprintf, etc.</span></span><br><span class="line"><span class="comment">// 内核态和用户态都有调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/error.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Space or zero padding and a field width are supported for the numeric</span></span><br><span class="line"><span class="comment"> * formats only.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The special format %e takes an integer error code</span></span><br><span class="line"><span class="comment"> * and prints a string describing the error.</span></span><br><span class="line"><span class="comment"> * The integer may be positive or negative,</span></span><br><span class="line"><span class="comment"> * so that -E_NO_MEM and E_NO_MEM are equivalent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> error_string[MAXERROR] =</span><br><span class="line">&#123;</span><br><span class="line">	[E_UNSPECIFIED]	= <span class="string">&quot;unspecified error&quot;</span>,</span><br><span class="line">	[E_BAD_ENV]	= <span class="string">&quot;bad environment&quot;</span>,</span><br><span class="line">	[E_INVAL]	= <span class="string">&quot;invalid parameter&quot;</span>,</span><br><span class="line">	[E_NO_MEM]	= <span class="string">&quot;out of memory&quot;</span>,</span><br><span class="line">	[E_NO_FREE_ENV]	= <span class="string">&quot;out of environments&quot;</span>,</span><br><span class="line">	[E_FAULT]	= <span class="string">&quot;segmentation fault&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Print a number (base &lt;= 16) in reverse order,</span></span><br><span class="line"><span class="comment"> * using specified putch function and associated pointer putdat.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">printnum</span><span class="params">(<span class="type">void</span> (*putch)(<span class="type">int</span>, <span class="type">void</span>*), <span class="type">void</span> *putdat,</span></span><br><span class="line"><span class="params">	 <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> num, <span class="type">unsigned</span> base, <span class="type">int</span> width, <span class="type">int</span> padc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// first recursively print all preceding (more significant) digits</span></span><br><span class="line">	<span class="keyword">if</span> (num &gt;= base) &#123;</span><br><span class="line">		printnum(putch, putdat, num / base, base, width - <span class="number">1</span>, padc);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// print any needed pad characters before first digit</span></span><br><span class="line">		<span class="keyword">while</span> (--width &gt; <span class="number">0</span>)</span><br><span class="line">			putch(padc, putdat);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then print this (the least significant) digit</span></span><br><span class="line">	putch(<span class="string">&quot;0123456789abcdef&quot;</span>[num % base], putdat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get an unsigned int of various possible sizes from a varargs list,</span></span><br><span class="line"><span class="comment">// depending on the lflag parameter.</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">getuint</span><span class="params">(va_list *ap, <span class="type">int</span> lflag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lflag &gt;= <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> va_arg(*ap, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (lflag)</span><br><span class="line">		<span class="keyword">return</span> va_arg(*ap, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> va_arg(*ap, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as getuint but signed - can&#x27;t use getuint</span></span><br><span class="line"><span class="comment">// because of sign extension</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span><span class="comment">//被调用，来解决诸如%d匹配参数的问题，隐性进行合法判定</span></span><br><span class="line">getint(va_list *ap, <span class="type">int</span> lflag)<span class="comment">//ap:1,3,4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (lflag &gt;= <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> va_arg(*ap, <span class="type">long</span> <span class="type">long</span>);<span class="comment">//ap:3,4</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (lflag)</span><br><span class="line">		<span class="keyword">return</span> va_arg(*ap, <span class="type">long</span>);<span class="comment">//ap:4</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> va_arg(*ap, <span class="type">int</span>);<span class="comment">//ap:null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化，并且调用putchar输出字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printfmt</span><span class="params">(<span class="type">void</span> (*putch)(<span class="type">int</span>, <span class="type">void</span>*), <span class="type">void</span> *putdat, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;<span class="comment">//参数：putch,&amp;cnt,fmt,ap</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vprintfmt</span><span class="params">(<span class="type">void</span> (*putch)(<span class="type">int</span>, <span class="type">void</span>*), <span class="type">void</span> *putdat, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> ch, err;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">	<span class="type">int</span> base, lflag, width, precision, altflag;</span><br><span class="line">	<span class="type">char</span> padc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//逐字符分析fmt：根据%后的字符决定参数，将ap参数逐步加入划分中，题例划分：&quot;x %d, y %x, z %d\n&quot;, 1, 3, 4 =&gt; &quot;x %d:1, y %x:2, z %d:3&quot; &quot;\n&quot;四个部分</span></span><br><span class="line">		<span class="keyword">while</span> ((ch = *(<span class="type">unsigned</span> <span class="type">char</span> *) fmt++) != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			putch(ch, putdat);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process a %-escape sequence</span></span><br><span class="line">		padc = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		width = <span class="number">-1</span>;</span><br><span class="line">		precision = <span class="number">-1</span>;</span><br><span class="line">		lflag = <span class="number">0</span>;</span><br><span class="line">		altflag = <span class="number">0</span>;</span><br><span class="line">	reswitch:</span><br><span class="line">		<span class="keyword">switch</span> (ch = *(<span class="type">unsigned</span> <span class="type">char</span> *) fmt++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// flag to pad on the right</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">			padc = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			<span class="keyword">goto</span> reswitch;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// flag to pad with 0&#x27;s instead of spaces</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">			padc = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">goto</span> reswitch;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// width field</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">			<span class="keyword">for</span> (precision = <span class="number">0</span>; ; ++fmt) &#123;</span><br><span class="line">				precision = precision * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				ch = *fmt;</span><br><span class="line">				<span class="keyword">if</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> process_precision;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">			precision = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">			<span class="keyword">goto</span> process_precision;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (width &lt; <span class="number">0</span>)</span><br><span class="line">				width = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">goto</span> reswitch;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">			altflag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> reswitch;</span><br><span class="line"></span><br><span class="line">		process_precision:</span><br><span class="line">			<span class="keyword">if</span> (width &lt; <span class="number">0</span>)</span><br><span class="line">				width = precision, precision = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">goto</span> reswitch;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// long flag (doubled for long long)</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">			lflag++;</span><br><span class="line">			<span class="keyword">goto</span> reswitch;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// character</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">			putch(va_arg(ap, <span class="type">int</span>), putdat);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// error message</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">			err = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				err = -err;</span><br><span class="line">			<span class="keyword">if</span> (err &gt;= MAXERROR || (p = error_string[err]) == <span class="literal">NULL</span>)</span><br><span class="line">				printfmt(putch, putdat, <span class="string">&quot;error %d&quot;</span>, err);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				printfmt(putch, putdat, <span class="string">&quot;%s&quot;</span>, p);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// string</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> ((p = va_arg(ap, <span class="type">char</span> *)) == <span class="literal">NULL</span>)</span><br><span class="line">				p = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span> (width &gt; <span class="number">0</span> &amp;&amp; padc != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">				<span class="keyword">for</span> (width -= strnlen(p, precision); width &gt; <span class="number">0</span>; width--)</span><br><span class="line">					putch(padc, putdat);</span><br><span class="line">			<span class="keyword">for</span> (; (ch = *p++) != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; (precision &lt; <span class="number">0</span> || --precision &gt;= <span class="number">0</span>); width--)</span><br><span class="line">				<span class="keyword">if</span> (altflag &amp;&amp; (ch &lt; <span class="string">&#x27; &#x27;</span> || ch &gt; <span class="string">&#x27;~&#x27;</span>))</span><br><span class="line">					putch(<span class="string">&#x27;?&#x27;</span>, putdat);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					putch(ch, putdat);</span><br><span class="line">			<span class="keyword">for</span> (; width &gt; <span class="number">0</span>; width--)</span><br><span class="line">				putch(<span class="string">&#x27; &#x27;</span>, putdat);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (signed) decimal</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">			num = getint(&amp;ap, lflag);</span><br><span class="line">			<span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>) num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				putch(<span class="string">&#x27;-&#x27;</span>, putdat);</span><br><span class="line">				num = -(<span class="type">long</span> <span class="type">long</span>) num;</span><br><span class="line">			&#125;</span><br><span class="line">			base = <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">goto</span> number;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// unsigned decimal</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">			num = getuint(&amp;ap, lflag);</span><br><span class="line">			base = <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">goto</span> number;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (unsigned) octal</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">			<span class="comment">// Replace this with your code.</span></span><br><span class="line">			putch(<span class="string">&#x27;X&#x27;</span>, putdat);</span><br><span class="line">			putch(<span class="string">&#x27;X&#x27;</span>, putdat);</span><br><span class="line">			putch(<span class="string">&#x27;X&#x27;</span>, putdat);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// pointer</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">			putch(<span class="string">&#x27;0&#x27;</span>, putdat);</span><br><span class="line">			putch(<span class="string">&#x27;x&#x27;</span>, putdat);</span><br><span class="line">			num = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)</span><br><span class="line">				(<span class="type">uintptr_t</span>) va_arg(ap, <span class="type">void</span> *);</span><br><span class="line">			base = <span class="number">16</span>;</span><br><span class="line">			<span class="keyword">goto</span> number;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (unsigned) hexadecimal</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">			num = getuint(&amp;ap, lflag);</span><br><span class="line">			base = <span class="number">16</span>;</span><br><span class="line">		number:</span><br><span class="line">			printnum(putch, putdat, num, base, width, padc);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// escaped &#x27;%&#x27; character</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">			putch(ch, putdat);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// unrecognized escape sequence - just print it literally</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			putch(<span class="string">&#x27;%&#x27;</span>, putdat);</span><br><span class="line">			<span class="keyword">for</span> (fmt--; fmt[<span class="number">-1</span>] != <span class="string">&#x27;%&#x27;</span>; fmt--)</span><br><span class="line">				<span class="comment">/* do nothing */</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printfmt</span><span class="params">(<span class="type">void</span> (*putch)(<span class="type">int</span>, <span class="type">void</span>*), <span class="type">void</span> *putdat, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line"></span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	vprintfmt(putch, putdat, fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sprintbuf</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">char</span> *ebuf;</span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sprintputch</span><span class="params">(<span class="type">int</span> ch, <span class="keyword">struct</span> sprintbuf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	b-&gt;cnt++;</span><br><span class="line">	<span class="keyword">if</span> (b-&gt;buf &lt; b-&gt;ebuf)</span><br><span class="line">		*b-&gt;buf++ = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sprintbuf</span> <span class="title">b</span> =</span> &#123;buf, buf+n<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buf == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print the string to the buffer</span></span><br><span class="line">	vprintfmt((<span class="type">void</span>*)sprintputch, &amp;b, fmt, ap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// null terminate the buffer</span></span><br><span class="line">	*b.buf = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	rc = vsnprintf(buf, n, fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Kern-x2F-console-c"><a href="#Kern-x2F-console-c" class="headerlink" title="Kern&#x2F;console.c"></a>Kern&#x2F;console.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"><span class="comment">//控制台的IO处理逻辑：I，O，控制台</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/kbdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/console.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cons_intr</span><span class="params">(<span class="type">int</span> (*proc)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cons_putc</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PC设计历史原因，只是单纯的IO等待</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">delay</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	inb(<span class="number">0x84</span>);</span><br><span class="line">	inb(<span class="number">0x84</span>);</span><br><span class="line">	inb(<span class="number">0x84</span>);</span><br><span class="line">	inb(<span class="number">0x84</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***** IO代码 *****/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM1		0x3F8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_RX		0	<span class="comment">// In:	Receive buffer (DLAB=0)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_TX		0	<span class="comment">// Out: Transmit buffer (DLAB=0)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_DLL		0	<span class="comment">// Out: Divisor Latch Low (DLAB=1)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_DLM		1	<span class="comment">// Out: Divisor Latch High (DLAB=1)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_IER		1	<span class="comment">// Out: Interrupt Enable Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_IER_RDI	0x01	<span class="comment">//   Enable receiver data interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_IIR		2	<span class="comment">// In:	Interrupt ID Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_FCR		2	<span class="comment">// Out: FIFO Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_LCR		3	<span class="comment">// Out: Line Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	  COM_LCR_DLAB	0x80	<span class="comment">//   Divisor latch access bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	  COM_LCR_WLEN8	0x03	<span class="comment">//   Wordlength: 8 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_MCR		4	<span class="comment">// Out: Modem Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	  COM_MCR_RTS	0x02	<span class="comment">// RTS complement</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	  COM_MCR_DTR	0x01	<span class="comment">// DTR complement</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	  COM_MCR_OUT2	0x08	<span class="comment">// Out2 complement</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_LSR		5	<span class="comment">// In:	Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_LSR_DATA	0x01	<span class="comment">//   Data available</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_LSR_TXRDY	0x20	<span class="comment">//   Transmit buffer avail</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_LSR_TSRE	0x40	<span class="comment">//   Transmitter off</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> serial_exists;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">serial_proc_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(inb(COM1+COM_LSR) &amp; COM_LSR_DATA))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> inb(COM1+COM_RX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serial_intr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (serial_exists)</span><br><span class="line">		cons_intr(serial_proc_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">serial_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">	     !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;</span><br><span class="line">	     i++)</span><br><span class="line">		delay();</span><br><span class="line"></span><br><span class="line">	outb(COM1 + COM_TX, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">serial_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Turn off the FIFO</span></span><br><span class="line">	outb(COM1+COM_FCR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set speed; requires DLAB latch</span></span><br><span class="line">	outb(COM1+COM_LCR, COM_LCR_DLAB);</span><br><span class="line">	outb(COM1+COM_DLL, (<span class="type">uint8_t</span>) (<span class="number">115200</span> / <span class="number">9600</span>));</span><br><span class="line">	outb(COM1+COM_DLM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 8 data bits, 1 stop bit, parity off; turn off DLAB latch</span></span><br><span class="line">	outb(COM1+COM_LCR, COM_LCR_WLEN8 &amp; ~COM_LCR_DLAB);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No modem controls</span></span><br><span class="line">	outb(COM1+COM_MCR, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// Enable rcv interrupts</span></span><br><span class="line">	outb(COM1+COM_IER, COM_IER_RDI);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear any preexisting overrun indications and interrupts</span></span><br><span class="line">	<span class="comment">// Serial port doesn&#x27;t exist if COM_LSR returns 0xFF</span></span><br><span class="line">	serial_exists = (inb(COM1+COM_LSR) != <span class="number">0xFF</span>);</span><br><span class="line">	(<span class="type">void</span>) inb(COM1+COM_IIR);</span><br><span class="line">	(<span class="type">void</span>) inb(COM1+COM_RX);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 并行端口输出代码 *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lpt_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)</span><br><span class="line">		delay();</span><br><span class="line">	outb(<span class="number">0x378</span>+<span class="number">0</span>, c);</span><br><span class="line">	outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);</span><br><span class="line">	outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 以文字形式向 CGA/VGA 显示输出 *****/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> addr_6845;</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> *crt_buf;</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> crt_pos;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">cga_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">uint16_t</span> *cp;</span><br><span class="line">	<span class="type">uint16_t</span> was;</span><br><span class="line">	<span class="type">unsigned</span> pos;</span><br><span class="line"></span><br><span class="line">	cp = (<span class="type">uint16_t</span>*) (KERNBASE + CGA_BUF);</span><br><span class="line">	was = *cp;</span><br><span class="line">	*cp = (<span class="type">uint16_t</span>) <span class="number">0xA55A</span>;</span><br><span class="line">	<span class="keyword">if</span> (*cp != <span class="number">0xA55A</span>) &#123;</span><br><span class="line">		cp = (<span class="type">uint16_t</span>*) (KERNBASE + MONO_BUF);</span><br><span class="line">		addr_6845 = MONO_BASE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*cp = was;</span><br><span class="line">		addr_6845 = CGA_BASE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extract cursor location */</span></span><br><span class="line">	outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">	pos = inb(addr_6845 + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">	pos |= inb(addr_6845 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	crt_buf = (<span class="type">uint16_t</span>*) cp;</span><br><span class="line">	crt_pos = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">cga_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">	<span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</span><br><span class="line">		c |= <span class="number">0x0700</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			crt_pos--;</span><br><span class="line">			crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">		crt_pos += CRT_COLS;</span><br><span class="line">		<span class="comment">/* fallthru */</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">		crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">		cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		crt_buf[crt_pos++] = c;		<span class="comment">/* write the character */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// What is the purpose of this?</span></span><br><span class="line">	<span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">		<span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">			crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		crt_pos -= CRT_COLS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* move that little blinky thing */</span></span><br><span class="line">	outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">	outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">	outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 键盘输入处理 *****/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO		0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHIFT		(1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL		(1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALT		(1&lt;&lt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAPSLOCK	(1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMLOCK		(1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCROLLLOCK	(1&lt;&lt;5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E0ESC		(1&lt;&lt;6)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> shiftcode[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	[<span class="number">0x1D</span>] = CTL,</span><br><span class="line">	[<span class="number">0x2A</span>] = SHIFT,</span><br><span class="line">	[<span class="number">0x36</span>] = SHIFT,</span><br><span class="line">	[<span class="number">0x38</span>] = ALT,</span><br><span class="line">	[<span class="number">0x9D</span>] = CTL,</span><br><span class="line">	[<span class="number">0xB8</span>] = ALT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> togglecode[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	[<span class="number">0x3A</span>] = CAPSLOCK,</span><br><span class="line">	[<span class="number">0x45</span>] = NUMLOCK,</span><br><span class="line">	[<span class="number">0x46</span>] = SCROLLLOCK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> normalmap[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	NO,   <span class="number">0x1B</span>, <span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;2&#x27;</span>,  <span class="string">&#x27;3&#x27;</span>,  <span class="string">&#x27;4&#x27;</span>,  <span class="string">&#x27;5&#x27;</span>,  <span class="string">&#x27;6&#x27;</span>,	<span class="comment">// 0x00</span></span><br><span class="line">	<span class="string">&#x27;7&#x27;</span>,  <span class="string">&#x27;8&#x27;</span>,  <span class="string">&#x27;9&#x27;</span>,  <span class="string">&#x27;0&#x27;</span>,  <span class="string">&#x27;-&#x27;</span>,  <span class="string">&#x27;=&#x27;</span>,  <span class="string">&#x27;\b&#x27;</span>, <span class="string">&#x27;\t&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;q&#x27;</span>,  <span class="string">&#x27;w&#x27;</span>,  <span class="string">&#x27;e&#x27;</span>,  <span class="string">&#x27;r&#x27;</span>,  <span class="string">&#x27;t&#x27;</span>,  <span class="string">&#x27;y&#x27;</span>,  <span class="string">&#x27;u&#x27;</span>,  <span class="string">&#x27;i&#x27;</span>,	<span class="comment">// 0x10</span></span><br><span class="line">	<span class="string">&#x27;o&#x27;</span>,  <span class="string">&#x27;p&#x27;</span>,  <span class="string">&#x27;[&#x27;</span>,  <span class="string">&#x27;]&#x27;</span>,  <span class="string">&#x27;\n&#x27;</span>, NO,   <span class="string">&#x27;a&#x27;</span>,  <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;d&#x27;</span>,  <span class="string">&#x27;f&#x27;</span>,  <span class="string">&#x27;g&#x27;</span>,  <span class="string">&#x27;h&#x27;</span>,  <span class="string">&#x27;j&#x27;</span>,  <span class="string">&#x27;k&#x27;</span>,  <span class="string">&#x27;l&#x27;</span>,  <span class="string">&#x27;;&#x27;</span>,	<span class="comment">// 0x20</span></span><br><span class="line">	<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;`&#x27;</span>,  NO,   <span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;z&#x27;</span>,  <span class="string">&#x27;x&#x27;</span>,  <span class="string">&#x27;c&#x27;</span>,  <span class="string">&#x27;v&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;b&#x27;</span>,  <span class="string">&#x27;n&#x27;</span>,  <span class="string">&#x27;m&#x27;</span>,  <span class="string">&#x27;,&#x27;</span>,  <span class="string">&#x27;.&#x27;</span>,  <span class="string">&#x27;/&#x27;</span>,  NO,   <span class="string">&#x27;*&#x27;</span>,	<span class="comment">// 0x30</span></span><br><span class="line">	NO,   <span class="string">&#x27; &#x27;</span>,  NO,   NO,   NO,   NO,   NO,   NO,</span><br><span class="line">	NO,   NO,   NO,   NO,   NO,   NO,   NO,   <span class="string">&#x27;7&#x27;</span>,	<span class="comment">// 0x40</span></span><br><span class="line">	<span class="string">&#x27;8&#x27;</span>,  <span class="string">&#x27;9&#x27;</span>,  <span class="string">&#x27;-&#x27;</span>,  <span class="string">&#x27;4&#x27;</span>,  <span class="string">&#x27;5&#x27;</span>,  <span class="string">&#x27;6&#x27;</span>,  <span class="string">&#x27;+&#x27;</span>,  <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;2&#x27;</span>,  <span class="string">&#x27;3&#x27;</span>,  <span class="string">&#x27;0&#x27;</span>,  <span class="string">&#x27;.&#x27;</span>,  NO,   NO,   NO,   NO,	<span class="comment">// 0x50</span></span><br><span class="line">	[<span class="number">0xC7</span>] = KEY_HOME,	      [<span class="number">0x9C</span>] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">/*KP_Enter*/</span>,</span><br><span class="line">	[<span class="number">0xB5</span>] = <span class="string">&#x27;/&#x27;</span> <span class="comment">/*KP_Div*/</span>,      [<span class="number">0xC8</span>] = KEY_UP,</span><br><span class="line">	[<span class="number">0xC9</span>] = KEY_PGUP,	      [<span class="number">0xCB</span>] = KEY_LF,</span><br><span class="line">	[<span class="number">0xCD</span>] = KEY_RT,	      [<span class="number">0xCF</span>] = KEY_END,</span><br><span class="line">	[<span class="number">0xD0</span>] = KEY_DN,	      [<span class="number">0xD1</span>] = KEY_PGDN,</span><br><span class="line">	[<span class="number">0xD2</span>] = KEY_INS,	      [<span class="number">0xD3</span>] = KEY_DEL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> shiftmap[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	NO,   <span class="number">033</span>,  <span class="string">&#x27;!&#x27;</span>,  <span class="string">&#x27;@&#x27;</span>,  <span class="string">&#x27;#&#x27;</span>,  <span class="string">&#x27;$&#x27;</span>,  <span class="string">&#x27;%&#x27;</span>,  <span class="string">&#x27;^&#x27;</span>,	<span class="comment">// 0x00</span></span><br><span class="line">	<span class="string">&#x27;&amp;&#x27;</span>,  <span class="string">&#x27;*&#x27;</span>,  <span class="string">&#x27;(&#x27;</span>,  <span class="string">&#x27;)&#x27;</span>,  <span class="string">&#x27;_&#x27;</span>,  <span class="string">&#x27;+&#x27;</span>,  <span class="string">&#x27;\b&#x27;</span>, <span class="string">&#x27;\t&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;Q&#x27;</span>,  <span class="string">&#x27;W&#x27;</span>,  <span class="string">&#x27;E&#x27;</span>,  <span class="string">&#x27;R&#x27;</span>,  <span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;Y&#x27;</span>,  <span class="string">&#x27;U&#x27;</span>,  <span class="string">&#x27;I&#x27;</span>,	<span class="comment">// 0x10</span></span><br><span class="line">	<span class="string">&#x27;O&#x27;</span>,  <span class="string">&#x27;P&#x27;</span>,  <span class="string">&#x27;&#123;&#x27;</span>,  <span class="string">&#x27;&#125;&#x27;</span>,  <span class="string">&#x27;\n&#x27;</span>, NO,   <span class="string">&#x27;A&#x27;</span>,  <span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;D&#x27;</span>,  <span class="string">&#x27;F&#x27;</span>,  <span class="string">&#x27;G&#x27;</span>,  <span class="string">&#x27;H&#x27;</span>,  <span class="string">&#x27;J&#x27;</span>,  <span class="string">&#x27;K&#x27;</span>,  <span class="string">&#x27;L&#x27;</span>,  <span class="string">&#x27;:&#x27;</span>,	<span class="comment">// 0x20</span></span><br><span class="line">	<span class="string">&#x27;&quot;&#x27;</span>,  <span class="string">&#x27;~&#x27;</span>,  NO,   <span class="string">&#x27;|&#x27;</span>,  <span class="string">&#x27;Z&#x27;</span>,  <span class="string">&#x27;X&#x27;</span>,  <span class="string">&#x27;C&#x27;</span>,  <span class="string">&#x27;V&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;B&#x27;</span>,  <span class="string">&#x27;N&#x27;</span>,  <span class="string">&#x27;M&#x27;</span>,  <span class="string">&#x27;&lt;&#x27;</span>,  <span class="string">&#x27;&gt;&#x27;</span>,  <span class="string">&#x27;?&#x27;</span>,  NO,   <span class="string">&#x27;*&#x27;</span>,	<span class="comment">// 0x30</span></span><br><span class="line">	NO,   <span class="string">&#x27; &#x27;</span>,  NO,   NO,   NO,   NO,   NO,   NO,</span><br><span class="line">	NO,   NO,   NO,   NO,   NO,   NO,   NO,   <span class="string">&#x27;7&#x27;</span>,	<span class="comment">// 0x40</span></span><br><span class="line">	<span class="string">&#x27;8&#x27;</span>,  <span class="string">&#x27;9&#x27;</span>,  <span class="string">&#x27;-&#x27;</span>,  <span class="string">&#x27;4&#x27;</span>,  <span class="string">&#x27;5&#x27;</span>,  <span class="string">&#x27;6&#x27;</span>,  <span class="string">&#x27;+&#x27;</span>,  <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;2&#x27;</span>,  <span class="string">&#x27;3&#x27;</span>,  <span class="string">&#x27;0&#x27;</span>,  <span class="string">&#x27;.&#x27;</span>,  NO,   NO,   NO,   NO,	<span class="comment">// 0x50</span></span><br><span class="line">	[<span class="number">0xC7</span>] = KEY_HOME,	      [<span class="number">0x9C</span>] = <span class="string">&#x27;\n&#x27;</span> <span class="comment">/*KP_Enter*/</span>,</span><br><span class="line">	[<span class="number">0xB5</span>] = <span class="string">&#x27;/&#x27;</span> <span class="comment">/*KP_Div*/</span>,      [<span class="number">0xC8</span>] = KEY_UP,</span><br><span class="line">	[<span class="number">0xC9</span>] = KEY_PGUP,	      [<span class="number">0xCB</span>] = KEY_LF,</span><br><span class="line">	[<span class="number">0xCD</span>] = KEY_RT,	      [<span class="number">0xCF</span>] = KEY_END,</span><br><span class="line">	[<span class="number">0xD0</span>] = KEY_DN,	      [<span class="number">0xD1</span>] = KEY_PGDN,</span><br><span class="line">	[<span class="number">0xD2</span>] = KEY_INS,	      [<span class="number">0xD3</span>] = KEY_DEL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C(x) (x - <span class="string">&#x27;@&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> ctlmap[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,</span><br><span class="line">	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,</span><br><span class="line">	C(<span class="string">&#x27;Q&#x27;</span>),  C(<span class="string">&#x27;W&#x27;</span>),  C(<span class="string">&#x27;E&#x27;</span>),  C(<span class="string">&#x27;R&#x27;</span>),  C(<span class="string">&#x27;T&#x27;</span>),  C(<span class="string">&#x27;Y&#x27;</span>),  C(<span class="string">&#x27;U&#x27;</span>),  C(<span class="string">&#x27;I&#x27;</span>),</span><br><span class="line">	C(<span class="string">&#x27;O&#x27;</span>),  C(<span class="string">&#x27;P&#x27;</span>),  NO,      NO,      <span class="string">&#x27;\r&#x27;</span>,    NO,      C(<span class="string">&#x27;A&#x27;</span>),  C(<span class="string">&#x27;S&#x27;</span>),</span><br><span class="line">	C(<span class="string">&#x27;D&#x27;</span>),  C(<span class="string">&#x27;F&#x27;</span>),  C(<span class="string">&#x27;G&#x27;</span>),  C(<span class="string">&#x27;H&#x27;</span>),  C(<span class="string">&#x27;J&#x27;</span>),  C(<span class="string">&#x27;K&#x27;</span>),  C(<span class="string">&#x27;L&#x27;</span>),  NO,</span><br><span class="line">	NO,      NO,      NO,      C(<span class="string">&#x27;\\&#x27;</span>), C(<span class="string">&#x27;Z&#x27;</span>),  C(<span class="string">&#x27;X&#x27;</span>),  C(<span class="string">&#x27;C&#x27;</span>),  C(<span class="string">&#x27;V&#x27;</span>),</span><br><span class="line">	C(<span class="string">&#x27;B&#x27;</span>),  C(<span class="string">&#x27;N&#x27;</span>),  C(<span class="string">&#x27;M&#x27;</span>),  NO,      NO,      C(<span class="string">&#x27;/&#x27;</span>),  NO,      NO,</span><br><span class="line">	[<span class="number">0x97</span>] = KEY_HOME,</span><br><span class="line">	[<span class="number">0xB5</span>] = C(<span class="string">&#x27;/&#x27;</span>),		[<span class="number">0xC8</span>] = KEY_UP,</span><br><span class="line">	[<span class="number">0xC9</span>] = KEY_PGUP,		[<span class="number">0xCB</span>] = KEY_LF,</span><br><span class="line">	[<span class="number">0xCD</span>] = KEY_RT,		[<span class="number">0xCF</span>] = KEY_END,</span><br><span class="line">	[<span class="number">0xD0</span>] = KEY_DN,		[<span class="number">0xD1</span>] = KEY_PGDN,</span><br><span class="line">	[<span class="number">0xD2</span>] = KEY_INS,		[<span class="number">0xD3</span>] = KEY_DEL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> *charcode[<span class="number">4</span>] = &#123;</span><br><span class="line">	normalmap,</span><br><span class="line">	shiftmap,</span><br><span class="line">	ctlmap,</span><br><span class="line">	ctlmap</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从键盘获取单个字符，如果成功，返回，如果没有，返回0.</span></span><br><span class="line"><span class="comment"> * 无数据返回-1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">kbd_proc_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">uint8_t</span> stat, data;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint32_t</span> shift;</span><br><span class="line"></span><br><span class="line">	stat = inb(KBSTATP);</span><br><span class="line">	<span class="keyword">if</span> ((stat &amp; KBS_DIB) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// Ignore data from mouse.</span></span><br><span class="line">	<span class="keyword">if</span> (stat &amp; KBS_TERR)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	data = inb(KBDATAP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="number">0xE0</span>) &#123;</span><br><span class="line">		<span class="comment">// E0 escape character</span></span><br><span class="line">		shift |= E0ESC;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">		<span class="comment">// Key released</span></span><br><span class="line">		data = (shift &amp; E0ESC ? data : data &amp; <span class="number">0x7F</span>);</span><br><span class="line">		shift &amp;= ~(shiftcode[data] | E0ESC);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift &amp; E0ESC) &#123;</span><br><span class="line">		<span class="comment">// Last character was an E0 escape; or with 0x80</span></span><br><span class="line">		data |= <span class="number">0x80</span>;</span><br><span class="line">		shift &amp;= ~E0ESC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shift |= shiftcode[data];</span><br><span class="line">	shift ^= togglecode[data];</span><br><span class="line"></span><br><span class="line">	c = charcode[shift &amp; (CTL | SHIFT)][data];</span><br><span class="line">	<span class="keyword">if</span> (shift &amp; CAPSLOCK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">			c += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">			c += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process special keys</span></span><br><span class="line">	<span class="comment">// Ctrl-Alt-Del: reboot</span></span><br><span class="line">	<span class="keyword">if</span> (!(~shift &amp; (CTL | ALT)) &amp;&amp; c == KEY_DEL) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;Rebooting!\n&quot;</span>);</span><br><span class="line">		outb(<span class="number">0x92</span>, <span class="number">0x3</span>); <span class="comment">// courtesy of Chris Frost</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kbd_intr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cons_intr(kbd_proc_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">kbd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 设备无关的控制台代码 *****/</span></span><br><span class="line"><span class="comment">// Here we manage the console input buffer,</span></span><br><span class="line"><span class="comment">// where we stash characters received from the keyboard or serial port</span></span><br><span class="line"><span class="comment">// whenever the corresponding interrupt occurs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSBUFSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> buf[CONSBUFSIZE];</span><br><span class="line">	<span class="type">uint32_t</span> rpos;</span><br><span class="line">	<span class="type">uint32_t</span> wpos;</span><br><span class="line">&#125; cons;</span><br><span class="line"></span><br><span class="line"><span class="comment">// called by device interrupt routines to feed input characters</span></span><br><span class="line"><span class="comment">// into the circular console input buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">cons_intr</span><span class="params">(<span class="type">int</span> (*proc)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = (*proc)()) != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		cons.buf[cons.wpos++] = c;</span><br><span class="line">		<span class="keyword">if</span> (cons.wpos == CONSBUFSIZE)</span><br><span class="line">			cons.wpos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the next input character from the console, or 0 if none waiting</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cons_getc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poll for any pending input characters,</span></span><br><span class="line">	<span class="comment">// so that this function works even when interrupts are disabled</span></span><br><span class="line">	<span class="comment">// (e.g., when called from the kernel monitor).</span></span><br><span class="line">	serial_intr();</span><br><span class="line">	kbd_intr();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// grab the next character from the input buffer.</span></span><br><span class="line">	<span class="keyword">if</span> (cons.rpos != cons.wpos) &#123;</span><br><span class="line">		c = cons.buf[cons.rpos++];</span><br><span class="line">		<span class="keyword">if</span> (cons.rpos == CONSBUFSIZE)</span><br><span class="line">			cons.rpos = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output a character to the console</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">cons_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	serial_putc(c);</span><br><span class="line">	lpt_putc(c);</span><br><span class="line">	cga_putc(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize the console devices</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cons_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cga_init();</span><br><span class="line">	kbd_init();</span><br><span class="line">	serial_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!serial_exists)</span><br><span class="line">		cprintf(<span class="string">&quot;Serial port does not exist!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// `High&#x27;-level console I/O.  Used by readline and cprintf.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cputchar</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	cons_putc(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = cons_getc()) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">iscons</span><span class="params">(<span class="type">int</span> fdnum)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// used by readline</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="kern-x2F-kdebug-c"><a href="#kern-x2F-kdebug-c" class="headerlink" title="kern&#x2F;kdebug.c"></a>kern&#x2F;kdebug.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/stab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/kdebug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> __<span class="title">STAB_BEGIN__</span>[];</span>	<span class="comment">// Beginning of stabs table</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> __<span class="title">STAB_END__</span>[];</span>	<span class="comment">// End of stabs table</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> __STABSTR_BEGIN__[];		<span class="comment">// Beginning of string table</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> __STABSTR_END__[];		<span class="comment">// End of string table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stab是一个增序的指令数组，包含了大量关于代码执行的诸如起始地址，函数名，等我们需要的信息，因此info需要stab数组来填充</span></span><br><span class="line"><span class="comment">//1.stab_binsearch(stabs, region_left, region_right, type, addr)二分搜索指令地址，查找指定代码地址信息</span></span><br><span class="line"><span class="comment">//	给以下例子，</span></span><br><span class="line"><span class="comment">//		Index  Type   Address</span></span><br><span class="line"><span class="comment">//		0      SO     f0100000</span></span><br><span class="line"><span class="comment">//		13     SO     f0100040</span></span><br><span class="line"><span class="comment">//		117    SO     f0100176</span></span><br><span class="line"><span class="comment">//		118    SO     f0100178</span></span><br><span class="line"><span class="comment">//		555    SO     f0100652</span></span><br><span class="line"><span class="comment">//		556    SO     f0100654</span></span><br><span class="line"><span class="comment">//		657    SO     f0100849</span></span><br><span class="line"><span class="comment">//	给定参数:</span></span><br><span class="line"><span class="comment">//		left = 0, right = 657;为左闭右闭边界</span></span><br><span class="line"><span class="comment">//		stab_binsearch(stabs, &amp;left, &amp;right, N_SO, 0xf0100184);</span></span><br><span class="line"><span class="comment">//	结果得到 left = 118, right = 554.，因此left是指令所在索引，right是下个指令索引，所以left&gt;right代表失败</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stab_binsearch</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> Stab *stabs, <span class="type">int</span> *region_left, <span class="type">int</span> *region_right,</span></span><br><span class="line"><span class="params">	       <span class="type">int</span> type, <span class="type">uintptr_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l = *region_left, r = *region_right, any_matches = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;<span class="comment">//l不同于*region_left</span></span><br><span class="line">		<span class="type">int</span> true_m = (l + r) / <span class="number">2</span>, m = true_m;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 过滤不正确的type节省时间，中间值向左偏移</span></span><br><span class="line">		<span class="keyword">while</span> (m &gt;= l &amp;&amp; stabs[m].n_type != type)</span><br><span class="line">			m--;</span><br><span class="line">		<span class="keyword">if</span> (m &lt; l) &#123;	<span class="comment">// no match in [l, m]</span></span><br><span class="line">			l = true_m + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实际的二分搜索代码</span></span><br><span class="line">		any_matches = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (stabs[m].n_value &lt; addr) &#123;</span><br><span class="line">			*region_left = m;</span><br><span class="line">			l = true_m + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stabs[m].n_value &gt; addr) &#123;</span><br><span class="line">			*region_right = m - <span class="number">1</span>;</span><br><span class="line">			r = m - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// exact match for &#x27;addr&#x27;, but continue loop to find</span></span><br><span class="line">			<span class="comment">// *region_right</span></span><br><span class="line">			*region_left = m;</span><br><span class="line">			l = m;</span><br><span class="line">			addr++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!any_matches)</span><br><span class="line">		*region_right = *region_left - <span class="number">1</span>;<span class="comment">//非法判定成立准备</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 由于符号表中存在地址相同的可能，所以排列情况下，我们要的就是最右的那个</span></span><br><span class="line">		<span class="keyword">for</span> (l = *region_right;</span><br><span class="line">		     l &gt; *region_left &amp;&amp; stabs[l].n_type != type;</span><br><span class="line">		     l--)</span><br><span class="line">			<span class="comment">/* do nothing */</span>;</span><br><span class="line">		*region_left = l;<span class="comment">//赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.debuginfo_eip调用二分搜索来填充info，成功返回0，失败返回-1，但是失败的时候，info可能也填充了一部分</span></span><br><span class="line"><span class="comment">// debuginfo_eip(addr, info)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	Fill in the &#x27;info&#x27; structure with information about the specified</span></span><br><span class="line"><span class="comment">//	instruction address, &#x27;addr&#x27;.  Returns 0 if information was found, and</span></span><br><span class="line"><span class="comment">//	negative if not.  But even if it returns negative it has stored some</span></span><br><span class="line"><span class="comment">//	information into &#x27;*info&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">debuginfo_eip</span><span class="params">(<span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Eipdebuginfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> *<span class="title">stabs</span>, *<span class="title">stab_end</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *stabstr, *stabstr_end;</span><br><span class="line">	<span class="type">int</span> lfile, rfile, lfun, rfun, lline, rline;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize *info</span></span><br><span class="line">	info-&gt;eip_file = <span class="string">&quot;&lt;unknown&gt;&quot;</span>;</span><br><span class="line">	info-&gt;eip_line = <span class="number">0</span>;</span><br><span class="line">	info-&gt;eip_fn_name = <span class="string">&quot;&lt;unknown&gt;&quot;</span>;</span><br><span class="line">	info-&gt;eip_fn_namelen = <span class="number">9</span>;</span><br><span class="line">	info-&gt;eip_fn_addr = addr;</span><br><span class="line">	info-&gt;eip_fn_narg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the relevant set of stabs</span></span><br><span class="line">	<span class="keyword">if</span> (addr &gt;= ULIM) &#123;</span><br><span class="line">		stabs = __STAB_BEGIN__;</span><br><span class="line">		stab_end = __STAB_END__;</span><br><span class="line">		stabstr = __STABSTR_BEGIN__;</span><br><span class="line">		stabstr_end = __STABSTR_END__;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Can&#x27;t search for user-level addresses yet!</span></span><br><span class="line">  	        panic(<span class="string">&quot;User address&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// String table validity checks</span></span><br><span class="line">	<span class="keyword">if</span> (stabstr_end &lt;= stabstr || stabstr_end[<span class="number">-1</span>] != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we find the right stabs that define the function containing</span></span><br><span class="line">	<span class="comment">// &#x27;eip&#x27;.  First, we find the basic source file containing &#x27;eip&#x27;.</span></span><br><span class="line">	<span class="comment">// Then, we look in that source file for the function.  Then we look</span></span><br><span class="line">	<span class="comment">// for the line number.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search the entire set of stabs for the source file (type N_SO).</span></span><br><span class="line">	lfile = <span class="number">0</span>;</span><br><span class="line">	rfile = (stab_end - stabs) - <span class="number">1</span>;</span><br><span class="line">	stab_binsearch(stabs, &amp;lfile, &amp;rfile, N_SO, addr);</span><br><span class="line">	<span class="keyword">if</span> (lfile == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search within that file&#x27;s stabs for the function definition</span></span><br><span class="line">	<span class="comment">// (N_FUN).</span></span><br><span class="line">	lfun = lfile;</span><br><span class="line">	rfun = rfile;</span><br><span class="line">	stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_FUN, addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lfun &lt;= rfun) &#123;</span><br><span class="line">		<span class="comment">// stabs[lfun] points to the function name</span></span><br><span class="line">		<span class="comment">// in the string table, but check bounds just in case.</span></span><br><span class="line">		<span class="keyword">if</span> (stabs[lfun].n_strx &lt; stabstr_end - stabstr)</span><br><span class="line">			info-&gt;eip_fn_name = stabstr + stabs[lfun].n_strx;</span><br><span class="line">		info-&gt;eip_fn_addr = stabs[lfun].n_value;</span><br><span class="line">		addr -= info-&gt;eip_fn_addr;</span><br><span class="line">		<span class="comment">// Search within the function definition for the line number.</span></span><br><span class="line">		lline = lfun;</span><br><span class="line">		rline = rfun;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Couldn&#x27;t find function stab!  Maybe we&#x27;re in an assembly</span></span><br><span class="line">		<span class="comment">// file.  Search the whole file for the line number.</span></span><br><span class="line">		info-&gt;eip_fn_addr = addr;</span><br><span class="line">		lline = lfile;</span><br><span class="line">		rline = rfile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Ignore stuff after the colon.</span></span><br><span class="line">	info-&gt;eip_fn_namelen = strfind(info-&gt;eip_fn_name, <span class="string">&#x27;:&#x27;</span>) - info-&gt;eip_fn_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给定边界[lline, rline] </span></span><br><span class="line">	<span class="comment">// 找到之后， info-&gt;eip_line 赋值为rline代码块的行数</span></span><br><span class="line">	<span class="comment">// 失败返回-1</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//	对于代码行数，stab已经有特定的字段保存，你只要给addr参数即可，不需要再计算</span></span><br><span class="line">	<span class="comment">//	从&lt;inc/stab.h&gt;找stab定义</span></span><br><span class="line">	<span class="comment">// 我的代码</span></span><br><span class="line">	stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);<span class="comment">//代码行数</span></span><br><span class="line">	<span class="keyword">if</span> (lline &lt;= rline) &#123;</span><br><span class="line">    	info-&gt;eip_line = stabs[rline].n_desc;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 	   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search backwards from the line number for the relevant filename</span></span><br><span class="line">	<span class="comment">// stab.</span></span><br><span class="line">	<span class="comment">// We can&#x27;t just use the &quot;lfile&quot; stab because inlined functions</span></span><br><span class="line">	<span class="comment">// can interpolate code from a different file!</span></span><br><span class="line">	<span class="comment">// Such included source files use the N_SOL stab type.</span></span><br><span class="line">	<span class="keyword">while</span> (lline &gt;= lfile</span><br><span class="line">	       &amp;&amp; stabs[lline].n_type != N_SOL</span><br><span class="line">	       &amp;&amp; (stabs[lline].n_type != N_SO || !stabs[lline].n_value))</span><br><span class="line">		lline--;</span><br><span class="line">	<span class="keyword">if</span> (lline &gt;= lfile &amp;&amp; stabs[lline].n_strx &lt; stabstr_end - stabstr)</span><br><span class="line">		info-&gt;eip_file = stabstr + stabs[lline].n_strx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set eip_fn_narg to the number of arguments taken by the function,</span></span><br><span class="line">	<span class="comment">// or 0 if there was no containing function.</span></span><br><span class="line">	<span class="keyword">if</span> (lfun &lt; rfun)</span><br><span class="line">		<span class="keyword">for</span> (lline = lfun + <span class="number">1</span>;</span><br><span class="line">		     lline &lt; rfun &amp;&amp; stabs[lline].n_type == N_PSYM;</span><br><span class="line">		     lline++)</span><br><span class="line">			info-&gt;eip_fn_narg++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb可视化</title>
    <url>/2024/03/08/gdb%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><ul>
<li>PIP Package (Python Wheel)</li>
</ul>
<p>You can install it from PyPi repository.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 -m pip install gdbfrontend</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li>Arch Linux (AUR)****</li>
</ul>
<p>You can install Arch Linux package for Arch-based distributions. (<a href="https://aur.archlinux.org/packages/gdb-frontend-bin/">AUR Package</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ yay -S gdb-frontend-bin</span><br></pre></td></tr></table></figure>

<ul>
<li>GIT (Latest GIT Snapshot)</li>
</ul>
<p>You can download GDBFrontend from latest GIT snapshot.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/rohanrhu/gdb-frontend.git</span><br><span class="line">$ cd gdb-frontend</span><br><span class="line">$ ./gdbfrontend</span><br></pre></td></tr></table></figure>

<h1 id="更新vimrc（可跳过）"><a href="#更新vimrc（可跳过）" class="headerlink" title="更新vimrc（可跳过）"></a>更新vimrc（可跳过）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.进入配置</span></span><br><span class="line">vi ~/.vimrc</span><br><span class="line"><span class="comment">#2.编写脚本:命令行模式:gdb来编译，调用gdbfrontend</span></span><br><span class="line">func GDB()</span><br><span class="line">	let ffileName = bufname(<span class="string">&quot;%&quot;</span>)</span><br><span class="line">	let fileName = strpart(ffileName, <span class="number">0</span>, strridx(ffileName, <span class="string">&quot;.&quot;</span>))</span><br><span class="line">	let curDir = getcwd()</span><br><span class="line">	exe <span class="string">&quot;!clear &amp;&amp; g++ -std=c++11 % -g -o&quot;</span> fileName </span><br><span class="line">	exe <span class="string">&quot;!clear &amp;&amp; gdbfrontend -G&quot;</span> curDir.<span class="string">&quot;/&quot;</span>.fileName </span><br><span class="line">endfunc</span><br><span class="line">cmap gdb call GDB()&lt;cr&gt;</span><br><span class="line"><span class="comment">#3.更新配置</span></span><br><span class="line">:source $MYVIMRC </span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.测试文件</span></span><br><span class="line">vi test.cpp</span><br><span class="line"><span class="comment">#2.something dumb</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">#3.测试</span></span><br><span class="line">  <span class="comment">#如果有自定义函数</span></span><br><span class="line">:gdb</span><br><span class="line">  <span class="comment">#如果没有进入shell运行, &lt;PATH&gt;代表你的文件绝对路径</span></span><br><span class="line">$ gdbfrontend -G &lt;PATH&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202203221242973.png"></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT-6.828实验通关记录</title>
    <url>/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="如何入手本实验？"><a href="#如何入手本实验？" class="headerlink" title="如何入手本实验？"></a>如何入手本实验？</h1><p><strong>小白推荐阅读顺序</strong>  </p>
<ol>
<li><p>mit6.828实验总览  </p>
</li>
<li><p>各个lab的课堂笔记和材料 </p>
</li>
<li><p>各个lab的实验笔记</p>
</li>
</ol>
<span id="more"></span>
<p><strong>笔记的构成</strong>  </p>
<ol>
<li>英文笔记的相当部分的总结翻译和图</li>
<li>基本工具使用和所需部分知识补充</li>
<li>实验流程的shortcut而不是过分详细的讲解  </li>
<li>主题下和延伸的问题与回答</li>
<li>实验结尾的总结</li>
</ol>
<p><strong>阅读建议</strong></p>
<p>考虑到每个lab都非常长，所以我进行了分块书写，尽可能保证简洁和清晰，你可以使用以下方式增加阅读体验</p>
<ol>
<li>确定你要看的部分：是实验笔记还是实验资料？是工具使用还是源代码？</li>
<li>善用文字匹配&#x2F;大纲搜索定位</li>
<li>使用草稿纸作为buf，方便上下切换查阅不忘记</li>
</ol>
<p><strong>参考书本</strong>  </p>
<p>由于语言问题，讲解的时候并不一定很容易理解，所以需要你自己查阅一些资料加以补充和理解。给出本人的参考书籍：  </p>
<p>《程序员的自我修养》  </p>
<p>《深入理解计算机系统》  </p>
<p>《unix操作系统设计》  </p>
<h1 id="官方资源整理"><a href="#官方资源整理" class="headerlink" title="官方资源整理"></a>官方资源整理</h1><a href="/2021/11/29/mit-6-828-overview/" title="mit-6.828_overview">mit-6.828_overview</a>

<h1 id="本人笔记资料整理"><a href="#本人笔记资料整理" class="headerlink" title="本人笔记资料整理"></a>本人笔记资料整理</h1><h2 id="Lab1-C，汇编，工具和引导"><a href="#Lab1-C，汇编，工具和引导" class="headerlink" title="Lab1: C，汇编，工具和引导"></a>Lab1: C，汇编，工具和引导</h2><ul>
<li>资料</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" title="基本工具使用">基本工具使用</a>  &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L1%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" title="L1：操作系统概论">L1：操作系统概论</a>  &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L2%EF%BC%9Ax86%E5%92%8CPC%E6%9E%B6%E6%9E%84/" title="L2：x86和PC架构">L2：x86和PC架构</a>  &#x2F;</p>
<ul>
<li>实验</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE/" title="工具链配置">工具链配置</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/lab1/" title="实验1：汇编，工具和引导">实验1：汇编，工具和引导</a>   &#x2F;</p>
<h2 id="Lab2-内存管理"><a href="#Lab2-内存管理" class="headerlink" title="Lab2: 内存管理"></a>Lab2: 内存管理</h2><ul>
<li>资料</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/L4%EF%BC%9Ashell&os/" title="L4：shell和os">L4：shell和os</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L4homework%EF%BC%9Ashell/" title="L4 homework：shell">L4 homework：shell</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L5%EF%BC%9A%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/" title="L5：隔离机制">L5：隔离机制</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L6%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="L6：虚拟内存">L6：虚拟内存</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L7%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" title="L7:使用虚拟内存">L7:使用虚拟内存</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/JOS%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" title="JOS虚拟内存布局">JOS虚拟内存布局</a>   &#x2F;</p>
<ul>
<li>实验</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/lab2/" title="实验 2：内存管理">实验 2：内存管理</a>   &#x2F;</p>
<h2 id="Lab3-用户级别环境"><a href="#Lab3-用户级别环境" class="headerlink" title="Lab3: 用户级别环境"></a>Lab3: 用户级别环境</h2><ul>
<li>资料</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/L8%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/" title="L8 ：系统调用、中断和异常">L8 ：系统调用、中断和异常</a>   &#x2F; </p>
<ul>
<li>实验</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/lab3%EF%BC%9APartA/" title="lab3：用户环境(PartA)">lab3：用户环境(PartA)</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/lab3%EF%BC%9APartB/" title="lab3：PartB">lab3：PartB</a>   &#x2F;</p>
<h2 id="Lab4-进程调度"><a href="#Lab4-进程调度" class="headerlink" title="Lab4: 进程调度"></a>Lab4: 进程调度</h2><ul>
<li>资料</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/L9%EF%BC%9A%E9%94%81/" title="L9：锁">L9：锁</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L10%EF%BC%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6/" title="L10：进程，线程和调度">L10：进程，线程和调度</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L11%EF%BC%9A%E5%8D%8F%E8%B0%83%EF%BC%88sleep&wakeup%EF%BC%89/" title="L11 ：协调（sleep&amp;wakeup）">L11 ：协调（sleep&amp;wakeup）</a>   &#x2F;</p>
<ul>
<li>实验</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/lab4%EF%BC%9APartA/" title="lab4：抢占式多任务处理(PartA)">lab4：抢占式多任务处理(PartA)</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/lab4%EF%BC%9APartB/" title="lab4：PartB">lab4：PartB</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/lab4%EF%BC%9APartC/" title="lab4：PartC">lab4：PartC</a>   &#x2F;</p>
<h2 id="Lab5-文件系统，IO和shell"><a href="#Lab5-文件系统，IO和shell" class="headerlink" title="Lab5: 文件系统，IO和shell"></a>Lab5: 文件系统，IO和shell</h2><ul>
<li>资料</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/L12%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="L12：文件系统">L12：文件系统</a>   &#x2F;   </p>
<p>&#x2F;  <a href="/2024/03/08/L13%EF%BC%9A%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/" title="L13：崩溃恢复，日志记录">L13：崩溃恢复，日志记录</a>   &#x2F;</p>
<p>&#x2F;  <a href="/2024/03/08/L14%EF%BC%9ALinux_ext3_%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D/" title="L14：Linux_ext3_崩溃恢复">L14：Linux_ext3_崩溃恢复</a>   &#x2F;</p>
<ul>
<li>实验</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/lab5/" title="实验 5：文件系统、Spawn 和 Shell">实验 5：文件系统、Spawn 和 Shell</a>   &#x2F;</p>
<h2 id="Lab6-网络"><a href="#Lab6-网络" class="headerlink" title="Lab6: 网络"></a>Lab6: 网络</h2><ul>
<li>实验</li>
</ul>
<p>&#x2F;  <a href="/2024/03/08/lab6/" title="实验 6：网络">实验 6：网络</a>   &#x2F;</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统调用</title>
    <url>/2024/03/08/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><p>1.攻克linux L10&#x2F;L11&#x2F;L7&#x2F;L8&#x2F;L16&#x2F;L17&#x2F;L18&#x2F;L19</p>
<p>2.L8信号量的没看懂</p>
<p>3.L13内存锁定和保护</p>
<p>4.不太明白：I&#x2F;O复用不熟悉，内存高级应用，信号量高级应用，进程优先级，</p>
<p>快速回忆系统调用和一些零碎的shell命令</p>
<span id="more"></span>

<h1 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112082154292.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112082155386.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112082155001.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112082155572.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112082156099.png"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p>int lseek(int fd, off_t offset, int whence);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lseek(fd,10*sizeof(int),SEEK_SET);//注意大小是字节</span><br><span class="line">//我们的offset指针被文件保存，下方的操作都是按照隐藏的指针来读写</span><br></pre></td></tr></table></figure>

<p>int open(char *pathname )</p>
<p>int write(int fd, void *buf, size_t count);</p>
<p>int read(int fd, void *buf, size_t count);</p>
<p>int close(int fd);</p>
<p>！查看具体使用：多进程</p>
<h2 id="缓冲函数"><a href="#缓冲函数" class="headerlink" title="缓冲函数"></a>缓冲函数</h2><h3 id="内核上的缓冲"><a href="#内核上的缓冲" class="headerlink" title="内核上的缓冲"></a>内核上的缓冲</h3><p>int fdatasync(int fd);&#x2F;&#x2F;刷新数据到磁盘<br>int fsync(int fd);&#x2F;&#x2F;刷新文件到磁盘</p>
<h3 id="应用层的缓冲"><a href="#应用层的缓冲" class="headerlink" title="应用层的缓冲"></a>应用层的缓冲</h3><p>有一个获取文件信息的系统调用 stat。其获得的文件属性信息中，有一项建议了文件 IO<br>缓存大小，低于此值的缓存大小会被认为是低效的。其函数原型为：</p>
<pre><code>int stat(const char * pathname, struct stat *statbuf);
</code></pre>
<p>这一项正是 struct stat 结构体中的 st_blksize 字段。设置应用层的缓存大小，至少不小于该字段给出的数值。</p>
<p>此外， <strong>glibc 中提供的 fread 和 fwrite 函数，其内部都维护了一个数据缓存，用来尽量减少系统调用次数</strong><br>。默认选择的缓存大小已进行了充分优化。如果还是不满意，可以用 glibc 的 setvbuf 和 setbuffer<br>函数自定义缓存大小和缓存行为。这两个函数的原型分别为：</p>
<pre><code>int setvbuf(FILE *stream, char *buf, int mode, size_t size);
void setbuffer(FILE *stream, char *buf, size_t size);
</code></pre>
<p>其中的 setvbuf 函数允许开发者指定缓冲方式，主要有以下三种可选方式。</p>
<ul>
<li>_IONBF：不缓冲，标准错误输出默认选择该缓冲方式，以保证错误信息及时输出来。</li>
<li>_IOLBF：行缓冲，也就是遇到换行符时，对之前的内容执行 read、write 系统调用，终端设备默认执行该缓冲方式。</li>
<li>_IOFBF：全缓冲，也叫块缓冲，当指定大小的缓冲区满了之后，才会触发调用一次系统调用，磁盘文件默认使用该缓冲方式。同时，glibc 还提供了 fflush 函数，应用可以在缓冲区数据满之前，手动将数据刷新到内核缓冲区。</li>
</ul>
<p>出于性能上的考虑，读写磁盘文件应该使用 fread 和 fwrite 函数，而不是直接使用 read 和 write</p>
<h3 id="混合使用glibc和系统调用"><a href="#混合使用glibc和系统调用" class="headerlink" title="混合使用glibc和系统调用"></a>混合使用glibc和系统调用</h3><p>前面讨论过，为了尽量减少系统调用的次数，我们推荐使用 glibc 的 fread 和 fwrite 函数操作文件，这两个函数需要的参数是 FILE 类型。</p>
<p>如果我们既希望使用系统调用控制数据同步和内核缓冲行为，又需要使用以整数型为参数的系统调用，该如何混合使用两者操作同一个文件呢？</p>
<p>其实，C 标准库提供了实现两者间互相转换的函数：</p>
<pre><code>int fileno(FILE *fp)
FILE * fdopen(int fd, const char * mode)
</code></pre>
<p>其中 fdopen 中的文件模式需要和 open 打开文件时的模式相同，否则会失败。</p>
<h2 id="EXT2"><a href="#EXT2" class="headerlink" title="EXT2"></a>EXT2</h2><h2 id="文件扩展属性"><a href="#文件扩展属性" class="headerlink" title="文件扩展属性"></a>文件扩展属性</h2><h2 id="文件系统监控"><a href="#文件系统监控" class="headerlink" title="文件系统监控"></a>文件系统监控</h2><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><p>int pipe(int fds[2]);&#x2F;&#x2F;0代表读取，1代表写入,如果返回了2，那么代表错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//我们通常使用两个进程之间的管道进行读和写，因此务必注意单向的情况下close不需要的窗口fd</span><br><span class="line">//linux中预留给管道的是一个环形缓冲区，大小有16页，因此每次写入大小不要超过一页，否则管道函数会重新寻找新的页而不是顺序存放，并且读的时候需要保证乱序拼接消息，容易出错。</span><br><span class="line">//如果环形缓冲区满，那么写进程会睡眠，直到空间可用。</span><br></pre></td></tr></table></figure>

<p>dup&amp;dup2(int fd);</p>
<h2 id="有名管道FIFO"><a href="#有名管道FIFO" class="headerlink" title="有名管道FIFO"></a>有名管道FIFO</h2><p>可以保证不同进程空间之间的文件访问（而不是无名下的父子之间共享的fd来文件访问）。</p>
<p>创建 FIFO 的系统调用如下：</p>
<pre><code>int mkfifo(const char *pathname, mode_t mode);
</code></pre>
<p>FIFO 的实现与行为和管道非常相似</p>
<p>！更多IPC看多进程</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>实际上内存映射就是创建进程中的部分过程被包装成系统调用给了用户来使用：加载磁盘（文件）并找到物理内存直接映射到用户空间而已。这样进程I&#x2F;O就不再需要多次系统调用了：<strong>不需要内核缓冲区</strong>，变相扩大了应用层缓冲区，牺牲一点空间换时间。同时也引入了零拷贝：通过PGFLT来增加映射。</p>
<pre><code>void * mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<p>其中：</p>
<ul>
<li>参数 addr 指定期望的映射目标地址，如果给 addr 传递 NULL，则表示让内核选择一个合适的地址；</li>
<li>参数 length 指定要映射的数据的字节数，内核会把它对齐到内存页大小的下一个倍数；</li>
<li>参数 prot 指定地址映射之后的访问权限，它的取值可以是 PROT_NONE，或者 PROT_READ、PROT_WRITE、PROT_EXEC 几种值的任意组合；</li>
<li>参数 fd 指定要映射的文件；</li>
<li>参数 offset 指定映射内容在文件中的偏移量。</li>
</ul>
<p>flags 参数比较复杂，它指定执行内存映射时使用的操作选项，不同选项的组合适用于不同的应用场景。 <strong>其中有两个选项是互斥并且是必选项。</strong></p>
<ul>
<li><p>MAP_PRIVATE：私有映射。在这种映射模式下，映射到内存中的内容会根据文件内容进行初始化，但是内存中内容的变化不会更新到磁盘文件中去，而且，映射建立之后，一旦应用对内存内容有更新，内核会使用写时拷贝技术为被修改的内存页创建新的副本。</p>
</li>
<li><p>MAP_SHARED：共享映射。在这种映射模式下，映射后内存内容的修改会更新到磁盘文件内，而且，如果有多个进程映射了同一个磁盘文件的相同区域，那么其中任意一个进程对内存内容的修改都会立即被其他进程可见。</p>
</li>
</ul>
<p>除了这两个互斥的必选项之外，还可以组合使用一些其他的操作选项，常见的比如有<br>MAP_ANONYMOUS（创建匿名映射）、MAP_FIXED（使用指定的固定地址执行映射）等，了解更多请读者自行查看帮助手册。</p>
<h3 id="glib的应用"><a href="#glib的应用" class="headerlink" title="glib的应用"></a>glib的应用</h3><p>在 glibc 的内存分配函数 malloc 的内部，有时会 <strong>使用 mmap 函数代替堆内存边界调整函数 brk。</strong></p>
<p>用 mmap 分配内存的 <strong>好处在于，可以独立使用 munmap 高效地解除映射</strong> ，映射解除后，应用占用的虚拟内存总量就会降下来。</p>
<p>而如果使用 brk 调整边界的方式，当释放的内存不在堆内存边界的时候，堆内存的最高水位线是降不下来的。</p>
<p>但是 mmap <strong>也有缺点，最大缺点就是系统开销比较大</strong> ，因为需要经过内核，内核先要查找合适的映射地址，还会把分配的内存内容都置为<br>0，再返回给应用层。</p>
<p>所以，在 glibc 的设计中， <strong>只有生命周期比较长的大块内存才适合使用 mmap 进行分配</strong> 。在最新的 glibc 实现中：</p>
<ul>
<li>超过 32 MB 的内存块会被认为是大内存块，且总是会使用 mmap 分配；</li>
<li>小于 128 KB 的内存申请，总是会在动态堆内存区进行分配；</li>
<li>大小在 128 KB 到 32 MB 之间的内存申请，会受到动态调整的分界水位线的影响，水位线之下的在动态堆内存区分配，高于水位线的用 mmap 分配，而水位线的调整时机，就是在 mmap 分配的内存区上执行 free 操作时。</li>
</ul>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>1.共享内存的实现</p>
<p>在执行内存映射时， <strong>使用 MAP_SHARED 选项</strong> ，并关联到相同的磁盘文件，就 <strong>可以创建在多个进程间共享的内存块。</strong></p>
<p>这样创建的映射内存与 IPC 的共享内存很相似，不同之处在于 <strong>它会同时把内存中的更新保存到磁盘文件上，所以可以提供数据的持久化保存功能。</strong></p>
<p>如果要在父子进程之间共享内存块，而不需要数据持久化功能，还可以使用共享的匿名映射（MAP_SHARED | MAP_ANONYMOUS）。</p>
<p>与使用共享内存的方式相比，以这样的方式创建的共享内存块，不会显示在 IPC<br>的输出列表里，而且可以把共享范围严格限制在父子进程之间，因而更加适合有私密性要求的数据的共享。</p>
<p>2.多个文件映射内存，优化逻辑处理</p>
<p>flags 还有一个 <strong>应用比较多的选项 MAP_FIXED</strong> ，它表示把内存映射到某个指定的固定位置。使用这个选项，就可以<br><strong>把分布在多个文件，或者单个文件不同位置处的内容，映射到连续的内存地址处</strong> ，如此处理之后就可以使后续的处理逻辑得以简化。</p>
<p>如果使用的是 MAP_SHARED 与 MAP_FIXED 组合的方式，还可以实现内存中更新的内容自动保存到相应文件的功能。</p>
<p>在使用 MAP_FIXED 选项时，通常会与匿名私有映射配合使用，也就是首先以如下方式让操作系统帮助我们选择一个与当前虚拟地址不冲突的映射地址：</p>
<p>​    </p>
<pre><code>void * addr = mmap(NULL, length, prot_flag, MAP_PRIVATE | MAP_ANONYMOUS, 0);
</code></pre>
<p>然后以 addr 地址为基地址，在映射内存的相对位置上使用 MAP_FIXED 标记安排后续每块数据的映射位置。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存shm和内存映射mmap一点点不一样：前者用来共享，后者为了优化内核访问。</p>
<p>实际上共享内存就是针对两个进程的内存映射：寻找物理页，映射时共享页表项（可写的COW）为了IPC而已。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">int shmdt(const void *shmaddr);</span><br></pre></td></tr></table></figure>

<ul>
<li>shmget() 函数 <strong>创建或获取一块指定大小（size）的共享内存</strong> ，key 和 shmflg 的意义与消息队列函数中的 key 和 flag 类似：都是内核里的id而不是自定义</li>
<li>shmat() <strong>将指定的共享内存附加到进程的线性地址空间内</strong> ，可以指定起始线性地址（shmaddr），而更常见的做法是让内核决定起始地址（shmaddr &#x3D;&#x3D; NULL）。函数成功执行后，返回值是该共享内存附加到进程的线性起始地址。这两步操作成功之后，进程就可以像使用其他内存一样使用这块内存区。如果还有其他进程附加了该共享内存，任意进程对内存区域的修改对其他进程都是可见的。基于此种数据交换方式，共享内存通常可与信号量配合使用， <strong>实现临界区的一致性保护</strong> ，除非在其上实现的是某种无锁的数据结构。</li>
<li>shmdt() 函数用于 <strong>将共享内存段从当前进程中分离</strong> 。</li>
</ul>
<p>如果附加共享内存时让操作系统决定起始地址，进程多次运行时选择的起始地址将不固定。若要存储指向共享内存区内某数据对象的地址，<br><strong>应使用偏移量形式，而不能直接存储绝对地址</strong> 。</p>
<p>另外，共享内存的生存周期与进程内存不同，<strong>共享内存会在进程退出之后仍被系统保留</strong>。因此，如果共享内存中有指向进程内存的指针，应该在进程重启时重置。</p>
<p>共享内存的各种限制同样可以通过内核参数设置，如下所示。</p>
<ul>
<li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmmni：可以创建的共享内存块的数量。</li>
<li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmmax：共享内存段的最大容量，实际上限同时依赖物理内存和交换空间的大小。</li>
<li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmall：系统中所有共享内存的分页总数上限，同时受限于物理内存和交换空间的大小。</li>
</ul>
<p>另外，附加共享内存实际上只是把内存页表指向特定的物理内存页，在使用 fork()<br>创建子进程之后，这些数据也会被复制一份，所以，子进程会继承父进程附加的共享内存段。而当 exec() 成功执行后，共享内存段会在新进程中被分离。</p>
<p>使用共享内存的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程A</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">#define SHM_PATH &quot;/tmp/shm&quot;</span><br><span class="line">#define SHM_SIZE 128</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//init</span><br><span class="line">    int shmid;</span><br><span class="line">    char *addr;</span><br><span class="line">    key_t key = ftok(SHM_PATH, 0x6666);</span><br><span class="line">//create shm</span><br><span class="line">    shmid = shmget(key, SHM_SIZE, IPC_CREAT|IPC_EXCL|0666);</span><br><span class="line">    if (shmid &lt; 0) &#123;</span><br><span class="line">        printf(&quot;failed to create share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">//map shm</span><br><span class="line">    addr = shmat(shmid, NULL, 0);</span><br><span class="line">    if (addr &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;failed to map share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">//easily op to shm</span><br><span class="line">    sprintf(addr, &quot;%s&quot;, &quot;Hello World\n&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">进程B</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">#define SHM_PATH &quot;/tmp/shm&quot;</span><br><span class="line">#define SHM_SIZE 128</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int shmid;</span><br><span class="line">    char *addr;</span><br><span class="line">    key_t key = ftok(SHM_PATH, 0x6666);</span><br><span class="line">    </span><br><span class="line">    char buf[128];</span><br><span class="line">//just map shm</span><br><span class="line">    shmid = shmget(key, SHM_SIZE, IPC_CREAT);</span><br><span class="line">    if (shmid &lt; 0) &#123;</span><br><span class="line">        printf(&quot;failed to get share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addr = shmat(shmid, NULL, 0);</span><br><span class="line">    if (addr &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;failed to map share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    strcpy(buf, addr, 128);</span><br><span class="line">    printf(&quot;%s&quot;, buf);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>fork</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多进程模型的网络服务程序中，为什么要在子进程中关闭监听套接字，同时要在父进程中关闭新连接的套接字呢？</span><br><span class="line"></span><br><span class="line">原因在于 fork() 执行之后，所有已经打开的套接字都被增加了引用计数，在其中任一个进程中都无法彻底关闭套接字，只能减少该文件的引用计数。因此，在</span><br><span class="line">fork() 之后，每个进程立即关闭不再需要的文件是个好的策略，否则很容易导致大量没有正确关闭的文件一直占用系统资源的现象。</span><br><span class="line"></span><br><span class="line">**再比如** ，下面这段代码是否存在问题？为什么在输出文件中会出现两行重复的文本？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        FILE * fp = fopen(&quot;output.txt&quot;, &quot;w&quot;);</span><br><span class="line">        fputs(&quot;Message in parent\n&quot;, fp);</span><br><span class="line">        switch(fork())</span><br><span class="line">        &#123;</span><br><span class="line">        case -1:</span><br><span class="line">            perror(&quot;fork failed&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        case 0:</span><br><span class="line">            fputs(&quot;Message in Child\n&quot;, fp);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">    [root@TealCode process]# cat output.txt</span><br><span class="line">    Message in parent</span><br><span class="line">    Message in parent</span><br><span class="line">    Message in Child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原因是 fputs 库函数带有缓冲，fork() 创建的子进程完全拷贝父进程用户空间内存时，fputs 库函数的缓冲区也被包含进来了。所以，fork()</span><br><span class="line">执行之后，子进程同样获得了一份 fputs 缓冲区中的数据，导致“Message in</span><br><span class="line">parent”这条消息在子进程中又被输出了一次。要解决这个问题，只需在 fork() 之前，利用 fflush 刷新到内核缓冲并放弃应用层缓冲，因此进程的缓冲就不会被包含。</span><br><span class="line"></span><br><span class="line">另外，利用父子进程共享相同的只读数据段的特性，是不是可以实现一套父子进程间的通信机制呢？</span><br><span class="line">A：父全局定义一个数据并实时修改，子读取即可</span><br></pre></td></tr></table></figure>

<p>exec：#include &lt;unistd.h&gt;，只有在错误的时候返回</p>
<p>​	int execve(const char *filename, char *const argv[], char *const envp[]);&#x2F;&#x2F;工业用</p>
<p>filename 用于指定要运行的程序的文件名，argv 和 envp<br>分别指定程序的运行参数和环境变量。除此之外，该系列函数还有很多变体，它们执行大体相同的功能，区别在于需要的参数不同，包括<br>execl、execlp、execle、execv、execvp、execvpe 等。它们的参数意义和使用方法请读者自行查看帮助手册。</p>
<p>​	Int execv(const char* path, char *const argv[]);&#x2F;&#x2F;自己用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(execv(strcat(pth, ecmd-&gt;argv[0]), ecmd-&gt;argv) &lt; 0)&#123;//注意：第一个指针通常被忽略，默认认为是文件名，</span><br><span class="line">    printf(&quot;%s&quot;, pth);</span><br><span class="line">    fprintf(stderr, &quot;execv not implemented\n&quot;);//&lt;stdio.h&gt;,即向终端输出信息</span><br><span class="line">    _exit(0); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对于执行 exec() 函数的应用，应该 <strong>总是使用内核为文件提供的执行时关闭标志（FD_CLOEXEC）</strong> 。设置了该标志之后，如果<br>exec() 执行成功，文件就会被自动关闭；如果 exec() 执行失败，那么文件会继续保持打开状态。使用系统调用 fcntl() 可以设置该标志。</p>
<p>fexecve() 函数</p>
<p>glibc 从 2.3.2 版本开始提供 fexecv() 函数，它与 execve() 的区别在于，<br><strong>第一个参数使用的是打开的文件描述符，而非文件路径名</strong> 。</p>
<p>增加这个函数是为了满足这样的应用需求：有些应用在执行某个程序文件之前，需要先打开文件验证文件内容的校验和，确保文件内容没有被恶意修改过。</p>
<h2 id="监视进程"><a href="#监视进程" class="headerlink" title="监视进程"></a>监视进程</h2><ul>
<li>pid_t wait(int * statua)</li>
</ul>
<p>一直阻塞地等待任意一个子进程退出，返回值为退出的子进程的 ID，status 中包含子进程设置的退出标志。</p>
<ul>
<li>pid_t waitpid(pid_t pid, int * status, int options)</li>
</ul>
<p>可以用 pid 参数指定要等待的进程或进程组的 ID，options 可以控制是否阻塞，以及是否监控因信号而停止的子进程等。</p>
<ul>
<li>int waittid(idtype_t idtype, id_t id, siginfo_t *infop, int options)</li>
</ul>
<p>提供比 waitpid 更加精细的控制选项来监控指定子进程的运行状态。</p>
<ul>
<li>wait3() 和 wait4() 系统调用</li>
</ul>
<p>可以在子进程退出时，获取到子进程的资源使用数据。</p>
<p><strong>即使父进程在业务逻辑上不关心子进程的终止状态，也需要使用 wait 类系统调用的底层原因</strong>：父进程使用wait真正杀死一个子进程，因此无论是kill命令，或者子进程在wait之前就终止了，仍然需要用wait来杀死子进程，在这之间就是僵尸状态。如果不wait，那么从内核资源角度看就会被大量占用，导致寻找free进程失败。如果父进程也进入僵尸状态，那么就会使用init进程来处理这种情况。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>正常终止一个进程可以用 _exit 系统调用来实现，原型为：    </p>
<pre><code>void _exit(int status);
</code></pre>
<p>其中的 status 会返回 wait() 类的系统调用。 <strong>进程退出时会清理掉该进程占用的所有系统资源</strong><br>，包括关闭打开的文件描述符、释放持有的文件锁和内存锁、取消内存映射等，还会给一些子进程发送信号（后面课程再详细展开）。该系统调用一定会成功，永远不会返回。</p>
<p>在退出之前，还希望做一些 <strong>个性化的清理操作</strong> ，可以使用库函数 exit() 。函数原型为：</p>
<pre><code>void exit(int status);
</code></pre>
<p>这个库函数先调用退出处理程序，然后再利用 status 参数调用 _exit() 系统调用。这里的退出处理程序可以通过 atexit() 或<br>on_exit() 函数注册。其中 atexit() 只能注册返回值和参数都为空的回调函数，而 on_exit()<br>可以注册带参数的回调函数。退出处理函数的执行顺序与注册顺序相反。它们的函数原型如下所示：</p>
<pre><code>int atexit(void (*func)(void));
int on_exit(void (*func)(int, void *), void *arg);
</code></pre>
<p>通常情况下， <strong>个性化的退出处理函数只会在主进程中执行一次</strong> ，所以 exit() 函数一般在主进程中使用，而在<strong>子进程</strong>中只使用 _exit()<br>系统调用结束当前进程。</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>4种IPC：</p>
<ul>
<li>管道与 FIFO</li>
<li>消息队列！</li>
<li>信号和信号量！</li>
<li>共享内存</li>
</ul>
<p>管道 <strong>还有一些固有的限制</strong> ，比如下面这几项：</p>
<ul>
<li>管道与 FIFO 中传输的是比特流，没有消息边界的概念，很难实现这样一类需求——有多个读取进程，每个进程每次只从管道中读取自定义长度的数据；</li>
<li>管道与 FIFO 中数据读出的顺序与数据写入的顺序严格一致，没有优先级的概念，必须要通过锁或者睡眠队列来保证顺序；</li>
<li>管道和 FIFO 使用的都是内核存储空间，允许滞留在管道中的数据容量有限。</li>
</ul>
<p>而消息队列则解决这个问题。</p>
<p>消息队列就是一个消息的双向链表，每个消息队列都有一个队列头，用结构<strong>struct msg_queue</strong>来描述。队列头中包含了该队列的大量信息，包括消息队列的<strong>键值、用户ID、组ID、消息数目、读写进程ID</strong>等。</p>
<p>消息队列在如下两个方面上比管道有所增强：</p>
<ul>
<li>消息队列中的数据是有边界的，发送端和接收端能以消息为单位进行交流，而不再是无分隔的字节流，这大大降低了某些应用的逻辑复杂度；</li>
<li>每条消息都包括一个整形的类型标识，接收端可以读取特定类型的消息，而不需要严格按消息写入的顺序读取，这样可使消息优先级的实现非常简单，而且每个进程可以非常方便地只读取自己感兴趣的消息。</li>
<li><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112091520210.png"></li>
<li>我们可以从以上的图看到，消息队列在内核生成，但是我们的msg是自己定义的并传入内核，这种间接就有很多内核编写空间来规避管道的问题。？到底怎么规避</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">key_t ftok(char *pathname, char proj);</span><br><span class="line">int msget(key_t key, int flag);</span><br><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflag);</span><br><span class="line">int msgrcv(int msqid, void *msgp, size_t maxmsgsz, long msgtp, int msgflag);</span><br><span class="line">int msgctl(int msqid, int cmd, struct msqid_ds *buf);//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">  * msqid 是由 msgget() 生成的消息队列 ID；</span><br><span class="line">  * msgp 指向用户定义的消息体，第一个字段需要是 int msgtype，0代表第一个消息，正代表符合type第一条，负代表小于type绝对值的第一个，后续的其他字段可以自由定义；</span><br><span class="line">  		简单情况：sender可以直接发送消息，receiver可以指定一个buf数组即可。</span><br><span class="line">  		消息体：</span><br><span class="line">			struct _msg</span><br><span class="line">			&#123;</span><br><span class="line">    			long mtype;</span><br><span class="line">    			char buf[256];</span><br><span class="line">			&#125;msg1,msg2;//这个是可以自定义的，内核根据情况给定的指针进行修改即可</span><br><span class="line">  * msgsz 指定要发送的消息体的数据长度；</span><br><span class="line">  * msgflag 指定发送动作的行为参数，目前只有一个可选参数 IPC_NOWAIT，表示当内核中消息队列已满时不挂起发送进程，而是立即返回一个 EAGAIN 错误。</span><br><span class="line">  * cmd：IPC_STAT：用于获取消息队列信息，返回的信息存贮在参数buf中</span><br><span class="line">				 IPC_SET：用于设置消息队列的属性，要设置的属性存储在参数buf中</span><br><span class="line">				 PC_RMID：删除msqid标识的消息队列</span><br><span class="line"></span><br><span class="line">	* 消息读取函数中的 msgtp 字段指定了要读取的消息类型，可以有多种消息过滤的方法：</span><br><span class="line">   		传入正值表示只取指定类型的消息；</span><br><span class="line">   		传入 0 值表示不区分消息类型，按照先入先出的顺序依次读取；</span><br><span class="line">   		传入负值表示按照优先级从高到低依次读取消息类型值不大于给定值的绝对值的消息。</span><br></pre></td></tr></table></figure>

<p><a href="https://zhuanlan.zhihu.com/p/143554766">使用场景代码</a></p>
<p>信号机制</p>
<p>通常我们的睡眠唤醒就是靠信号，中断向量也可以认为是内核信号。因此我们的硬件中断和系统调用都算是一种信号机制。那么信号从发送到接受处理是异步的。</p>
<p>实际上就是通过<strong>系统调用</strong>来给用户<strong>中断处理</strong>的权利：<strong>中断进入内核</strong>后返回用户态处理后再返回用户原本代码。</p>
<p>因此有以下三类处理</p>
<ul>
<li>自定义模拟中断：upcall</li>
<li>屏蔽：啥也不干</li>
<li>让系统处理信号：大部分是终止程序</li>
</ul>
<p>我们来看看系统处理：这里认为<strong>内核还能收到多种中断信号</strong>，不是xv6（jos）那样的大内核锁，所以变复杂了。</p>
<p>0-31信号采用bitmap来解决，1代表还未处理。如果多次发送，bitmap处理是幂等的：如果正在处理，内核中断就忽略这个信号，继续切换回之前的信号处理，因此没法保证都会处理到。后续的使用队列，因此如果在处理，会有一个队列长度的等待。</p>
<p>存在以下信号机制处理问题：</p>
<ul>
<li><p>要重入的系统调用信号：比如malloc这样中断之后不会继续运行剩余的malloc</p>
</li>
<li><p>小心全局数据：信号被另一个信号打断，全局就会改变</p>
</li>
<li><p>小心全局errno：会被打断时中断覆盖errno后返回不是我要的errno</p>
</li>
<li><p>保证全局数据的共享操作原子性：因为如果不屏蔽中断，mutex一定会失效，xchg也不太行：volatile（防止编译器优化） 和 保证不会中断的sig_atomic_t</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile sig_atomic_t variable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>小心++ 和 –</p>
</li>
<li><p>进程内核异常栈爆了：自定义一个预留栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sigaltstack(const stack_t * sigstack, stack_t * old_sigstack);</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    void * ss_sp;       //备选栈的起始地址</span><br><span class="line">    int    ss_flags;    //备选栈操作标志：SS_ONSTACK 启用 SS_DISABLE禁用</span><br><span class="line">    int    ss_size;     //备选栈空间大小</span><br><span class="line">&#125;stack_t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来是一个对于信号被打断的一个简单处理</p>
<p>实际代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void block_readpipe(int pipefd, void *buffer, int sz) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int n = read(pipefd, buffer, sz);</span><br><span class="line">        if (n&lt;0) &#123;</span><br><span class="line">            if (errno == EINTR)</span><br><span class="line">                continue;</span><br><span class="line">            fprintf(stderr, &quot;socket-server : read pipe error %s.\n&quot;,strerror(errno));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // must atomic read from a pipe</span><br><span class="line">        assert(n == sz);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码段出自云风的开源游戏服务器 Skynet。在这段代码中，在从管道里面读取指定字节的数据时，对 EINTR 错误做了特殊的处理，即：</p>
<ul>
<li>当发现 read 系统调用返回了错误，而错误代码是 EINTR（被打断）的时候，当做什么也没发生，继续读取后面的数据；</li>
<li>其他类型的错误才会被作为管道出错的情况来处理。</li>
</ul>
<p>其原因，就是因为在管道上的 read 系统调用时会阻塞的，如果当进程阻塞在 read<br>系统调用上时收到了信号，那么在执行完对应的信号处理程序之后，在再次返回主程序时，read 系统调用会返回错误码告知进程自己被打断过。</p>
<p>如果在 Socket 上执行阻塞的读取操作时，如果给 Socket<br>设置了超时时间属性，那么当阻塞时间超过设置的超时时间时，也会有一个信号出来打断阻塞的系统调用，这时，错误码会被设置为 EAGAIN 或者<br>EWOULDBLOCK，表示这次读取超时了，到此为止了，想要更多的数据就再试一次吧。</p>
<p>在 Linux 的标准中，规定在这种情况下，把 errno 设置为 EAGAIN 和 EWOULDBLOCK<br>都是可以的，所以，要想让你写的程序兼容性更好，总是应该把这两个错误码一起检查。</p>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int </span><br><span class="line">sched_setscheduler(pid_t pid, int policy, const struct sched_param * param);//设置实时进程的调度策略和优先级（sched_param）</span><br><span class="line">int </span><br><span class="line">sched_setparam(pid_t pid, const struct sched_param * param);//设置实时优先级</span><br><span class="line">int </span><br><span class="line">sched_yield(void);//主动放弃进行调度</span><br><span class="line">int </span><br><span class="line">sched_setaffinity(pid_t pid, size_t len, cpu_set_t * set);//设置进程的CPU亲和力</span><br><span class="line">int </span><br><span class="line">setpriority(int which, id_t who, int prio);//进程组设置优先级？</span><br><span class="line">int </span><br><span class="line">getpriority(int which, id_t who);//进程组得到优先级？</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">  * pid 指定目标进程 ID ，如果为 0，表示修改调用进程。</span><br><span class="line">  * policy 参数指定进程采用的调度策略** ，如果决定采用实时调度策略，则可以取值 SCHED_RR、SCHED_FIFO；如果希望采用非实时的普通调度策略，则也可设置为 SCHED_OTHER（普通时间片轮转调度）、SCHED_BATCH（适用于批处理的进程）、SCHED_IDLE（比最大的 Nice 值的运行优先级还要低的后台进程）。</span><br><span class="line">  * param 定义为struct sched_param &#123;</span><br><span class="line">    																int sched_priority;</span><br><span class="line">																	&#125;;</span><br><span class="line">	* cpu_set_t 是一个位掩码结构，能够指定目标进程可以运行的 CPU；在 CPU 位掩码结构中，对 CPU 的编号是从 0 开始的，比如一个 16 核的 CPU，其 CPU 核心的编号分别为 0 — 15。</span><br><span class="line">  * len 参数指定使用的 CPU 位掩码数据结构的字节数。</span><br><span class="line">	* cpu_set_t的宏</span><br><span class="line">			void CPU_ZERO(cpu_set_t *set);           //把 CPU 位掩码 set 初始化为 0</span><br><span class="line">			void CPU_SET(int cpu, cpu_set_t *set);   //将指定编号的 CPU 添加到位掩码 set 中</span><br><span class="line">      void CPU_CLR(int cpu, cpu_set_t *set);   //将指定编号的 CPU 从位掩码 set 中删除</span><br><span class="line">			void CPU_ISSET(int cpu, cpu_set_t *set); //检查指定编号的 CPU 在位掩码 set 中是否存在</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>1.提高时间片：linux0.11分配方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority</span><br></pre></td></tr></table></figure>

<p>即每次调度时找不到就绪态时，对所有进程时间片减半后加优先级，对于睡眠队列（counter停滞）的进程友好。</p>
<p>我们现在的linux跟priority和nice值有关，值越小说明时间counter越多。对于优先级为数字的进程来说，PR 与 NI 的值总是对应的，PR 的取值范围为 0 — 39，而 NI 的取值范围为 -20 — 19，PR 的值总是等于<br>20 + NI。</p>
<p>Nice 在英文中是“和善”的意思，这里进程的 Nice 值，也表示进程的和善程度，Nice 值越高就越和善，越和善的进程，越不会与别的进程争抢 CPU<br>资源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int setpriority(int which, id_t who, int prio);</span><br><span class="line">int getpriority(int which, id_t who);</span><br></pre></td></tr></table></figure>

<p>其中，which 和 who 参数联合指定要操作的进程或进程组（详情请参考帮助手册），setpriority() 中的参数 prio 和<br>getpriority() 的返回值都是操作目标的 Nice 值。</p>
<p>因为 Nice 值可以是负数，所以， <strong>使用 getpriority() 系统调用之前需要先把 errno 显式设置为 0</strong> ，如果返回值为负数，再联合<br>errno 区分是遇到错误，还是目标的 Nice 值本身就是负值。</p>
<p>2.调整优先级的限制</p>
<p> <strong>特权进程能够自由地修改任意进程的优先级</strong>；而非特权进程只能修改自身。我们查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$	ulimit -a</span><br><span class="line">scheduling priority             (-e) 0//0代表0的改动值</span><br><span class="line">//我的不行？</span><br></pre></td></tr></table></figure>

<p>我们如果找到nice&#x3D;&#x3D;-20，那么代表内核工作队列的线程，获得CPU一定是最容易的。</p>
<p>Linux 中有两种比较常用的实时调度策略，分别是：</p>
<ul>
<li>SCHED_RR（Round-Robin 循环）为每个进程都分配一个固定长度的时间片，如果有优先级相同的进程，它们会以循环时间分享的形式交替执行，一个运行的进程使用完时间片或者自己主动放弃 CPU 时，会被放置到同优先级队列的队尾。</li>
<li>SCHED_FIFO（先入先出）没有为进程分配时间片，一个进程一旦获得运行权，就会一直运行，直到终止，或者自己主动放弃 CPU。</li>
</ul>
<p>3.CPU亲和力的调整</p>
<p> <strong>通过精细地控制每个线程的 CPU<br>亲和力，可以在以下几个方面获得性能提升</strong> 。</p>
<ul>
<li>如果一个进程内有多个线程需要经常访问同样的数据，那么把它们绑定在同一个 CPU 上能带来性能的提升。因为如果它们在不同的 CPU 上运行，就需要经常执行这样的操作：把 CPU 高速缓冲器中的数据更新到内存，并在另一个 CPU 上从内存重新加载到高速缓冲器。</li>
<li>如果有两个线程都是 CPU 计算密集的，而且都需要经常使用不同的数据，那把它们分别绑定在不同的 CPU 核心上，也会因为能够重复使用高速缓冲器内的数据而带来整体性能的提升。</li>
<li>如果系统中存在关键功能的进程，专门给它们预留一个或几个 CPU，而把其他的所有进程都限制在别的 CPU 上，能提高系统在各种极端状况下的可用性。</li>
</ul>
<h1 id="多-线程"><a href="#多-线程" class="headerlink" title="(多)线程"></a>(多)线程</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112091239549.png"></p>
<p>！gdb调试时候添加-pthread来编译</p>
<p>线程共享了包括代码段、初始化数据段、未初始化数据段、堆内存段及动态链接内存段等，但是一般找不到其他线程（包括主线程stack）的stack</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>pthread_create()：比较符合概念模型的线程，但是必须自己实现调度算法。</p>
<p>clone() 是创建线程的底层系统调用，同时也为进程创建提供底层支持。其函数原型为：</p>
<pre><code>int clone(int (*func)(void *), void * child_stack, int flags, void * func_args, ...)
</code></pre>
<p>其中，参数 flags 可以指定进程复制时与父进程共享的资源。在线程创建函数中，传递的 flags 如下所示：</p>
<pre><code>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
</code></pre>
<p>也就是说，新建的实体与父进程共享同一份虚拟内存页、同一个打开的文件描述符表、文件系统信息、信号处理函数表等，且新创建的实体会被放在创建者的线程组内（CLONE_THREAD）。相比之下，用<br>fork() 创建进程时的 <strong>flags 值仅包含 SIGCHILD</strong> 。这也是 <strong>线程和进程的本质区别</strong> 。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li>mutex</li>
<li>semaphore</li>
<li>spinlock</li>
<li>读写锁</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pthread_mutex_t lock;</span><br><span class="line">pthread_mutex_init(&amp;lock,NULL);//0即未上锁</span><br></pre></td></tr></table></figure>



<ul>
<li>pthread_mutex_lock(&amp;lock) 负责在进入临界区之前对临界区加锁；</li>
<li>pthread_mutex_unlock(&amp;lock) 负责在执行完临界区处理时给临界区解锁。</li>
</ul>
<p>小心使用，由于互斥锁功能有限，会出现死锁：循环等待依赖。</p>
<pre><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict abs_timeout);
</code></pre>
<p>它们可以在锁定失败后立即返回，或在一段超时时间后返回，应用可以处理这种错误情况，而避免陷入无限的死锁中。</p>
<p>但是这里使用麻烦在于对于代码和文件需要在使用之前进行加锁，而文件我们使用包装的互斥锁，通常对于文件读写（包括管道）非常好用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int lockf(int fd, int cmd, off_t len);</span><br><span class="line">//cmd:0 开锁，1 上锁</span><br><span class="line">len通常是0，偏移闭区间，可以使用strlen来计算</span><br></pre></td></tr></table></figure>



<h3 id="信号量-x2F-x2F-暂时粗体"><a href="#信号量-x2F-x2F-暂时粗体" class="headerlink" title="信号量&#x2F;&#x2F;暂时粗体"></a>信号量&#x2F;&#x2F;暂时粗体</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112091555432.png"></p>
<p>无名信号量在进程空间里产生而不是内核，因此只能在线程之间使用（同一个进程内共享变量定位），而有名信号量在内核进行申请可以通过名字定位，因此可以用于进程之间IPC。这点和管道不一样，你可以通过头文件来确认。</p>
<p>同时信号量通过spinlock来保证原子性</p>
<p>​	无名信号量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;semaphore.h&gt;</span><br><span class="line">//init</span><br><span class="line">sem_t sem;</span><br><span class="line">sem_init (&amp;sem,0,10);//0代表线程，非0代表进程。10 is counter	</span><br><span class="line"></span><br><span class="line">//op</span><br><span class="line">sem_wait(&amp;sem);//-1</span><br><span class="line">sem_post(&amp;sem);//+1</span><br><span class="line">sem_destroy(&amp;sem);</span><br><span class="line">//特别注意的是，我们在wait之后信号量小于0就会卡住，因此可以作为顺序</span><br></pre></td></tr></table></figure>

<p>​	有名信号量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/sem.h&gt;//通常也要加个无名的，因为？</span><br><span class="line">sem_t *sem = sem_open(&quot;name_sem1&quot;,O_CREAT,0666,0);</span><br><span class="line"></span><br><span class="line">//0666 表示 所有用户可读写，0代表初始值，如果存在这个有名，那么后两个参数会被忽略</span><br><span class="line">//其他操作即沿用无名的 </span><br></pre></td></tr></table></figure>

<p>例如，管道通信中，如果父进程使用 fork()创建两个<strong>子进程1和2</strong>，子进程1，2按顺序向管道写一段文字，最后父进程从管道将子进程写入的内容读出来，要保证进程执行的<strong>先后顺序</strong>（信号量使用了队列？），可以用有名信号量来解决。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;semaphore.h&gt;</span><br><span class="line">#include&lt;sys/sem.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//init </span><br><span class="line">    int pid1,pid2;</span><br><span class="line">    sem_t *resource1; //注意是指针</span><br><span class="line">    sem_t *resource2; </span><br><span class="line">    int Cpid1,Cpid2=-1;</span><br><span class="line">    int fd[2];//0为读出段,1为写入端</span><br><span class="line">    char outpipe1[100],inpipe[200],outpipe2[100];</span><br><span class="line">    pipe(fd);//建立一个无名管道</span><br><span class="line"></span><br><span class="line">    pid1 = fork();</span><br><span class="line"></span><br><span class="line">    if(pid1&lt;0)&#123;</span><br><span class="line">        printf(&quot;error in the first fork!&quot;);</span><br><span class="line">    &#125;else if(pid1==0)&#123;//子进程1</span><br><span class="line">//op in child1</span><br><span class="line">        resource1=sem_open(&quot;name_sem1&quot;,O_CREAT,0666,0);/0666 表示 所有用户可读写</span><br><span class="line">        Cpid1 = getpid();</span><br><span class="line">        close(fd[0]);//关掉读出端</span><br><span class="line">        lockf(fd[1],1,0);//上锁,则锁定从当前偏移量到文件结尾的区域</span><br><span class="line">        sprintf(outpipe1,&quot;Child process 1 is sending a message!&quot;);</span><br><span class="line">        write(fd[1],outpipe1,strlen(outpipe2));//write from fd[1] to outpipe1,count=strlen()</span><br><span class="line">        lockf(fd[1],0,0);//解锁</span><br><span class="line">        sem_post(resource1);</span><br><span class="line">        sem_close(resource1);</span><br><span class="line">        exit(0);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">        if(pid2&lt;0)&#123;</span><br><span class="line">            printf(&quot;error in the second fork!\n&quot;);</span><br><span class="line">        &#125;else if(pid2==0)&#123;  </span><br><span class="line">//op in child2</span><br><span class="line">                resource1=sem_open(&quot;name_sem1&quot;,O_CREAT,0666,0);</span><br><span class="line">                resource2=sem_open(&quot;name_sem2&quot;,O_CREAT,0666,0);</span><br><span class="line">                Cpid2 = getpid();</span><br><span class="line">                sem_wait(resource1);//child2等待</span><br><span class="line">								close(fd[0]);</span><br><span class="line">                lockf(fd[1],1,0);</span><br><span class="line">                sprintf(outpipe2,&quot;Child process 2 is sending a message!&quot;);</span><br><span class="line"></span><br><span class="line">                write(fd[1],outpipe2,strlen(outpipe2));</span><br><span class="line">                lockf(fd[1],0,0);//解锁</span><br><span class="line">                sem_post(resource2);</span><br><span class="line">                sem_close(resource1);</span><br><span class="line">                sem_close(resource2);</span><br><span class="line">                exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">//op in parent</span><br><span class="line">        if(pid1 &gt; 0 &amp;&amp; pid2 &gt;0)&#123;</span><br><span class="line">                resource2=sem_open(&quot;name_sem2&quot;,O_CREAT,0666,0);</span><br><span class="line">                sem_wait(resource2);</span><br><span class="line">                waitpid(pid1,NULL,0);</span><br><span class="line">                waitpid(pid2,NULL,0);</span><br><span class="line">                close(fd[1]);//关掉写端</span><br><span class="line">                read(fd[0],inpipe,200);</span><br><span class="line">                printf(&quot;%s\n&quot;,inpipe);</span><br><span class="line">                sem_close(resource2);</span><br><span class="line">                </span><br><span class="line">                exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        sem_unlink(&quot;name_sem1&quot;);</span><br><span class="line">        sem_unlink(&quot;name_sem2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于child1和child2，进行sem(resource1 针对child2,resource2 针对 parent)和文件加锁，保证了child1，child2，parent的读写顺序，其实就是在多进程状态下使用了01sem的mutex来保证顺序</span><br></pre></td></tr></table></figure>

<p>消费者和生产者进程代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define   __LIBRARY__</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">_syscall2(sem_t*,sem_open,const char *,name,unsigned int,value);</span><br><span class="line">_syscall1(int,sem_wait,sem_t*,sem);</span><br><span class="line">_syscall1(int,sem_post,sem_t*,sem);</span><br><span class="line">_syscall1(int,sem_unlink,const char *,name);</span><br><span class="line"></span><br><span class="line">#define NUMBER 520 /*打出数字总数*/</span><br><span class="line">#define CHILD 5 /*消费者进程数*/</span><br><span class="line">#define BUFSIZE 10 /*缓冲区大小*/</span><br><span class="line"></span><br><span class="line">sem_t   *empty, *full, *mutex;</span><br><span class="line">int fno; /*文件描述符*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int  i,j,k;</span><br><span class="line">    int  data;</span><br><span class="line">    pid_t p;</span><br><span class="line">    int  buf_out = 0; /*读取缓冲区的索引*/</span><br><span class="line">    int  buf_in = 0; /*写入缓冲区的索引*/</span><br><span class="line">    /*打开信号量*/</span><br><span class="line">    if((mutex = sem_open(&quot;carmutex&quot;,1)) == SEM_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sem_open() error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if((empty = sem_open(&quot;carempty&quot;,10)) == SEM_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sem_open() error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if((full = sem_open(&quot;carfull&quot;,0)) == SEM_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sem_open() error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    fno = open(&quot;buffer.dat&quot;,O_CREAT|O_RDWR|O_TRUNC,0666);</span><br><span class="line">    /* 将待读取位置存入buffer后,以便 子进程 之间通信 */</span><br><span class="line">    lseek(fno,10*sizeof(int),SEEK_SET);</span><br><span class="line">    write(fno,(char *)&amp;buf_out,sizeof(int));</span><br><span class="line">    /*生产者进程*/</span><br><span class="line">    if((p=fork())==0)</span><br><span class="line">    &#123;</span><br><span class="line">        for( i = 0 ; i &lt; NUMBER; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_wait(empty);</span><br><span class="line">            sem_wait(mutex);</span><br><span class="line">            /*写入一个字符*/</span><br><span class="line">            lseek(fno, buf_in*sizeof(int), SEEK_SET); </span><br><span class="line">            write(fno,(char *)&amp;i,sizeof(int));  </span><br><span class="line">            buf_in = ( buf_in + 1)% BUFSIZE;</span><br><span class="line"></span><br><span class="line">            sem_post(mutex);</span><br><span class="line">            sem_post(full);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else if(p &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;Fail to fork!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">/*消费者进程*/</span><br><span class="line">    for( j = 0; j &lt; CHILD ; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if((p=fork())==0)</span><br><span class="line">        &#123;</span><br><span class="line">            for( k = 0; k &lt; NUMBER/CHILD; k++ )</span><br><span class="line">            &#123;</span><br><span class="line">                sem_wait(full);</span><br><span class="line">                sem_wait(mutex);</span><br><span class="line">                /*获得读取索引*/</span><br><span class="line">                lseek(fno,10*sizeof(int),SEEK_SET);</span><br><span class="line">                read(fno,(char *)&amp;buf_out,sizeof(int));</span><br><span class="line">                /*读取数据到data*/</span><br><span class="line">                lseek(fno,buf_out*sizeof(int),SEEK_SET);</span><br><span class="line">                read(fno,(char *)&amp;data,sizeof(int));</span><br><span class="line">                /*更新读取索引*/</span><br><span class="line">                buf_out = (buf_out + 1) % BUFSIZE;</span><br><span class="line">                lseek(fno,10*sizeof(int),SEEK_SET);</span><br><span class="line">                write(fno,(char *)&amp;buf_out,sizeof(int));</span><br><span class="line"></span><br><span class="line">                sem_post(mutex);</span><br><span class="line">                sem_post(empty);</span><br><span class="line">                /*消费资源*/</span><br><span class="line">                printf(&quot;%d:  %d\n&quot;,getpid(),data);</span><br><span class="line">                fflush(stdout);</span><br><span class="line">            &#125;</span><br><span class="line">           return 0;</span><br><span class="line">        &#125;else if(p&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;Fail to fork!\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(NULL);</span><br><span class="line">    /*释放信号量*/</span><br><span class="line">    sem_unlink(&quot;carfull&quot;);</span><br><span class="line">    sem_unlink(&quot;carempty&quot;);</span><br><span class="line">    sem_unlink(&quot;carmutex&quot;);</span><br><span class="line">    /*释放资源*/</span><br><span class="line">    close(fno);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高级用法-1"><a href="#高级用法-1" class="headerlink" title="高级用法"></a>高级用法</h4><p>1.信号量的其他系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int semget(key_t key, int nsems, int semflg);      //创建一组以 key 为标识的信号量</span><br><span class="line">int semctl(int semid, int semnum, int cmd, ...);   //在指定的信号量上执行控制操作</span><br><span class="line">int semop(int semid, struct sembuf *sops, unsigned nsops); //在指定信号量上执行 PV 操作</span><br></pre></td></tr></table></figure>

<p>2.条件变量</p>
<ul>
<li>每个工作线程都配备自己的任务队列；</li>
<li>任务分发线程根据当前每个工作线程的负载水平，把任务直接追加到负载最低的工作线程的任务队列里去；</li>
<li>当工作线程发现自己的任务队列中已经没有要处理的任务时，自己进入睡眠状态；</li>
<li>任务分发线程在给某个工作线程分配任务时，如果发现分配之前的任务数是 0，就唤醒该工作线程；</li>
<li>工作线程一旦被唤醒，就持续处理自己的任务队列中的所有任务。</li>
</ul>
<p>在这种工作模式中，线程的休眠和唤醒仍然可以使用信号量，此外，还可以使用实现在 ptrhead 库中的更轻量级的条件变量，相关的接口为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t *mutex);</span><br><span class="line">int pthread_cond_signal(pthread_cond_t * cond);</span><br><span class="line">int pthread_cond_broadcast(pthread_cond_t *cond);</span><br></pre></td></tr></table></figure>

<p>其中 pthread_cond_wait() 接口会阻塞一个线程，直到有另外的线程在同一个条件变量 cond 上用<br>pthread_cond_signal() 或 pthread_cond_broadcast() 发出通知时再继续执行。</p>
<p>pthread_cond_signal 和 pthread_cond_broadcast 的区别在于：</p>
<ul>
<li>pthread_cond_signal 只保证唤醒至少一个被阻塞的线程；</li>
<li>pthread_cond_broadcast 会唤醒所有阻塞在条件变量 cond上的线程。</li>
</ul>
<p><strong>当唤醒目标很明确时，使用 pthread_cond_signal 会更有效率，而且能避免出现惊群的问题</strong> 。在上面改进版的任务处理模式中，就应该使用<br>pthread_cond_signal 来唤醒指定的工作线程。</p>
<p><strong>当唤醒目标无法精确地确定，而只需要保证多个工作线程中至少有一个被唤醒来工作时，应该使用 pthread_cond_broadcast</strong><br>，但是这时候要注意，每个线程都需要能正确处理多余和虚假的唤醒动作。常见的处理方式是把 pthread_cond_wait 包含于一条 while 循环中：</p>
<p>​    </p>
<pre><code>while(pthread_cond_wait(&amp;cond, &amp;mtx));
// Process the task
</code></pre>
<p>市面上有些高性能的防火墙产品对网络数据包的处理就是采用这种工作模式，有些产品还会使用双缓冲技术，进一步减少任务分发线程与工作线程在操作同一个任务队列时发生锁争抢的概率。</p>
<h3 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h3><p>自旋锁的 <strong>优点是等待时间短</strong> ，一旦满足条件就可以马上拿到锁继续执行，不需要经历线程的切换。</p>
<p><strong>它的缺点则是会占用 CPU 资源，一直保持忙等的状态</strong> 。</p>
<p>也因为它忙等的特点，只有非常快速就能完成的临界区才适合用自旋锁保护，而且，临界区内一定不能有对同一个临界区的递归调用，否则会发生死锁。</p>
<p>pthread 库中自旋锁相关的接口为：</p>
<p>​    </p>
<pre><code>int pthread_spin_init(pthread_spinlock_t *lock, int pshared);  //初始化自旋锁
int pthread_spin_destroy(pthread_spinlock_t *lock);            //销毁自旋锁
int pthread_spin_lock(pthread_spinlock_t *lock);               //锁定自旋锁
</code></pre>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁是这样一种锁，它由读锁和写锁两部分组成，读锁是共享的，而写锁是独占的。也就是说：</p>
<ul>
<li>多个读线程可以同时进入临界区，因为临界区内并没有共享数据的更新，所以所有线程都可以正确地工作；</li>
<li>而当有线程试图获取写锁时，如果有读锁，写锁线程会被阻塞，直到所有的读锁都被释放，同时，新的读锁请求也会被阻塞，直到写锁被释放。</li>
</ul>
<p>读写锁的行为有点像游戏服务器停服更新时的做法，发布停服通知后，新登录的用户会被告知服务器正在停服更新，同时服务区会等待一段时间，让当前正在玩的玩家能完成当前正在进行的游戏进程。等所有玩家都下线后，才真正开始执行服务器关闭，更新的操作。</p>
<p>对于更新频率很低的共享数据，使用读写锁代替互斥锁，能 <strong>明显提高只读取临界区数据的线程的并行化水平，提高系统处理效率</strong> 。但是选用读写锁时<br><strong>一定要确保临界区数据确实满足上述访问模式</strong> ，否则，其最终性能表现可能还不如互斥锁。</p>
<p>pthread 库中读写锁相关的接口定义为：</p>
<p>​    </p>
<pre><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, 
        const pthread_rwlockattr_t *restrict attr);         //初始化读写锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);       //销毁读写锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);        //加读锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);        //加写锁
</code></pre>
<h2 id="监听和连接-x2F-分离线程"><a href="#监听和连接-x2F-分离线程" class="headerlink" title="监听和连接&#x2F;分离线程"></a>监听和连接&#x2F;分离线程</h2><p>等同于子进程一样，会被动等待杀死线程。但是不同于子进程由父进程杀死，这里的线程可以指定杀死其他线程。</p>
<pre><code>int pthread_join(pthread_t thread, void **retval);
</code></pre>
<p>进程连接与线程连接 在以下几个方面存在一些区别 ：</p>
<ul>
<li>任何线程都可以<strong>监听一个指定线程的退出</strong>，而不需要是创建该线程的线程；</li>
<li>线程连接函数<strong>只能连接一个指定 ID 的线程</strong>，而不能像进程一样监听任意线程的退出；</li>
<li>如果不想指定监听者，那么线程创建之后可以使用分离函数设置其不需要等待被连接，这种情况下，线程结束之后会被自动清理。</li>
</ul>
<p>设置线程分离的函数为：</p>
<pre><code>int pthread_detach(pthread_t thread);
</code></pre>
<p>处于分离状态的线程，无法被任何线程执行连接获取其状态，也无法再返回到可连接状态。</p>
<h2 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h2><p>我们还可以强制退出线程</p>
<p>比如，很多带 GUI 的应用都会对长时间运行的后台任务 <strong>设置一个取消按钮</strong> ，还有一些服务器进程可能会 <strong>动态调整运行中的工作线程数量</strong> 。这些都<br><strong>可以用线程取消函数来实现</strong> ：</p>
<p>​    </p>
<pre><code>int pthread_cancel(pthread_t thread);
</code></pre>
<p>同时，对退出线程状态和类型的掌控，可以进一步控制它们响应取消请求的处理过程。这两个标志可以通过下面两个函数来设置：</p>
<p>​    </p>
<pre><code>int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
</code></pre>
<p>状态类型分为启用、关闭两种。关闭状态下的线程不可被取消，开启状态下的线程可进一步设置取消类型，在任一点取消，以及在预定的取消点取消。取消点是内核在一些函数实现中埋下的点，这些函数都是有可能造成进程阻塞或触发<br>IO 行为的函数，如 sleep()、wait()、fsync() 等。</p>
<p><strong>合理控制线程的取消行为，是保证数据一致性、逻辑完整性不被破坏的必要手段</strong> 。更多细节可查看系统帮助手册了解。</p>
<h2 id="线程独有数据"><a href="#线程独有数据" class="headerlink" title="线程独有数据"></a>线程独有数据</h2><p>为了保证线程的安全性</p>
<p>创建线程特有数据 API 的函数为：</p>
<p>​    </p>
<pre><code>int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));
</code></pre>
<p>该函数只在主线程或某个线程中执行一次，可以放在 pthread_once() 函数中执行。destructor<br>是一个析构函数，用来创建标识某个线程本地存储的 key。key<br>所对应的内存空间，需在每个线程中具体分享。这里的析构函数注册完成后就是用来在每个线程退出时释放各自内存空间的。</p>
<p>在线程中设置和获取 key 所对应内存空间的函数如下所示：</p>
<p>​    </p>
<pre><code>int pthread_setspecific(pthread_key_t key, const void *value);
void * pthread_getspecific(pthread_key_t key);
</code></pre>
<p>参数 value 可以是一个指向内存区域的指针，也可以是一个标量值，具体选用哪个由线程自己决定。在 Linux 中，最多可定义 1024 个线程特有数据的<br>key 值。如果考虑程序的可移植性，所定义的 key 数量不应超过 128 个。当确实需要更多线程特有数据时，可将多个值放置在一个结构中，从而减少 key<br>的数量。</p>
<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><h2 id="基本函数-1"><a href="#基本函数-1" class="headerlink" title="基本函数"></a>基本函数</h2><p>网络服务器最基本的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//socket，bind，listen，accept</span><br><span class="line">int </span><br><span class="line">socket(int domain, int type, int protocol);   //创建网络套接字</span><br><span class="line">int </span><br><span class="line">bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); //把套接字与一个具体的网络地址绑定</span><br><span class="line">int </span><br><span class="line">listen(int sockfd, int backlog);    //设置指定的套接字为被动监听状态</span><br><span class="line">int </span><br><span class="line">accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);//接受一个连接请求，并为之创建新的套接字</span><br><span class="line"></span><br><span class="line">//read/write</span><br><span class="line">ssize_t </span><br><span class="line">read(int fd, void *buf, size_t count);</span><br><span class="line">ssize_t </span><br><span class="line">write(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure>

<p>最简单的网络服务器：单线程，I&#x2F;O阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define BUFF_SIZE 1024</span><br><span class="line">#define SVR_PORT 6677</span><br><span class="line"></span><br><span class="line">//handle：业务处理逻辑</span><br><span class="line">int doWork(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[BUFF_SIZE];</span><br><span class="line">    int n = read(sockfd, buffer, BUFF_SIZE); //读取对端输入</span><br><span class="line">    int resn;</span><br><span class="line">    char result[BUFF_SIZE];</span><br><span class="line">    //对请求执行处理，把处理结果放在 result，resn 保存结果数据长度</span><br><span class="line">    write(sockfd, result, resn);        //处理结果发送给对端</span><br><span class="line">&#125;</span><br><span class="line">//main</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//socket,bind,listen</span><br><span class="line">    struct sockaddr_in server_addr, client_addr;</span><br><span class="line">    socklen_t clientaddr_len;</span><br><span class="line"></span><br><span class="line">    int listenfd, connfd;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  //创建 TCP 网络套接字</span><br><span class="line"></span><br><span class="line">    bzero(&amp;server_addr, sizeof(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(SVR_PORT);     //设置监听的本地地址和端口</span><br><span class="line">		//套接字与本地地址绑定</span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));   </span><br><span class="line">    listen(listenfd, 20);</span><br><span class="line">    </span><br><span class="line">//accept and handle events</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        clientaddr_len = sizeof(client_addr);</span><br><span class="line">        connfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;clientaddr_len);  //接受连接请求，创建新的连接</span><br><span class="line">        doWork(connfd);      //处理请求</span><br><span class="line">        close(sockfd);       //处理完毕，关闭连接</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多进程模型：改成多进程的并发：一个进程使用一个套接字，I&#x2F;O阻塞时，可以换进程进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pid_t pid = 0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    int connfd = accept(listenfd, ...);</span><br><span class="line">    if( (pid = fork()) == 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        dowork(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更深入优化看I&#x2F;O复用</p>
<p>connect()</p>
<p>send()</p>
<p>recv()</p>
<p>sendto() </p>
<p>recvfrom() </p>
<p> close()</p>
<p>shutdown()</p>
<p>setsockopt()</p>
<p>getsockopt()</p>
<p>getpeername()</p>
<p>gethostname()</p>
<h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><h2 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h2><h1 id="I-x2F-O复用"><a href="#I-x2F-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h1><p>多进程的程切换花销也很大，如果使用多线程，实际经验是开销也挺大，所以应该再优化：使用进程池：复用这些进程来处理多个套接字下的accept（用户）：</p>
<ul>
<li>轮询套接字</li>
<li>I&#x2F;O复用：告诉内核需要监听的事件（套接字，也就是文件），当事件发生（文件接受到新的数据），告诉进程，从而让进程使用这个套接字。</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">//用于操作 fd_set 的宏定义</span><br><span class="line">void FD_CLR(int fd, fd_set *set);         //从 set 中清除 fd</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);       //检查 set 中有没有指定的 fd</span><br><span class="line">void FD_SET(int fd, fd_set *set);         //在 set 中设置 fd</span><br><span class="line">void FD_ZERO(fd_set *set);                //清空 set</span><br></pre></td></tr></table></figure>

<p>要使用 select 函数，首先需要自己准备一个最长为 FD_SETSIZE<br>的文件描述符数组，用于记录所有需要监听的文件描述符，同时要记录这些描述符中数值最大的一个，并把它 +1 传给 select<br>的第一个参数。初始状态下，当只有最早的监听套接字时，这个值就是监听套接字的文件描述符：</p>
<p>​    </p>
<pre><code>int client[FS_SETSIZE];
int maxfd = listenfd;
fd_set init_set, rec_set;
for(int i = 0; i &lt; FS_SETSIZE; i++)
    client[i] = -1;   //用复数表示该位置空闲
FD_ZERO(&amp;init_set);
FD_SET(listenfd, &amp;init_set);

while(1)
&#123;
    rec_set = init_set;
    int nevent = select(maxfd + 1, &amp;rec_set, NULL, NULL, NULL);
    ...
&#125;
</code></pre>
<p>然后，当 select 函数返回时，表示在传入的文件描述符集合中，至少有一个描述符上发生了需要处理的事件，所以，就需要找出是哪个，并依次处理：</p>
<p>​    </p>
<pre><code>if(FD_ISSET(listenfd, &amp;rec_set))
&#123;
    //表示服务器的监听套接字上发生了新的接入事件
    connfd = accept(listenfd, ...);

    //把新创建的描述符加入到监听集合，并记录在 client 数组
    FD_SET(connfd, &amp;init_set);
    if(connfd &gt; maxfd) maxfd = connfd;

    //找一个空位记录新的文件描述符
    for(int i = 0; i &lt; FD_SETSIZE; i++)&#123;
        if(client[i] &lt; 0) &#123;
            client[i] = connfd;
            break;
        &#125;
    &#125;
&#125;

//依次检查还有哪个文件描述符上发生了需要处理的事件
for(ini i = 0;  i &lt; FD_SETSIZE; i++) &#123;
    if(client[i] &lt; 0) continue;   //跳过空位
    int sockfd = client[i];
    if(FD_SET(sockfd, &amp;rec_set)) &#123;
        doWork(sockfd);
    &#125;
&#125;
</code></pre>
<p>select 能同时监听的文件描述符集合，有最大 1024 的数量限制，要修改这个限制，需要修改宏定义 FD_SETSIZE，并重新编译内核。</p>
<p>有这样的限制，是因为在它被设计的那个年代，认为 1024 已经足够大了。Richard Stevens 教授的名著《Unix 网络编程 卷1：联网套接字<br>API》（ <em>Unix Network Programming, Volume 1: The Sockets Networking API</em><br>）中，也有原文说：</p>
<blockquote>
<p>头文件 &lt;sys&#x2F;select.h&gt; 中定义的 FD_SETSIZE 常值是数据类型 fd_set 中的描述符总数，其值通常是<br>1024，不过很少有程序用到那么多的描述符。</p>
</blockquote>
<p>时代在发展，现在的情况已经变成了： <strong>很少有服务器程序只能同时支持不超过 1024 个连接。</strong></p>
<p>在现代，接任 select，担当 I&#x2F;O 复用功能的函数是 poll，它破除了受到宏定义限制的最大连接数限制。其函数定义为：</p>
<p>​    </p>
<pre><code>struct pollfd &#123;
               int   fd;         /* 要监听的文件描述符 */
               short events;     /* 感兴趣的监听事件 */
               short revents;    /* 实际发生的事件 */
           &#125;;

int poll(struct pollfd *fds, nfds_t nfds, int timeout); 
</code></pre>
<p>各参数释义如下：</p>
<ul>
<li>参数 fds 指定要监听的 pollfd 结构的数组；</li>
<li>参数 nfds 说明了被监听的 pollfd 结构的数量；</li>
<li>timeout 则指定超时时间。</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 的使用方式与 select 很像，不过它把要监听的文件描述符数组与 fdset<br>合并在了一个结构中，所以更加方便直观。只要初始时把监听套接字放入监听数组，新连接建立之后再依次向后追加就可以了：</p>
<p>​    </p>
<pre><code>struct pollfd clients[MAX_LIMIT];    //MAX_LIMIT 是自定义的长度限制

clients[0].fd = listenfd;
clients[0].events = POLLRDNORM;   //监听新连接事件
for(int i = 1; i &lt; MAX_LIMIT; i++) &#123;
    clients[i].fd = -1;           //把其他的文件描述符标记为无效
&#125;
int maxIdx = 1;

while(1) &#123;
    int nevent = poll(clients, maxIdx, 0x8FFFFFFF);
    ...
&#125;
</code></pre>
<p>然后，在收到任何事件通知，从 poll<br>调用返回后，需要依次检查每个事件。如果是发生在服务器监听套接字上的连接请求，就建立新的套接字，并添加到监听数组中；其他套接字上的事件，就执行消息读取，并依次处理：</p>
<p>​    </p>
<pre><code>if(clients[0].revent &amp; POLLRDNORM) &#123;
    //处理新连接请求
    int connfd = accept(listenfd, ...);
    //找个空闲的位置，保存新创建的套接字
    for(int i = 1; i &lt; MAX_LIMIT; i++) &#123;
        if(clients[i].fd &lt; 0) &#123;
            clients[i].fd = connfd;
            clients[i].events = POLLRDNORM;
            if(i &gt; maxIdx) maxIdx = i;
            break;
        &#125;
    &#125;
&#125;

for(int i = 1; i &lt; maxIdx; i++) &#123;
    if(clients[i].fd &lt; 0) continue;

    if(clients[i].revents &amp; POLLRDNORM) &#123;
        doWork(clients[i].fd);
    &#125;
&#125;
</code></pre>
<p>上面的程序并没有处理客户端连接的关闭事件，因为本节课重点关注的是整个处理流程中影响性能的方面，所以，只关注正常业务的处理流程。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>每当内核通知进程时候，返回文件描述符集合，因此进程对于select和poll会轮询套接字，因此我们需要直接让内核告诉进程哪个套接字（fd）需要处理。</p>
<pre><code>int epoll_create(int size);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre>
<p>使用 epoll 编写的基本网络服务器程序的实例为：</p>
<p>​    </p>
<pre><code>#define MAX_EVENTS 50
struct epoll_event ev, events[MAX_EVENTS];
int listen_sock, conn_sock, nfds, epollfd;

epollfd = epoll_create(100);
if (epollfd == -1) &#123;
    exit(EXIT_FAILURE);
&#125;

ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123;
    exit(EXIT_FAILURE);
&#125;

for (;;) &#123;
    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
    if (nfds == -1) &#123;
        exit(EXIT_FAILURE);
    &#125;

    for (n = 0; n &lt; nfds; ++n) &#123;
        if (events[n].data.fd == listen_sock) &#123;
            conn_sock = accept(listen_sock, ...);
            if (conn_sock == -1) &#123;
                exit(EXIT_FAILURE);
            &#125;
            setnonblocking(conn_sock);
            ev.events = EPOLLIN | EPOLLET;
            ev.data.fd = conn_sock;
            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                               &amp;ev) == -1) &#123;
                exit(EXIT_FAILURE);
            &#125;
        &#125; else &#123;
            doWork(events[n].data.fd);
        &#125;
    &#125;
&#125;
</code></pre>
<p>可以看到，epoll_wait() 的返回会指示发生了几个需要处理的事件，并且只有需要引用处理的事件才会被写入到 events<br>数组内。这就有效地避免了每次发生事件的时候，都要依次遍历所有监听的文件描述符，以确定是哪个上面发生了什么事件。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1].极客时间 - 宇文拓 - 攻克Linux系统编程</p>
<p>[2].帅地-面试攻略-linux</p>
<p>[3].哈工大-linux 0.11实验</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>L9：锁</title>
    <url>/2024/03/08/L9%EF%BC%9A%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="为什么要谈论锁？"><a href="#为什么要谈论锁？" class="headerlink" title="为什么要谈论锁？"></a>为什么要谈论锁？</h1><p>  流水线指令的<strong>并行</strong>以加速<br>  所以内核必须处理并行系统调用<br>  从而并行访问内核数据（缓冲区缓存、进程等）<br>  锁有助于<strong>协调共享数据</strong></p>
<span id="more"></span>

<h1 id="思考锁的问题"><a href="#思考锁的问题" class="headerlink" title="思考锁的问题"></a>思考锁的问题</h1><h2 id="锁抽象："><a href="#锁抽象：" class="headerlink" title="锁抽象："></a>锁抽象：</h2><p>  锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire(lock)</span><br><span class="line">    x = x + 1 -- “临界区”，即共享区的修改，需要用锁变为为原子操作</span><br><span class="line">release(lock)</span><br></pre></td></tr></table></figure>

<p>  锁本身就是一个对象<br>  如果多个线程调用acquire(l)<br>    只有一个会执行临界区<br>    其他人将等待 release() – “block”<br>  一个程序通常有很多数据，很多锁<br>    如果不同的线程使用不同的数据，<br>    那么他们可能持有不同的锁，<br>    所以他们可以并行执行——完成更多的工作。<br>  请注意，锁 lock 没有专门绑定到数据 x<br>    程序员有一个线程&#x2F;进程通信计划：每当需要数据x修改时候，查看锁</p>
<p>决定<strong>何时需要锁</strong>的保守规则：<br>  任何时候两个线程使用一个内存位置，并且至少一个是写<br>  除非您持有正确的锁，否则不要接触共享数据！<br>  （太严格：程序逻辑有时可能会排除共享；无锁）<br>  （太松散：printf()；并不总是简单的锁&#x2F;数据对应）</p>
<p>可以自动锁定吗？<br>  也许该语言可以将锁与每个数据对象相关联<br>    编译器在每次使用时添加获取&#x2F;释放<br>    这样的想法很省事！<br>  这个想法往往过于僵化：</p>
<h3 id="1-确定何时需要锁："><a href="#1-确定何时需要锁：" class="headerlink" title="1.确定何时需要锁："></a>1.确定何时需要锁：</h3><p><strong>就是确定何时需要操作数据的原子性</strong></p>
<p>​    rename（“d1&#x2F;x”，“d2&#x2F;y”）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock d1，erase x，unlock d1</span><br><span class="line">lock d2，add y，unlock d2</span><br></pre></td></tr></table></figure>

<p>​    问题：该文件暂时不存在！<br>​      rename() 应该是原子的<br>​        其他系统调用应该在之前或之后看到，而不是在两者之间<br>​      否则写程序太难了<br>​    我们需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock d1 ; lock d2</span><br><span class="line">      erase x，add y</span><br><span class="line">unlock d2；unlcok d1</span><br></pre></td></tr></table></figure>

<p>  也就是说，程序员经常需要显式控制<br>    持有锁的代码区域<br>    为了隐藏尴尬的中间状态：保证原子性</p>
<p>  锁有助于<strong>避免丢失更新</strong><br>  锁帮助你创建原子多步操作——隐藏中间状态<br>  锁帮助操作维护数据结构的不变量<br>    假设不变量在操作开始时为真<br>    操作使用锁来隐藏对不变量的临时违反<br>    操作在释放锁之前恢复不变量</p>
<h3 id="2-确定保证没有死锁："><a href="#2-确定保证没有死锁：" class="headerlink" title="2.确定保证没有死锁："></a>2.确定保证没有死锁：</h3><p>所谓死锁就是多（次）锁循环等待</p>
<p>问题：死锁<br>  通知 rename() 持有两个锁<br>  如果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">core A                 core B</span><br><span class="line">renmae(d1/x, d2/y)     rename(d2/a, d1/b)</span><br><span class="line">lock d1                lock d2</span><br><span class="line">lock d2 ...            lock d1 ...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，并行的操作前提下，锁只能保证操作原子性（或者说临界区的互斥），但是这里的core A和core B互相等待，不仅如此，如果在临界区，也可以出现自己获取自己拥有的锁，那么同样也会导致循环等待。  </p>
<p>解决方案：<br>    程序员计算出所有锁的顺序：比如使用优先队列<br>    所有代码都必须按该顺序获取锁<br>    即预测锁、排序、获取——复杂！</p>
<h2 id="锁与模块化"><a href="#锁与模块化" class="headerlink" title="锁与模块化"></a>锁与模块化</h2><p>  锁使得难以隐藏模块内的细节<br>  为了避免死锁，我需要知道我调用的函数获取的锁<br>  我可能需要在<strong>调用之前获取它们</strong>，即使我不使用它们<br>  即<strong>锁通常不是单个模块的私有业务</strong></p>
<p>如何考虑将锁放在哪里？<br>  这是新代码的简单计划</p>
<ol>
<li><p>串口执行下写模块正确<br>即假设单 CPU，单线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void insert（）&#123;</span><br><span class="line">	e-&gt;next = l; </span><br><span class="line">	l = e; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果并行执行则不正确</p>
</li>
</ol>
<p>2.为保证串行执行添加锁<br>     由于获取&#x2F;释放允许一次仅由一个 CPU 执行<br>    要点：</p>
<p>程序员更容易推理串行代码<br>    尽管具有并行性，锁仍可能导致您的串行代码正确</p>
<p>性能呢？<br>  毕竟，我们可能将锁作为获得并行加速的计划的一部分，所以是<strong>并行不悖</strong></p>
<h2 id="锁和并行"><a href="#锁和并行" class="headerlink" title="锁和并行"></a>锁和并行</h2><p>  锁<em>防止</em>并行执行<br>  为了获得并行性，你经常需要拆分数据和锁<br>    以某种方式让每个核心使用不同的数据和不同的锁<br>    “细粒度锁”<br>  选择数据&#x2F;锁的<strong>最佳分割</strong>是一个设计挑战<br>    整个ph.c表；每个表[]行；每个条目<br>    整个FS；目录&#x2F;文件；磁盘块<br>    整个内核；每个子系统；每个对象<br>  您可能需要重新设计代码以使其并行运行<br>    示例：将单个空闲内存列表分解为每核空闲列表<br>      如果线程在锁定单个空闲列表上等待很多，则有帮助<br>    这种重写可能需要大量的工作！</p>
<p>锁粒度建议<br>  从大锁开始，例如保护整个模块的一把锁<br>    更少的死锁，因为更少的机会持有两个锁<br>    不需要对不变量&#x2F;原子性进行推理<br>  衡量是否有问题<br>    大锁通常就足够了——也许花在那个模块上的时间很少<br>  仅在必须时才重新设计细粒度锁定</p>
<p>让我们看看 xv6 中的锁定。</p>
<h1 id="锁的典型用途：ide-c"><a href="#锁的典型用途：ide-c" class="headerlink" title="锁的典型用途：ide.c"></a>锁的典型用途：ide.c</h1><p>  许多 O&#x2F;S 的设备驱动程序安排的典型<br>  图表：<br>    用户进程、内核、FS、iderw、追加到磁盘队列<br>    IDE磁盘硬件<br>    标识符<br>  并发源：进程、中断</p>
<p>  ide.c 中只有一个锁：idelock——相当粗粒度</p>
<p>  iderw() – idelock 保护什么？<br>    1. 出队操作无竞争<br>        2. 如果队列不为空，IDE h&#x2F;w 正在执行队列头<br>        3.没有对IDE寄存器的并发访问<br>      ideintr() – 中断处理程序<br>        获取锁——可能必须在中断级别等待！<br>        使用 idequeue (1)<br>        将下一个排队的请求交给 IDE h&#x2F;w (2)<br>        接触 IDE 硬件寄存器 (3)</p>
<h1 id="如何实现锁？"><a href="#如何实现锁？" class="headerlink" title="如何实现锁？"></a>如何实现锁？</h1><p>  为什么不：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123; int locked; &#125;</span><br><span class="line">    acquire（l）&#123;</span><br><span class="line">      while（1）&#123;</span><br><span class="line">        if(l-&gt;locked == 0)&#123; // A</span><br><span class="line">          l-&gt;clocked= 1; // B</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  oops：A 线和 B 之间的原子性问题，如果他们不原子，那么我们从指令角度假设以下情况：CPU得到了lock的0，但是还未修改为1，这将导致同时另一个线程得到了0，那么他们各自将会将locked置为1，因此临界区将会允许两个线程进入，从而破坏临界区的互斥原则。</p>
<p>那么，我们如何原子地做 A 和 B？</p>
<p>硬件提供了原子交换指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov $1, %eax</span><br><span class="line">xchg %eax, addr</span><br><span class="line">或者</span><br><span class="line">xchg $1, addr</span><br><span class="line"></span><br><span class="line">1.这样有什么用呢？关键在于这个交换指令，我们先想想需要原子的是哪些操作？</span><br><span class="line">	获得锁，根据情况等待或者锁定</span><br><span class="line">对于等待而言，和获得锁一起进行原子并没有必要，是可以并行不悖，问题出在锁定上：假如我们使用xchg，那么1的交换就会导致</span><br><span class="line">	交换1和1:等待，很好</span><br><span class="line">	交换0和1:原子修改了locked为1，非常不错</span><br><span class="line">2.等待的判断需要原子吗？不需要，因为锁的获取和修改我们发现：也是临界区，等待并不修改临界区</span><br><span class="line">3.给出的汇编指令为什么可以有两种？因为mov $1这样的操作并不会出问题</span><br><span class="line">总之，想想有没可能出问题，再决定锁的需要和实现，这很重要</span><br></pre></td></tr></table></figure>

<p>  在硬件中执行此操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">globle lock addr（其他内核无法使用）</span><br><span class="line">    temp= *addr</span><br><span class="line">    *addr = %eax</span><br><span class="line">    %eax = temp</span><br><span class="line">unlock addr</span><br></pre></td></tr></table></figure>

<p>  x86 h&#x2F;w 提供了锁定内存位置的概念<br>    不同的 CPU 有不同的实现<br>    图：内核、总线、RAM、锁<br>    所以我们把问题推到了硬件上<br>    h&#x2F;w 在缓存行或整个总线的粒度上实现<br>  内存锁强制并发 xchg 一次运行一个，而不是交错</p>
<p>现在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire（l）&#123;</span><br><span class="line">    while（xchg(&amp;l-&gt;locked, 1) == 0）&#123;&#125;//wait or not</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  如果 l-&gt;locked 已经是 1，则 xchg 设置为 1（再次），返回 1，<br>    并且循环继续旋转<br>  如果 l-&gt;locked 为 0，则最多有一个 xchg 会看到 0；它会设置<br>    它为 1 并返回 0；其他 xchgs 将返回 1<br>  这是一个“自旋锁”，因为在获取循环中等待内核“自旋”</p>
<h2 id="看-xv6-自旋锁实现"><a href="#看-xv6-自旋锁实现" class="headerlink" title="看 xv6 自旋锁实现"></a>看 xv6 自旋锁实现</h2><p>  spinlock.h——你可以看到结构锁的“锁定”成员<br>  spinlock.c&#x2F;acquire():<br>    参见 while-loop 和 xchg() 调用<br>    pushcli() 是关于什么的？<br>      为什么要禁用中断？<br>  release（）：<br>    设置 lk-&gt;locked &#x3D; 0<br>    并重新启用中断</p>
<p>详细信息：内存读&#x2F;写排序<br>  假设两个内核使用一个锁来保护一个计数器，x<br>  我们有一个简单的锁实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心 A：	  				核心 B：</span><br><span class="line">locked = 1</span><br><span class="line">x = x + 1   			while（locked == 1）</span><br><span class="line">locked = 0 ...end</span><br><span class="line">                  locked= 1</span><br><span class="line">                  x = x + 1</span><br><span class="line">                  locked = 0</span><br></pre></td></tr></table></figure>

<p> 然而我们的编译器和 CPU 重新排序内存访问<br>    即它们不遵守源程序的内存引用顺序<br>    例如，编译器可能会为核心 A 生成此代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locked = 1</span><br><span class="line">locked = 0</span><br><span class="line">x = x + 1</span><br><span class="line"></span><br><span class="line">将增量移动到临界区外！！！</span><br><span class="line">1.为什么这么干，在其他方面会有好处吗？有，假如你很快就要再次修改这个地址（事实上确实这样），那么我们可以优化为修改后不放入内存，等待下次访问，加速访问（就像某种缓存和回写）。</span><br><span class="line">2.那么有什么办法禁止呢？c代码使用同步函数：sync_synchronize()，汇编代码使用asm关键字来防止这种优化</span><br></pre></td></tr></table></figure>

<p>  release() 对 sync_synchronize() 的调用防止重新排序<br>    编译器不会将内存引用移过 sync_synchronize()<br>    并且（可能）发出“内存屏障”指令来告诉 CPU<br>  Acquire() 对 xchg() 的调用具有类似的效果：<br>    英特尔承诺不会重新订购过去的 xchg 指令<br>    x86.h 中的一些垃圾 xchg() 告诉 C 编译器不要删除或重新排序<br>      （volatile asm 表示不要删除，“m”表示不重新排序）<br>  如果使用锁，则无需了解内存排序规则<br>    如果您想编写异国情调的“无锁”代码，则需要它们</p>
<h2 id="为什么使用自旋锁？"><a href="#为什么使用自旋锁？" class="headerlink" title="为什么使用自旋锁？"></a>为什么使用自旋锁？</h2><p>  他们在等待时不会浪费CPU吗？<br>  为什么不放弃CPU并切换到另一个进程，让它运行？<br>  如果持有线程需要运行怎么办；不应该等待线程让出 CPU 吗？<br>  <strong>自旋锁指南</strong>：<br>    保持自旋锁很短的时间<br>    持有自旋锁时不要让出 CPU<br>  系统通常为较长的关键部分提供“<strong>阻塞</strong>”锁：这将会是后面介绍的协调（coordination），通过sleep和wakeup来完成<br>    等待线程产生 CPU<br>    但管理费用通常更高<br>    稍后你会看到一些 xv6 阻塞方案</p>
<h2 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h2><p>  如果没有必要，请不要随意指定共享区：因为会在并行模式下导致问题<br>  从几个粗粒度的锁开始<br>  检测你的代码——哪些锁阻止了并行性？<br>  仅在并行性能需要时才使用细粒度锁<br>  使用检测器来检测效果</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L8 ：系统调用、中断和异常</title>
    <url>/2024/03/08/L8%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="L-8-：系统调用、中断和异常"><a href="#L-8-：系统调用、中断和异常" class="headerlink" title="L 8 ：系统调用、中断和异常"></a>L 8 ：系统调用、中断和异常</h1><p>以下内容来自于作业，所以记录没有太多必要，个人感觉有必要的具体讲解在lab3 partB最后，然后跟着做实验即可。</p>
<p>给出课程一些额外的内容和想法</p>
<span id="more"></span>

<h2 id="一些中断处理设计技巧"><a href="#一些中断处理设计技巧" class="headerlink" title="一些中断处理设计技巧"></a>一些中断处理设计技巧</h2><ul>
<li>中断过去相对较快；现在他们很慢<br>旧方法：每个事件都会导致中断，简单的硬件，智能软件<br>新方法：h&#x2F;w 在中断前完成大量工作：比如保存现场</li>
<li>中断需要一微秒的数量级<br>比如保存&#x2F;恢复状态<br>在缓存未命中的例子中</li>
<li>一些设备生成事件的速度超过每微秒一个<br>例如，千兆以太网可以传送 150 万个小数据包&#x2F;秒<br>如果事件总是在等待，则无需一直提醒软件</li>
<li>轮询是定期处理设备，中断是给信号才处理设备</li>
<li>低速率设备的中断，例如键盘<br>不断轮询会浪费 CPU<br>*自动在轮询和中断之间切换<br>速率低时中断（轮询会浪费 CPU 周期）<br>速率高时轮询（中断会浪费 CPU 周期）</li>
<li>更快地将中断返回到用户空间<br>能否直接交付给用户，无需内核干预？将中断程序设置为用户程序<br>或者通过内核更快的转发路径？</li>
</ul>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L7:使用虚拟内存</title>
    <url>/2024/03/08/L7%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="L7：使用虚拟内存"><a href="#L7：使用虚拟内存" class="headerlink" title="L7：使用虚拟内存"></a>L7：使用虚拟内存</h1><ul>
<li><p>计划：你可以用 vm 做的很酷的事情</p>
<ul>
<li>更好的性能&#x2F;效率<br>例如，一页填零<br>  例如，写时复制fork<span id="more"></span></li>
<li>新功能<br>例如，内存映射文件</li>
<li>JOS 和虚拟机</li>
<li>本次讲座可能会为最后一个实验室（最终项目）产生想法</li>
</ul>
</li>
<li><p>虚拟内存：几个视图</p>
<ul>
<li>主要目的：隔离<br>每个进程都有自己的地址空间</li>
<li>虚拟内存提供了一个间接级别<br>为内核提供了做很酷的事情的机会</li>
</ul>
</li>
<li><p>懒惰&#x2F;按需页面分配</p>
<ul>
<li>sbrk()<br>分配虚拟内存，但是只在实际需要的时候page fault，分配物理内存并建立映射<ul>
<li>page fault：一种中断<br>xv6 内存布局讨论<br>用户虚拟地址从零开始<br>  当然用户 va 0 映射到每个进程的不同 pa<br>2GB 用于用户堆连续增长<br>  但不需要有连续的物理内存—-没有碎片问题<br>  内核和用户映射—-易于切换系统调用、中断<br>  内核映射到所有进程的同一位置<br>  简化进程之间的切换<br>  内核易于读写用户内存<br>使用用户地址，例如 sys 调用参数<br>  内核易于读写物理内存<br>pa x 映射到 va x+0x80000000<br>我们很快就会在操作页表时看到这一个</li>
</ul>
</li>
</ul>
</li>
<li><p>退后一步：班级视角</p>
<ul>
<li>没有一种设计操作系统的最佳方式<br>许多操作系统使用 VM，但是可以不用</li>
<li>Xv6 和 JOS 展示了操作系统设计的例子<br>他们缺乏复杂设计的许多特征<br>事实上，与真正的操作系统相比，它们相当蹩脚<ul>
<li>我们的目标：教您关键思想，以便您可以推断<br>Xv6 和 JOS 是暴露关键思想的最小设计<br>你应该能够让他们变得更好<br>您应该能够深入了解 Linux 并找到自己的方式</li>
</ul>
</li>
</ul>
</li>
<li><p>保护页面以防止堆栈溢出</p>
<ul>
<li>在用户堆栈下方放置一个非映射页面：guard page</li>
<li>如果堆栈溢出，应用程序将看到页面错误</li>
</ul>
</li>
<li><p>一页填零</p>
<ul>
<li>内核经常用零填充一个页面</li>
<li>想法：memset函数设置页面为零<br>当内核需要零填充页面时映射该页面写时复制：即memset依然只是对虚拟内存操作<br>在写入时复制页面并将其映射到应用程序地址空间中的读&#x2F;写</li>
</ul>
</li>
<li><p>在 xv6 中共享内核页表<br>  kvmalloc() 为每个进程的内核页表分配新页<br>  但所有进程都有相同的内核页表</p>
</li>
<li><p>写时复制fork<br>  xv6 fork 从父级复制所有页面（参见 fork()）</p>
<ul>
<li>想法：在父子之间共享地址空间<br>修改 fork() 以映射页面 copy-on-write（在 PTE 和 PDE 中使用额外的可用系统位）<br>在页面错误时，复制页面并将其映射为读&#x2F;写</li>
</ul>
</li>
<li><p>需求分页</p>
<ul>
<li>观察：exec 将完整文件加载到内存中（参见 exec.c）<br>这样做需要时间（例如，文件存储在慢速磁盘上）<br>不必要：可能不会使用整个文件</li>
<li>想法：按需从文件加载页面<br>没必要分配页表条目，但按需标记它们<br>出错时，从文件中读入页面并更新页表条目</li>
<li>挑战：文件大于物理内存（见下一个想法）</li>
</ul>
</li>
<li><p>使用比物理内存大的虚拟内存<br>理由：应用程序可能需要比物理内存更多的内存</p>
<ul>
<li>想法：在磁盘上存储地址空间中不常用的部分<br>地址空间的页入页和页出页，这是一个对程序员透明的机制</li>
<li>当工作集适合物理内存时工作</li>
</ul>
</li>
<li><p>内存映射文件</p>
<ul>
<li>想法：允许使用加载和存储访问文件<br>可以轻松读写文件的一部分<br>例如，不必使用 lseek 系统调用更改偏移量，而是直接对虚拟内存修改，然后write系统调用和buffer一次性写文件</li>
<li>按需调入文件页面<br>当内存已满时，将不经常使用的文件页面调出：LRU</li>
</ul>
</li>
<li><p>共享虚拟内存</p>
<ul>
<li>想法：允许不同机器上的进程共享虚拟内存<br>给人一种通过网络共享物理内存的错觉</li>
<li>复制只读的页面：多个虚拟映射同一个物理</li>
<li>在写入时使副本无效</li>
</ul>
</li>
<li><p>JOS 和虚拟内存</p>
<ul>
<li><p>UVPT 技巧（实验 4）<strong>（看本目录下《JOS虚拟内存布局》）</strong><br>在 0x3BD 处递归映射 PD<br>  PD的虚拟地址为(0x3BD&lt;&lt;22)|(0x3BD&lt;&lt;12)<br>如果我们想找到虚拟页面 n 的 pte，计算<br>  pde_t uvpt[n]，其中 uvpt 是 (0x3BD &lt;&lt; 22)<br>&#x3D; uvpt + n * 4（因为 pdt 是一个词）<br>  &#x3D; (0x3BD &lt;&lt; 22) | (n 的前 10 位) | （n 的底部 10 位）&lt;&lt; 2<br>  &#x3D; 10 | 10 | 12<br>例如，uvpt[0] 是地址 (0x3BD &lt;&lt; 22)，按照指针给我们<br>页目录中的第一个条目，它指向第一个页表，它<br>我们用 0 索引，这给了我们 pte 0</p>
<p>这比 pgdirwalk() 更简单，但是实际模拟的时候我们仍然需要走页目录和页表。不过这提供了虚拟页表和物理的方便映射：因为只需要偏移。</p>
</li>
<li><p>用户级写时复制叉（lab4）<br>JOS 将页面错误传播到用户空间<br>用户程序可以玩与内核类似的 VM 技巧！<br>你会做用户级的写时复制叉</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L6：虚拟内存</title>
    <url>/2024/03/08/L6%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="L6：虚拟内存"><a href="#L6：虚拟内存" class="headerlink" title="L6：虚拟内存"></a>L6：虚拟内存</h1><h2 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h2><ul>
<li><p>今天的问题：<br>假设shell有一个错误：有时它会写入一个随机内存地址，我们如何防止它破坏内核？以及破坏其他进程？<span id="more"></span></p>
</li>
<li><p>我们想要隔离的地址空间<br>  1.每个进程都有自己的内存<br>2.它可以读写自己的内存<br>3.它不能读或写任何其他东西<br>想一想：<br>  如何在一个物理内存上复用多个内存？<br>同时保持内存之间的隔离</p>
</li>
<li><p>xv6 和 JOS 主要使用 x86 的分页硬件来实现隔离</p>
</li>
<li><p>分页为寻址提供了一个间接级别<br>CPU -&gt; MMU -&gt; RAM<br>VA PA<br>s&#x2F;w 只能 ld&#x2F;st 到虚拟地址，而不是物理地址<br>内核告诉 MMU 如何将每个虚拟地址映射到物理地址<br>  MMU 本质上有一个表，由 va 索引，产生 pa<br>  称为“页表”<br>MMU 可以限制用户代码可以使用的虚拟地址</p>
</li>
<li><p>x86 映射 4 KB “页面”<br>并对齐 - 从 4 KB 边界开始<br>因此页表索引是 VA 的前 20 位</p>
</li>
</ul>
<p>*页表条目（PTE）中有什么？<br>  见<a href="x86_translation_and_registers.pdf">讲义</a><br>  前 20 位是物理地址的前 20 位<br>    “物理页码”<br>    MMU 用 PPN 取代前 20 名 VA<br>  低 12 位是标志<br>    存在、可写等</p>
<ul>
<li><p>页表存储在哪里？<br>在 RAM 中——MMU 加载（和存储）PTE<br>o&#x2F;s 可以读&#x2F;写 PTE</p>
</li>
<li><p>页表只是一个 PTE 数组是否合理？<br>它有多大？<br>2^20 是一百万<br>每个条目 32 位<br>4 MB 用于整页表——在早期机器上相当大<br>小程序会浪费大量内存！<br>  你只需要几百页的映射<br>  所以其余的百万个条目将在那里但不需要</p>
</li>
<li><p>x86 使用“两级页表”来节省空间<br>图表<br>RAM 中的 PTE 页<br>RAM 中的页目录 (PD)<br>PDE 还包含 20 位 PPN——1024 个 PTE 指向的页面<br>1024 个 PDE 指向 PTE 页<br>  每个 PTE 页面有 1024 个 PTE——所以总共 1024*1024 个 PTE<br>PD 条目可能无效<br>  那些 PTE 页面不需要存在<br>  所以小地址空间的页表可以很小</p>
</li>
<li><p>mmu 如何知道页表在 RAM 中的位置？<br>%cr3 保存 PD 的 物理 地址<br>PD 持有 PTE 页面的 物理 地址<br>它们可以在 RAM 中的任何位置——不必是连续的</p>
</li>
<li><p>x86 分页硬件如何转换 va？<br>需要找到合适的 PTE<br>%cr3 指向 PD 的 PA<br>前 10 位索引 PD 以获得 PT 的 PA<br>下一个 10 位索引 PT 以获得 PTE<br>PTE 的 PPN + VA 的低 12</p>
</li>
<li><p>PTE 中的标志<br>P、W、U<br>xv6 使用 U 来禁止用户使用内核内存</p>
</li>
<li><p>如果 P 位未设置怎么办？或存储和 W 位未设置？<br>“页面错误”<br>CPU 保存寄存器，强制转移到内核<br>xv6 源中的 trap.c<br>内核只会产生错误，杀死进程<br>或者内核可以安装一个PTE，恢复进程<br>  例如在从磁盘加载内存页面之后</p>
</li>
<li><p>问：为什么是映射而不是例如基&#x2F;绑定？<br>间接允许分页硬件解决许多问题<br>例如避免碎片化<br>例如写时复制叉<br>例如懒惰分配</p>
</li>
<li><p>问：为什么在内核中使用虚拟内存？<br>为用户进程提供页表显然是件好事<br>但是为什么有一个内核页表呢？<br>  内核可以只使用物理地址运行吗？<br>答案：是<br>  Singularity 是一个使用 phys 地址的示例内核<br>但是，大多数标准内核确实使用虚拟地址？<br>为什么标准内核会这样做？</p>
<ul>
<li>好处：可以方便内核使用页表&#x2F;页目录用户地址<br>考虑即使是内核代码读写，那么硬件mmu也会对其进行地址转换，那么访问页表的虚拟地址的传入就非常有用，比如系统调用的时候<br>但是，这可能是个坏主意：内核&#x2F;应用程序之间的隔离不佳</li>
<li>好处：内核必须在各种硬件上运行<br>它们可能有不同的物理内存布局</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L5：隔离机制</title>
    <url>/2024/03/08/L5%EF%BC%9A%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>



<h1 id="第五讲：隔离机制"><a href="#第五讲：隔离机制" class="headerlink" title="第五讲：隔离机制"></a>第五讲：隔离机制</h1><h2 id="课程总览"><a href="#课程总览" class="headerlink" title="课程总览"></a>课程总览</h2><p>  用户&#x2F;内核隔离，用户&#x2F;用户隔离<br>  xv6 系统调用作为案例研究</p>
<span id="more"></span>

<h2 id="用户-x2F-内核隔离，用户-x2F-用户隔离"><a href="#用户-x2F-内核隔离，用户-x2F-用户隔离" class="headerlink" title="用户&#x2F;内核隔离，用户&#x2F;用户隔离"></a>用户&#x2F;内核隔离，用户&#x2F;用户隔离</h2><ul>
<li><p>如何选择内核的整体形式？<br>许多可能的答案！<br>一种极端：<br>  只是一个设备驱动程序库，与应用程序链接<br>  直接在硬件上运行应用程序<br>  快速灵活地用于单一用途的设备<br>  但通常在一台计算机上执行多项任务</p>
</li>
<li><p>多项任务推动关键要求：<br>多路复用<br>隔离<br>通信</p>
</li>
<li><p>有用的方法：抽象资源而不是原始硬件<br>1.文件系统，而不是原始磁盘<br>2.进程，而不是原始 CPU&#x2F;内存<br>3.TCP 连接，而不是以太网数据包</p>
</li>
<li><p>抽象通常更容易隔离和共享<br>  例如程序只会看到一个私有 CPU，不需要考虑多路复用CPU</p>
</li>
<li><p>隔离通常是最严格的要求。</p>
</li>
<li><p>什么是隔离？<br>1.强制分离以控制故障的影响<br>进程是通常的隔离单元</p>
</li>
<li><p>隔离目的：</p>
<p>1.防止进程 X 破坏或监视进程 Y<br>2.r&#x2F;w 内存，使用 100% 的 CPU，更改 FD，&amp;c<br>3.防止进程干扰操作系统<br>4.面对恶意和错误：一个糟糕的进程可能会试图欺骗硬件或内核</p>
</li>
<li><p>内核使用<strong>硬件机制</strong>作为进程隔离的一部分：<br>用户&#x2F;内核模式标志<br>虚拟地址空间<br>分时多路复用CPU<br>系统调用接口</p>
</li>
<li><p>硬件用户&#x2F;内核模式标志<br>控制指令是否可以访问特权硬件？<br>在 x86 上称为 CPL，%cs 寄存器的底部两位<br>  CPL&#x3D;0 – 内核模式 – 特权<br>  CPL&#x3D;3 – 用户模式 – 无权限</p>
</li>
<li><p>x86 CPL 保护许多与隔离相关的处理器寄存器<br>  I&#x2F;O 端口访问<br>  控制寄存器访问（eflags、%cs4、…）<br>包括 %cs 本身<br>  影响内存访问权限，但间接影响<br>  内核必须正确设置所有这些<br>每个微处理器都有某种用户&#x2F;内核标志</p>
</li>
<li><p>如何进行系统调用——切换CPL<br>问：对于用户程序进行系统调用这样的设计是否合适：<br>  设置 CPL&#x3D;0<br>  jmp sys_open<br>  不合适：CPL&#x3D;0 的用户指定指令，破坏用户态和内核态的隔离<br>问：如何设置 CPL&#x3D;0 的组合指令，<br>  但是<em>需要</em>立即跳转到内核中的某个地方？<br>  不行：用户可能会跳到内核中并破坏系统<br>x86 的设计：<br>  只有几个允许的内核入口点（“中断向量”）<br>  INT 指令设置 CPL&#x3D;0 ：提升权限并跳转到一个入口点<br>  但用户代码不能以其他方式修改 CPL 或跳转到内核中的任何其他地方<br>系统调用返回在返回用户代码之前设置 CPL&#x3D;3：这也是一个组合指令（不能单独设置CPL和jmp）</p>
</li>
<li><p>用户与内核的定义需要明确的概念<br>CPL&#x3D;3 并执行用户代码<br>或 CPL&#x3D;0 并从内核代码的入口点执行<br>而不是：<br>  CPL&#x3D;0 并执行用户代码<br>  CPL&#x3D;0 并在用户喜欢的内核中的任何地方执行</p>
</li>
<li><p>如何隔离进程内存？<br>想法：“虚拟地址空间”<br>给每个进程一些它可以访问的内存<br>  对于它的代码、变量、堆、堆栈<br>阻止它访问其他内存（内核或其他进程）</p>
</li>
<li><p>如何创建隔离的地址空间？<br>xv6 在内存管理单元 (MMU) 中使用 x86“分页硬件”<br>MMU 翻译（或“映射”）程序发出的每个地址<br>  CPU -&gt; MMU -&gt; RAM<br>      |<br>   页表<br>  VA -&gt; PA<br>  MMU 翻译所有内存引用：用户和内核。内核也要页表翻译（防小人也防君子？实际第一次加载内核代码时候ELF给定死了高地址，所以保证虚拟空间分布理论，内核也需要页表翻译）（不同的进程恒等映射公有部分内核地址：虚拟地址进程相同，物理地址更是相同）、指令和数据<br>  指令仅使用 VA，从不使用 PA</p>
</li>
<li><p>内核为每个进程设置不同的页表：一般都会有多级页表：PTD&#x2F;PTE来节省内存问题。我们在GDT中，通过CR3的偏移来从页表结构进入进程私有的PTD位置，通过各个划分的虚拟地址作为偏移，进行多级跳转，最终得到物理页地址，和页内偏移一起合成完整的物理地址，当然为了加速访问我们也可以有TLB缓存一部分页表<br>  每个进程的页表只允许访问该进程的 RAM（SRAM&#x2F;DRAM）</p>
</li>
</ul>
<h2 id="xv6系统调用实现"><a href="#xv6系统调用实现" class="headerlink" title="xv6系统调用实现"></a>xv6系统调用实现</h2><h3 id="系统调用进入内核"><a href="#系统调用进入内核" class="headerlink" title="系统调用进入内核"></a>系统调用进入内核</h3><ul>
<li>xv6 进程&#x2F;堆栈图：<br>  用户进程；内核线程<br>  用户堆栈；内核栈<br>  两种机制：<br>在用户&#x2F;内核之间切换<br>在内核线程之间切换<br>  trapframe<br>  内核函数调用…<br>  结构上下文（内核态&#x2F;用户态）</li>
</ul>
<ul>
<li>简化的 xv6 用户&#x2F;内核虚拟地址空间设置<br>FFFFFFFF：<br>      …内核中进程私有和公有部分<br>80000000：内核<br>      用户堆栈<br>      用户数据<br>00000000：用户说明<br>内核将 MMU 配置为仅允许用户代码访问属于用户的下半部分：通过特权级CPL判断是否合法<br>每个进程拥有独立地址空间但是每个进程的内核（高）映射都是相同的：因为是内核</li>
</ul>
<ul>
<li><p>系统调用起点：<br>  在用户空间执行，sh 写出它的提示<br>  sh.asm, 使用write() 系统接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break *0xb90</span><br><span class="line">x/3i 0xb8b</span><br></pre></td></tr></table></figure>

<p>  其中，eax 中的 0x10 是 write 的系统调用号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info reg</span><br></pre></td></tr></table></figure>

<p>​    cs&#x3D;0x1b, B&#x3D;1011 – CPL&#x3D;3 &#x3D;&gt; 用户模式<br>​    esp 和 eip 是低地址——当然是虚拟地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/4x $esp</span><br></pre></td></tr></table></figure>

<p>​    cc1 是返回地址——在 printf 中<br>​    2 是 fd<br>​    0x3f7a 是堆栈上的缓冲区地址，作为准备写入的虚拟地址<br>​    1 是写入字符个数<br>​    综上，我们可以知道printf中有 wirte（2，0x3f7a，1）这样的调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/c 0x3f7a</span><br></pre></td></tr></table></figure>
</li>
<li><p>INT指令，内核入口（建议理解一下CPL，RPL，DPL（current，request，descriptor））</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step i</span><br><span class="line">info reg</span><br></pre></td></tr></table></figure>

<p>​    从cs&#x3D;0x8 – CPL&#x3D;3 &#x3D;到&gt; 内核模式<br>​    注意 INT 将 eip 和 esp 更改为高内核地址：jmp和栈都要改</p>
<p>问题：eip在哪里？</p>
<p>、</p>
<p>​    在内核提供的向量处jmp——用户只能通过中断才能进入内核。所以用户程序不能跳转到 CPL&#x3D;0 的内核中的随机位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/6wx $esp</span><br></pre></td></tr></table></figure>

<p>​    INT 保存了一些用户寄存器：err，eip，cs，eflags，esp，ss<br>  问题：为什么 INT 只保存这些寄存器？<br>​    保护现场：1.会被覆盖2.结束后需要返回<br>  问题：INT 做了什么：<br>​    1.切换到当前进程的内核堆栈：由于中断，暂时允许（RPL，CPL &gt;&#x3D;DPL（int）<br>；RPL，CPL &lt;&#x3D; DPL（dest））保存寄存器到内核栈<br>​    2.在内核堆栈上保存了一些用户寄存器<br>​    3.设置 CPL&#x3D;0<br>​    4.开始在内核提供的“向量”处执行<br>  问题：内核esp 是从哪里来的？<br>​    创建进程时，得到内核堆栈位置，因此内核位置保存在进程表中</p>
</li>
</ul>
<p>问：为什么 INT 需要保存用户状态，感觉很麻烦？应该保存多少状态？<br>    根据情况比较透明度和速度吧。</p>
<p>​	对于保护现场而言，给出以下部分例子：</p>
<p>​	比如你的esp不再像返回时esp-n，而是高低地址的隔离。因此你从栈返回的时候应该有esp值。</p>
<p>​	再比如你的pc本来是不用特地保存在内核栈，因为可以栈先返回内核态，然后pc得到后代码返回，为了安全也可以一并保存。</p>
<ul>
<li><p>然后将其余的用户寄存器保存在内核堆栈上：pushal 压入 8 个寄存器：eax .. edi<br>  （Trapasm.S alltraps中看）</p>
</li>
<li><p>显示  内核堆栈顶部的 19 个字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/19x $esp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss</span><br><span class="line">  esp</span><br><span class="line">  eflags</span><br><span class="line">  CS</span><br><span class="line">  eip</span><br><span class="line">  err—— INT从这里开始保存？</span><br><span class="line">  trapno//错误码，用来判断中断类型</span><br><span class="line">  ds</span><br><span class="line">  es</span><br><span class="line">  FS</span><br><span class="line">  GS</span><br><span class="line">  eax..edi</span><br></pre></td></tr></table></figure>

<p>  最终会被恢复，当系统调用返回时：现场思考：1.栈切换2.代码切换3.通用寄存器覆盖<br>  同时内核 C 代码有时需要读取&#x2F;写入保存的值比如eax返回值这样，就有可能决定是否恢复保存的寄存器。丢弃也是可能的。<br>  x86.h 中的 struct trapframe</p>
<p>问题：为什么用户寄存器保存在内核栈中？<br>   为什么不将它们保存在用户堆栈中？</p>
<p>因为最后需要从内核态切换：栈和代码段，就像函数返回那样，需要提前保存现场，但是比函数返回更复杂：覆盖的CPU里寄存器更多</p>
</li>
</ul>
<h3 id="中断进入内核"><a href="#中断进入内核" class="headerlink" title="中断进入内核"></a>中断进入内核</h3><ul>
<li><p>让我们看内核 C 代码<br>  pushl %esp 为 trap(struct trapframe *tf) 创建一个参数<br>  现在我们在 trap.c 中的 trap()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print tf</span><br><span class="line"> print *tf</span><br></pre></td></tr></table></figure>


</li>
<li><p>内核系统调用处理<br>  设备中断和故障也会进入 trap()<br>  trapno &#x3D;&#x3D; T_SYSCALL<br>  myproc()<br>  proc.h 中的 struct proc<br>  myproc()-&gt;tf – 所以 syscall() 可以得到系统调用号和参数<br>  syscall.c 中的 syscall()<br>查看 tf-&gt;eax 以找出哪个系统调用<br>  syscalls[] 中的 SYS_write 映射到 sys_write<br>  sysfile.c 中的 sys_write()<br>  arg*() 从用户堆栈中读取 write(fd,buf,n) 参数<br>  syscall.c 中的 argint()<br>proc-&gt;tf-&gt;esp + xxx</p>
</li>
<li><p>恢复用户寄存器<br>  syscall() 将 tf-&gt;eax 设置为返回值<br>  回到trap（）<br>  完成 – 返回到 trapasm.S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info reg </span><br></pre></td></tr></table></figure>

<p>​	仍在内核中，寄存器被内核代码覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stepi//直到iret</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info reg</span><br></pre></td></tr></table></figure>

<p>​    大多数寄存器保存恢复的用户值<br>​    eax 的 write() 返回值为 1：成功写入的字符个数<br>​    esp、eip、cs 仍然有内核值，还未恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/5x $esp</span><br></pre></td></tr></table></figure>

<p>​    保存的用户状态：eip、cs、eflags、esp、ss<br>  IRET 从堆栈中弹出这些用户寄存器<br>​    从而以 CPL&#x3D;3 重新进入用户空间</p>
</li>
</ul>
<p>问题：我们真的需要 IRET 吗？否则现场恢复比函数更复杂<br>   我们可以使用普通指令来恢复寄存器吗？不行，见上面<br>   IRET 可以更简单吗？可以，根据系统调用分类，可以放弃有些寄存器恢复</p>
<ul>
<li><p>回到用户空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stepi</span><br><span class="line">info reg</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a>fork()系统调用</h3><ul>
<li><p>让我们看看 fork() 如何建立一个新进程<br>尤其是如何第一时间让新进程进入用户空间？<br>想法：<br>  fork() 伪造一个内核堆栈，<em>看起来</em>就像它即将从 trap() 返回：直接一开始就进入了内核Iret附近<br>顶部有一个伪造的trapframe<br>  child 开始在内核中执行——在函数返回指令处<br>  alltraps“恢复”伪造的已保存寄存器<br>  第一次开始执行子进程</p>
</li>
<li><p>请注意，有两个单独的操作：<br>  创建一个新进程<br>  执行新进程</p>
</li>
<li><pre><code>break fork
c
where//来查看fork的过程
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   proc.c 中的 fork()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- allocproc（）</span><br><span class="line">    在 proc.c 开始时查看 proc[]</span><br><span class="line">    关注 p-&gt;kstack 的初始内容</span><br><span class="line">    陷阱框架的空间（将是父母的副本）</span><br><span class="line">    指向 trapasm.S 中的 trapret 的伪造保存的 EIP</span><br><span class="line">    “上下文”的内核堆栈空间</span><br><span class="line">      包含*内核*寄存器</span><br><span class="line">      切换到子内核线程时恢复进程</span><br><span class="line">    p-&gt;context-&gt;eip = forkret 设置子进程在内核中的起始位置</span><br><span class="line">     基本上只是一个函数调用指令</span><br><span class="line"></span><br><span class="line">- 回到 fork()</span><br><span class="line">    （请记住，我们仍然以父级身份执行）</span><br><span class="line">    分配物理内存和页表</span><br><span class="line">    将父母的内存复制给子进程（linux下是写时复制，即只复制地址可以访问，写的时候再真正找内存进行复制）</span><br><span class="line">    复制trapframe</span><br><span class="line">    tf-&gt;eax = 0 -- 这将是 fork(): w 的子进程的返回值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
print *np
print *np-&gt;tf
print *np-&gt;context
x/25x np-&gt;context
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    state = RUNNABLE -- 现在我们完成了</span><br><span class="line"></span><br><span class="line">- 新进程的内核堆栈内容：</span><br><span class="line">    trapframe -- 父的副本，但 eax=0</span><br><span class="line"></span><br><span class="line">    trapret的地址</span><br><span class="line"></span><br><span class="line">    context</span><br><span class="line">    eip = forkret</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  break forkret</span><br><span class="line">  x/20x $esp</span><br><span class="line">  next</span><br><span class="line">  finish</span><br></pre></td></tr></table></figure>

（现在在tramasm.S 中的trapret在 sh.S 中的 b6a)

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info reg</span><br><span class="line">eax 为零——意味着进入子进程</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>综上，fork子进程拥有父进程的所有内存，寄存器，并且从内核态返回，除了eax&#x3D;0，紧接着从父进程的代码执行位置继续进行，并且接下来修改内存和父进程基本毫无关系</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L4 homework：shell</title>
    <url>/2024/03/08/L4homework%EF%BC%9Ashell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="作业：shell"><a href="#作业：shell" class="headerlink" title="作业：shell"></a>作业：shell</h1><p>注：需要提示可以从lab1下的xv6教程0章找寻答案</p>
<p>通过在一个小的 shell 中实现几个特性，这个任务将使你更加熟悉 Unix 系统调用接口和 shell，我们将其称为 6.828 shell。您可以在任何支持 Unix API 的操作系统（Linux Athena 机器、装有 Linux 或 MacOS 的笔记本电脑等）上执行此任务。将您的 6.828 shell 作为名为“hwN.c”的文本文件<a href="https://6828.scripts.mit.edu/2017/handin.py/">提交</a>到<a href="https://6828.scripts.mit.edu/2017/handin.py/">提交网站</a>，其中 N 是日程表中列出的作业编号。</p>
<span id="more"></span>

<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf">xv6 书籍的</a>第 0 章。</p>
<p>如果您不熟悉 shell 的作用，请从 6.033 开始<a href="http://web.mit.edu/6.033/www/assignments/handson-unix.html">动手</a>操作<a href="http://web.mit.edu/6.033/www/assignments/handson-unix.html">Unix</a>。</p>
<p>下载<a href="https://pdos.csail.mit.edu/6.828/2017/homework/sh.c">6.828 shell</a>并查看它。6.828 shell 包含两个主要部分：解析 shell 命令和实现它们。解析器仅识别简单的 shell 命令，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls &gt; y</span><br><span class="line">cat &lt; y | sort | uniq| wc &gt; y1</span><br><span class="line">cat y1</span><br><span class="line">rm y1</span><br><span class="line">ls | sort | uniq| wc</span><br><span class="line">rm y</span><br></pre></td></tr></table></figure>

<p>将这些命令剪切并粘贴到文件<code>t.sh 中</code></p>
<p>要编译<code>sh.c</code>，您需要一个 C 编译器，例如 gcc。在 Athena 上，您可以输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ add gnu</span><br></pre></td></tr></table></figure>

<p>使 gcc 可用。如果您使用自己的计算机，则可能需要安装 gcc。</p>
<p>一旦你有了 gcc，你就可以编译 shell脚本，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc sh.c</span><br></pre></td></tr></table></figure>

<p>它会生成一个<code>a.out</code>文件，您可以运行该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out &lt; t.sh</span><br></pre></td></tr></table></figure>

<p>此执行将打印错误消息，因为您尚未实现多个功能。在本作业的其余部分中，您将实现这些功能。</p>
<h2 id="执行简单的命令"><a href="#执行简单的命令" class="headerlink" title="执行简单的命令"></a>执行简单的命令</h2><p>实现简单的命令，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>解析器已经为您构建了一个<code>execcmd</code>，因此您唯一需要编写的代码是<code>runcmd 中</code>的情况。您可能会发现查看 exec 的手册页很有用；键入“man 3 exec”，然后阅读有关 <code>execv 的信息</code>。exec 失败时打印错误消息。</p>
<p>要测试您的程序，请编译并运行生成的 a.out：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure>

<p>这将打印提示并等待输入。 <code>sh.c</code>打印为提示 <code>6.828$</code>这样您就不会与计算机的shell混淆。现在在你的 shell 中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.828$ ls</span><br></pre></td></tr></table></figure>

<p>您的 shell 可能会打印一条错误消息（除非您的工作目录中有名为<code>ls</code>的程序 ，或者您正在使用搜索<code>PATH</code>的<code>exec</code>版本）。现在在你的 shell 中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.828$ /bin/ls</span><br></pre></td></tr></table></figure>

<p>这应该执行程序<code>/bin/ls</code>，它应该打印出您工作目录中的文件名。您可以通过键入 ctrl-d 来停止 6.828 shell，这应该会让您回到计算机的 shell。</p>
<p>如果当前工作目录中不存在该程序，您可能希望将 6.828 shell 更改为始终尝试<code>/bin</code>，这样您就不必在下面为每个程序键入“&#x2F;bin”。如果您雄心勃勃，您可以实现对<code>PATH</code>变量的支持。</p>
<h2 id="输入-x2F-输出重定向"><a href="#输入-x2F-输出重定向" class="headerlink" title="输入&#x2F;输出重定向"></a>输入&#x2F;输出重定向</h2><p>实现 I&#x2F;O 重定向命令，以便您可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;6.828 is cool&quot; &gt; x.txt</span><br><span class="line">cat &lt; x.txt</span><br></pre></td></tr></table></figure>

<p>解析器已经识别 “&gt;” 和 “&lt;”，并为您构建了一个<code>redircmd</code>，因此您的工作只是为这些符号填写<code>runcmd </code>中缺少的代码。您可能会发现 open 和 close 的man手册很有用。</p>
<p>请注意，<code>redircmd</code>中的<code>mode</code>字段包含访问模式（例如，<code>O_RDONLY</code>），您应该将其传递 给<code>open</code>的<code>flags</code>参数；有关 shell 正在使用的模式值，请参阅<code>parseredirs</code>，有关<code>flags</code>参数的<code>open</code>手册页。</p>
<p>如果您正在使用的系统调用之一失败，请确保打印错误消息。</p>
<p>确保您的实现使用上述测试输入正确运行。一个常见的错误是忘记指定创建文件时必须使用的权限（即打开的第三个参数）。</p>
<h2 id="实施管道"><a href="#实施管道" class="headerlink" title="实施管道"></a>实施管道</h2><p>实现管道，以便您可以运行命令管道，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls | sort | uniq| wc</span><br></pre></td></tr></table></figure>

<p>解析器已经识别出“|”，并为您构建了一个<code>pipecmd</code>，因此您必须编写的唯一代码是“|” 情况<code>RUNCMD</code>。您可能会发现 pipe、fork、close 和 dup 的手册页很有用。</p>
<p>测试您是否可以运行上述管道。该<code>类型的</code>程序可能在目录<code>的/ usr / bin/</code>中，在这种情况下，您可以键入绝对路径<code>的/ usr / bin/sort</code>来排序运行。（在您计算机的 shell 中，您可以键入<code>which sort</code>以找出 shell 搜索路径中的哪个目录具有名为“sort”的可执行文件。）</p>
<p>现在您应该能够正确运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.828$ a.out &lt; t.sh</span><br></pre></td></tr></table></figure>

<p>确保为程序使用正确的绝对路径名。</p>
<p>不要忘记将您的解决方案提交到<a href="https://6828.scripts.mit.edu/2017/handin.py/">提交网站</a> （使用上面概述的“hwN.c”命名约定），无论是否有挑战解决方案。</p>
<h2 id="可选挑战练习"><a href="#可选挑战练习" class="headerlink" title="可选挑战练习"></a>可选挑战练习</h2><p>以下练习完全是可选的，不会影响您的成绩。将您选择的任何功能添加到您的 shell，例如：</p>
<ul>
<li>实现命令列表，以“;”分隔</li>
<li>通过实现“(”和“)”来实现子shell</li>
<li>通过支持“&amp;”和“wait”实现后台运行命令</li>
</ul>
<p>所有这些都需要对解析器和<code>runcmd</code>进行更改功能。</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L4：shell和os</title>
    <url>/2024/03/08/L4%EF%BC%9Ashell&amp;os/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="视频课第-4-讲：Shell-amp-OS-组织"><a href="#视频课第-4-讲：Shell-amp-OS-组织" class="headerlink" title="视频课第 4 讲：Shell &amp; OS 组织"></a>视频课第 4 讲：Shell &amp; OS 组织</h1><h2 id="讲座主题："><a href="#讲座主题：" class="headerlink" title="讲座主题："></a>讲座主题：</h2><ol>
<li><p>内核系统调用API</p>
</li>
<li><p>细节和设计</p>
</li>
<li><p>通过shell和作业2说明</p>
</li>
</ol>
<span id="more"></span>

<h2 id="概览图"><a href="#概览图" class="headerlink" title="概览图"></a>概览图</h2><ol>
<li><p>系统程序根据权级分为：用户态&#x2F;内核态</p>
</li>
<li><p>进程 &#x3D; 隔离的地址空间 + 线程</p>
</li>
<li><p>进入内核态过程：打开应用 -&gt; printf() -&gt; 系统接口write() -&gt; 调用SYSTEM CALL函数 -&gt; sys_write() -&gt; …</p>
</li>
<li><p>用户级库是应用的私有业务</p>
</li>
<li><p>内核内部函数不能被用户调用，只能通过调用接口来间接使用</p>
</li>
<li><p>xv6 有几十个系统调用；Linux 几百个左右</p>
</li>
<li><p>今天的细节主要是关于 UNIX 系统调用 API：xv6、Linux、OSX、POSIX 标准等的基础。 jos 有非常不同的系统调用；您将通过 jos 自己构建 UNIX 调用</p>
</li>
</ol>
<h2 id="作业解决方案"><a href="#作业解决方案" class="headerlink" title="作业解决方案"></a>作业解决方案</h2><ul>
<li>让我们复习视频课 2 (sh.c)<ul>
<li><p>执行<br>为什么有两个 execv() 参数？：执行文件定位和文件所需参数列表<br>参数会发生什么？被定位，然后第二个传入执行程序<br>当 exec’d 进程完成时会发生什么？执行加载的文件<br>execv() 可以返回吗？失败会返回，成功不会<br>命令完成后shell如何继续？子shell进程转为所需进程，主shell不被影响</p>
</li>
<li><p>重定向<br>exec’d 进程如何了解重定向？ 不同的fd 表中，使用自己的fd来引用同一个文件<br>重定向（或错误退出）是否会影响主 shell？不会，通过子进程执行这一过程</p>
</li>
<li><p>管道<br>ls | wc -l<br>如果 ls 产生输出的速度比 wc 消耗它的速度快怎么办？管道buffer的多余的东西避免丢失ls输出<br>如果 ls 比 wc 慢怎么办？wc等待ls产生，就立即进行<br>每个命令如何决定何时退出？执行后退出<br>如果读者没有关闭写端怎么办？无所谓，每个进程的端并不互相影响，进程退出后消失<br>如果作者没有关闭读取端怎么办？无所谓，每个进程的端并不互相影响，进程退出后消失<br>内核如何知道何时释放管道缓冲区？当内核结束</p>
</li>
<li><p>shell 如何知道管道已完成？wc执行成功后子进程退出，返回信号给shell父进程<br>例如 ls | sort | tail -1</p>
</li>
<li><p>什么是进程树？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定命令的进程树: ls | (sort | tail -1)</span><br><span class="line">          sh进程</span><br><span class="line">          sh1进程</span><br><span class="line">      （ls进程      sh2进程）</span><br><span class="line">               （sort进程   tail进程）</span><br><span class="line">我们可以认为：自左向右执行命令（实际的进程切换不影响这个简单的”认为“，只是提高了效率）</span><br></pre></td></tr></table></figure>
</li>
<li><p>shell 需要分叉这么多次吗？</p>
<ul>
<li>如果 sh 没有为 pcmd-&gt;left fork 怎么办？[尝试一下]<br>即调用 runcmd() 而不分叉?sh2进程下的子进程会无限等待管道的输入区</li>
<li>如果 sh 没有为 pcmd -&gt; right fork怎么办？[尝试一下]<br>用户可见的行为会改变吗？会仅仅执行ls<br>sleep 10 | echo hi你会发现hi之后等待了十秒，说明进程是交错执行，造成了并行假象，而不是左边进程执行完毕后右边才执行</li>
</ul>
</li>
<li><p>为什么只有在进程都启动后才使用wait()？为了子进程交错执行成功，否则父进程和左进程执行，右进程不执行。<br>如果 sh wait()ed for pcmd-&gt;left 在第二个 fork 之前会怎样？[尝试一下]可能第一个进程创造了很多buf但是第二个进程没有及时执行，造成效率低下<br>  ls | wc -l<br>  cat &lt; big | wc -l&#x2F;&#x2F;将big输入到cat，输出流重定向屏幕到管道，wc -l执行使用管道，最后得到统计结果而不是文件内容</p>
</li>
<li><p>重点：系统调用可以有多种组合方式<br>获得不同的行为。</p>
</li>
<li><p>综上所述，管道｜不仅完成了进程通信，即使不使用缓冲区，这个命令也规定了子进程运行顺序：并行</p>
</li>
</ul>
</li>
</ul>
<h2 id="shell挑战题"><a href="#shell挑战题" class="headerlink" title="shell挑战题"></a>shell挑战题</h2><ul>
<li>如何用“;”实现自定义子进程执行顺序？<br>gcc sh.c; .&#x2F;a.out<br>echo a; echo<br>为什么在 scmd-&gt; 之前等待（）？[尝试一下]：如果并行，那么文件执行失败，等同于&amp;&amp;命令</li>
<li>如何实现“&amp;”？<br>$ sleep 5 &amp; &#x2F;&#x2F;&amp;在命令后代表后台执行：和父进程并行</li>
<li>$wait&#x2F;&#x2F;父进程等待sleep子进程：改变后台执行状态<br>&amp; 和 wait 的实现是主要的——为什么？见上面回答<br>如果后台进程退出而 sh 等待前台进程怎么办？子进程退出会给父进程发送一些信息，因此wait后会在sleep进程输出结果多+done ，还有sleep 5这样的字眼</li>
<li>如何实现嵌套？<br> (echo a; echo b) | wc -l<br>*我的 ( … ) 实现仅在 sh 的解析器中，而不是 runcmd()<br>sh 管道代码不必知道它适用于序列，这很巧妙，只需要知道和buffer的动作交互即可</li>
<li>这些有什么不同？<br>echo a &gt; x ; echo b &gt; x&#x2F;&#x2F;字符a输入文件（没有就新建）x,然后b再输入x，覆盖a的内容<br>( echo a ; echo b ) &gt; x&#x2F;&#x2F;将a和b的输出流一起使用&gt;重定向到文件x<br>避免覆盖的机制是什么？括号。</li>
<li>ps：如果你想要在第一行命令基础上完成目标，对b替换&gt;为&gt;&gt;，变为append模式即可</li>
</ul>
<h2 id="UNIX-系统调用观察"><a href="#UNIX-系统调用观察" class="headerlink" title="UNIX 系统调用观察"></a>UNIX 系统调用观察</h2><ul>
<li><p>fork&#x2F;exec 拆分看起来很浪费——fork() 复制 mem，exec() 丢弃。<br>为什么不例如 pid &#x3D; forkexec(path, argv, fd0, fd1) ？<br>因为fork&#x2F;exec 拆分很有用：<br>  fork（）; I&#x2F;O 重定向；runcmd（）<br>或者fork（）; 复杂的嵌套命令；exit。<br>如 ( cmd1 ; cmd2 ) | cmd3<br>  fork() 单独：并行处理<br>  exec() 单独： &#x2F;bin&#x2F;login … exec(“&#x2F;bin&#x2F;sh”)<br>fork 对于小程序来说效率高——在我的机器上：<br>  fork+exec 需要 400 微秒（2500&#x2F;秒）<br>  单独 fork 需要 80 微秒（12000 &#x2F; 秒）<br>  涉及到一些技巧——您将在 jos 中实现它们！</p>
</li>
<li><p>文件描述符设计：</p>
<ul>
<li>FD 是一个句柄的间接级别：就是作为偏移的多级指针啦<ul>
<li>进程的真实 I&#x2F;O 环境隐藏在内核中</li>
<li>保留在 fork 和 exec 上</li>
<li>将 I&#x2F;O 设置与使用分开</li>
<li>想象写文件（文件名，偏移量，缓冲区大小）</li>
</ul>
</li>
<li>FD 有助于使程序更通用：不需要特殊情况<br>文件 vs 控制台 vs 管道</li>
</ul>
</li>
<li><p>理念：一小组概念上简单的调用，它们结合得很好<br>例如 fork()、open()、dup()、exec()<br>命令行设计有类似的方法<br>  ls | wc -l</p>
</li>
<li><p>为什么内核必须支持管道——为什么不用 sh 模拟它们，例如<br>ls &gt; 临时文件；wc -l &lt; 临时文件：进程不同，临时文件没法传递</p>
</li>
<li><p>系统调用接口简单，只有整数和字符缓冲区。为什么没有 open()<br>返回指向内核文件对象的指针引用？open调用系统接口，如果返回指针就破坏了内核态和用户态的隔离，容易操作不当破坏内核区</p>
</li>
<li><p>核心 UNIX 系统调用是古老的；他们坚持得好吗？<br>是的; 非常成功，并且经过多年的发展<br>历史：设计迎合命令行和软件开发<br>  系统调用接口方便程序员使用命令行用户，如命名文件、管道等，对开发、调试、服务器维护很重要。<br>但是 UNIX 的想法并不完美：<br>  程序员对于系统调用 API 的便利性来说通常不是很好<br>  程序员使用诸如 Python 之类的库来隐藏系统调用的详细信息<br>  应用程序可能与文件和c几乎没有关系，例如在智能手机上<br>  一些 UNIX 抽象不是很有效<br>  用于多 GB 进程的 fork() 非常慢<br>FD 隐藏了可能很重要的细节：<br>  例如磁盘文件的块大小<br>  例如网络消息的时间和大小<br>所以有很多关于替代计划的工作<br>  有时为现有的类 UNIX 内核提供新的系统调用和抽象<br>  有时内核应该做什么的全新方法<br>*在学习的时候你应该问“为什么这样？设计 X 不是更好吗？”</p>
</li>
</ul>
<h2 id="操作系统组织"><a href="#操作系统组织" class="headerlink" title="操作系统组织"></a>操作系统组织</h2><ul>
<li><p>如何实现系统调用接口？</p>
</li>
<li><p>为什么不只是一个lib库？<br>即没有内核，直接在硬件上运行app+library。<br>灵活：如果不需要，应用程序可以绕过库<br>应用程序可以直接与硬件交互<br>库适用于单一用途的设备<br>但是如果计算机用于多项活动呢？</p>
</li>
<li><p>内核的关键要求：<br>隔离：内核态和用户态隔离，用户进程之间也隔离<br>多路复用：多个进程执行合为一个cpu来做<br>相互作用：进程通信</p>
</li>
<li><p>有用的方法：抽象资源而不是原始硬件交互：你想写软件的时候写硬件交互代码吗？<br>文件系统，而不是原始磁盘：你想自己计算磁盘扇区位置吗？<br>进程，而不是原始 CPU&#x2F;内存：你想小心翼翼不要让机子爆炸吗？<br>TCP，而不是以太网数据包：你想手动解析，思考数据包的内容吗<br>抽象通常可以实现隔离、多路复用和交互<br>也更方便便携：即计算机领域，任何一个问题都可以加一个抽象层来实现：）</p>
</li>
<li><p>从隔离开始，因为这通常是最困难的要求。</p>
</li>
<li><p>隔离目标：<br>应用程序不能直接与硬件交互<br>应用程序不会损害操作系统<br>应用之间不能直接影响<br>应用程序只能通过操作系统界面与世界交互</p>
</li>
<li><p>处理器提供有助于隔离的机制</p>
<ul>
<li>硬件提供用户模式和内核模式<ul>
<li>某些指令只能在内核模式下执行<br>设备访问、处理器配置、隔离机制</li>
</ul>
</li>
<li>硬件禁止应用程序执行特权指令<ul>
<li>而是陷入内核模式</li>
<li>内核可以清理（例如，终止进程）</li>
</ul>
</li>
<li>硬件让内核模式在用户模式上配置各种约束<br>最关键：页表将用户软件限制在其自己的地址空间</li>
</ul>
</li>
<li><p>内核建立在硬件隔离机制之上</p>
<ul>
<li><p>操作系统以内核模式运行</p>
<ul>
<li>内核是一个大程序<br>服务：进程、文件系统、网络<br>低级：设备、虚拟内存<br>所有内核都以完整的硬件特权运行（方便）</li>
</ul>
</li>
<li><p>应用程序在用户模式下运行</p>
<ul>
<li>内核设置每个进程隔离的地址空间</li>
<li>系统调用在用户模式和内核模式之间切换<br>应用程序执行特殊指令进入内核<br>硬件切换到内核模式<br>但仅限于内核指定的入口点</li>
</ul>
</li>
</ul>
</li>
<li><p>在内核中放什么？</p>
<ul>
<li><p>xv6 遵循传统设计：所有操作系统都在内核模式下运行</p>
<ul>
<li>一个带有文件系统、驱动程序等的大程序</li>
<li>这种设计称为单片内核</li>
<li>内核接口 &#x3D;&#x3D; 系统调用接口</li>
<li>好：易于子系统协作<br>文件系统和虚拟内存共享一个缓存</li>
<li>不好：交互很复杂<br>导致错误<br>内核中没有隔离</li>
</ul>
</li>
<li><p>微内核设计</p>
<ul>
<li>许多操作系统服务作为普通用户程序运行<br>文件服务器中的文件系统</li>
<li>内核实现了在用户空间运行服务的最小机制<br>有记忆的进程<br>进程间通信（IPC）</li>
<li>内核接口 !&#x3D; 系统调用接口		</li>
<li>好：更多隔离</li>
<li>差：可能很难获得良好的性能</li>
</ul>
</li>
<li><p>exokernel：没有抽象<br>应用程序可以半直接使用硬件，但 O&#x2F;S 隔离<br>例如应用程序可以读&#x2F;写自己的页表，但 O&#x2F;S 审计<br>例如应用程序可以读&#x2F;写磁盘块，但 O&#x2F;S 跟踪块所有者<br>好：对于要求苛刻的应用程序具有更大的灵活性<br>jos 将是微内核和外内核的混合体</p>
</li>
</ul>
</li>
<li><p>可以在没有硬件支持的内核&#x2F;用户模式的情况下进行进程隔离吗？<br>是的！<br>见 Singularity O&#x2F;S，在学习的后期<br>但硬件用户&#x2F;内核模式是最受欢迎的计划</p>
</li>
</ul>
<p>下一讲：x86 硬件隔离机制以及 xv6 的使用</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L2：x86和PC架构</title>
    <url>/2024/03/08/L2%EF%BC%9Ax86%E5%92%8CPC%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li>PC结构</li>
<li>x86命令集</li>
<li>gcc调用惯例</li>
<li>PC模拟</li>
</ul>
<span id="more"></span>

<h2 id="PC结构"><a href="#PC结构" class="headerlink" title="PC结构"></a>PC结构</h2><ul>
<li><p>一个完成的PC包括</p>
<ul>
<li>x86CPU，包括寄存器，执行单元，内存管理（比如mmu寻址）</li>
<li>CPU芯片，包括地址和数据信号</li>
<li>内存</li>
<li>硬盘</li>
<li>键盘</li>
<li>显示器</li>
<li>其他的资源：引导ROM，时钟，等</li>
</ul>
</li>
<li><p>我们将会以出事的16位8086CPU开始</p>
</li>
<li><p>CPU以这样的一个指令开始</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	run next instruction</span><br><span class="line">	&#125;<span class="comment">//即顺序执行代码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时需要一些寄存器</p>
<ul>
<li>16位的：AX, BX, CX, DX</li>
<li>每个都是有8位的比如AL，AH</li>
<li>小而快：相对于内存来说</li>
</ul>
</li>
<li><p>更大的空间：内存</p>
<ul>
<li>CPU通过地址总线发送地址（每位发送1bit）</li>
<li>数据从数据总线传送，发送或者返回</li>
</ul>
</li>
<li><p>添加地址寄存器：指针</p>
<ul>
<li>SP：栈顶指针</li>
<li>BP：栈底指针</li>
<li>SI：源索引</li>
<li>DI：目标索引</li>
</ul>
</li>
<li><p>不仅数据在内存中，指令也在内存中</p>
<ul>
<li>IP：指令指针</li>
<li>根据IP顺序执行每个指令</li>
<li>IP能够被CALL，RET，JMP，条件转移来修改IP</li>
</ul>
</li>
<li><p>如何进行条件转移？</p>
<ul>
<li>FLAGS：一些条件命令<ul>
<li>of：溢出</li>
<li>sf：正负</li>
<li>zf：0判定</li>
<li>cf：进位（跟溢出不一样，比如8位带符号中128就是一出，而无符号256就是进位）</li>
<li>等等</li>
<li>if：中断</li>
<li>df：方向（就是IP从地址的小到大或者从大到小）</li>
</ul>
</li>
<li>JP，JN，J[N]Z，J[N]C，J[N]O…这些指令来条件转移，后跟地址</li>
</ul>
</li>
<li><p>IO</p>
<ul>
<li><p>原始PC结构：使用执行的IO空间</p>
<ul>
<li><p>同内存访问没什么区别，加个signal而已</p>
</li>
<li><p>只有1024IO地址：即10位</p>
</li>
<li><p>使用特殊的比如IN，OUT指令访问</p>
</li>
<li><p>例子：你应该寻找里面的访问代码，以及函数的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_PORT    0x378</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_PORT  0x379</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   BUSY 0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTROL_PORT 0x37A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   STROBE 0x01</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">lpt_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait for printer to consume previous byte */</span></span><br><span class="line">  <span class="keyword">while</span>((inb(STATUS_PORT) &amp; BUSY) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* put the byte on the parallel lines */</span></span><br><span class="line">  outb(DATA_PORT, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* tell the printer to look at the data */</span></span><br><span class="line">  outb(CONTROL_PORT, STROBE);</span><br><span class="line">  outb(CONTROL_PORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>内存定位IO</p>
<ul>
<li>使用物理地址<ul>
<li>有限的IO空间</li>
<li>不需要特殊指令</li>
<li>使用系统控制器传送到特殊设备</li>
</ul>
</li>
<li>魔法内存：？？？<ul>
<li>访问有副作用</li>
<li>读取产生永久改变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果想要超过16位的访问呢？</p>
<ul>
<li>8086有20位的地址，也就是1Mb内存</li>
<li>因此在16位基础上衍生段寄存器的概念</li>
<li>CS：代码段，左移4位（16进制1位）加上额外的IP来访问</li>
<li>SS：栈段，加上偏移的SP或BP来访问</li>
<li>DS：数据段，加上偏移的其他寄存器来访问</li>
<li>ES：额外段，对于字符串操作用</li>
<li>因此虚拟地址为pa&#x3D;va+seg*16</li>
<li>举个例子，对于65535，CS为4096</li>
<li>坑：跨越边界的指针访问</li>
</ul>
</li>
<li><p>但是还不够，内存依旧太小</p>
<ul>
<li>80386提供32位</li>
<li>为了兼容性，从16位开始，到保护模式扩展到32位</li>
<li>寄存器从AX到EAX</li>
<li>操作数和地址都因此是32位，（这也意味着指针存放的一些限制），段地址并不再乘，而是直接相加偏移量</li>
<li>为了区别32&#x2F;16，使用隐含（汇编层面）前缀区别，32位为0x66 ，另一个0x67，这个完全不用记，看不到也没啥意义</li>
<li>转换的开始：.code32，即开始了隐含的前缀，</li>
<li>80386不仅分段，同时也有分页操作</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b8 cd ab		16-bit CPU,  AX &lt;- 0xabcd</span><br><span class="line">b8 34 12 cd ab		32-bit CPU, EAX &lt;- 0xabcd1234</span><br><span class="line">66 b8 cd ab		32-bit CPU,  AX &lt;- 0xabcd</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="X86物理内存"><a href="#X86物理内存" class="headerlink" title="X86物理内存"></a>X86物理内存</h2><ul>
<li>物理地址空间像传统RAM一样</li>
<li>除了一些低地址指向其他东西</li>
<li>写VGA部分的内存开始显示，可以被观察</li>
<li>重启或者启动-从0xfffffff0的ROM（所以顶部一定是ROM？）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x0000000</span><br></pre></td></tr></table></figure>

<h2 id="X86-指令集"><a href="#X86-指令集" class="headerlink" title="X86 指令集"></a>X86 指令集</h2><ul>
<li><p>Intel语法：op dst，src</p>
</li>
<li><p>AT&amp;Tyufa：op src，dst（相反）</p>
<p>操作数是寄存器，常量，指针（通过寄存器访问内存），通过内存访问的常量</p>
</li>
<li><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;T syntax	&quot;C&quot;-ish equivalent</span><br><span class="line"></span><br><span class="line">movl %eax, %edx	edx = eax;	register mode</span><br><span class="line">movl $0x123, %edx	edx = 0x123;	immediate</span><br><span class="line">movl 0x123, %edx	edx = *(int32_t*)0x123;	direct</span><br><span class="line">movl (%ebx), %edx	edx = *(int32_t*)ebx;	indirect</span><br><span class="line">movl 4(%ebx), %edx	edx = *(int32_t*)(ebx+4);	displaced</span><br></pre></td></tr></table></figure>
</li>
<li><p>指令类型</p>
<ul>
<li>数据移动：MOV，PUSH，POP。。。</li>
<li>算数统计：TEST，SHL，ADD，AND。。。</li>
<li>IO：IN，OUT。。。</li>
<li>控制：JMP，JZ，JNZ，CALL，RET</li>
<li>字符串：REP MOVSB。。。</li>
<li>系统：IRET，INT</li>
<li>intel架构第二册是参考</li>
</ul>
</li>
</ul>
<h2 id="gcc-x86-调用惯例"><a href="#gcc-x86-调用惯例" class="headerlink" title="gcc x86 调用惯例"></a>gcc x86 调用惯例</h2><ul>
<li><p>x86 指定了栈向低地址增长：记住每个指令的对应指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//左边是指令，实际上的干的在右边，对，我们写的汇编也可以不维护栈，会自动生成一些</span><br><span class="line">pushl %eax	      subl $4, %esp//栈增长</span><br><span class="line">									movl %eax, (%esp)</span><br><span class="line">									</span><br><span class="line">popl %eax					movl (%esp), %eax</span><br><span class="line">									addl $4, %esp//栈减小</span><br><span class="line">									</span><br><span class="line">call 0x12345			pushl %eip (*)</span><br><span class="line">									movl $0x12345, %eip (*)//call的指令就是eip压栈</span><br><span class="line">									</span><br><span class="line">ret								popl %eip (*)//返回，但是实际上指令更多：需要返回到原eip，这代表了eip，ebp，esp都需要改变，不止这一条指令</span><br><span class="line">//*代表了这是人工造的例子</span><br></pre></td></tr></table></figure>
</li>
<li><p>GCC指定栈的使用。约定了x86中调用和被调用的情况</p>
<ul>
<li><p>call指令：</p>
<ul>
<li>eip压栈</li>
<li>由于在每条指令执行后eip增加，所以返回时pop执行后eip变为call的下一条指令</li>
</ul>
</li>
<li><p>对于一个函数的入口：call之后</p>
<ul>
<li>%eip指向函数的第一条命令：新eip</li>
<li>原%ebp压栈，新%ebp指向这部分，标志着函数栈底</li>
<li>每次%esp在存放之前扩展，删除之后缩小，标志着栈顶</li>
<li>CPU续取址执行</li>
</ul>
</li>
<li><p>在ret指令后：恢复现场</p>
<ul>
<li>%eip保存了返回地址</li>
<li>%esp将指向调用的返回值</li>
<li>%eax（如果64位，那么还得有个%edx）保存了返回值（如果void类型就丢弃）</li>
<li>调用者：%edx，%ecx没什么变化，可能不用回被恢复</li>
<li>调用函数中：%ebp, %ebx, %esi, %edi，会在调用期间被使用，因此需要恢复现场。当然你得知道，如果函数需要很少，那么寄存器满足，不会被开辟栈帧，而且ebx一般保存上一个ebp</li>
</ul>
</li>
</ul>
</li>
<li><p>专业名词</p>
<ul>
<li><p>每个函数有个一个由ebp，esp来标记的栈帧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     +------------+   |</span><br><span class="line">       | arg <span class="number">2</span>      |   \</span><br><span class="line">       +------------+    &gt;- previous function<span class="number">&#x27;</span>s <span class="built_in">stack</span> frame</span><br><span class="line">       | arg <span class="number">1</span>      |   /</span><br><span class="line">       +------------+   |</span><br><span class="line">       | ret %eip   |   /</span><br><span class="line">       +============+   -----分界线，call后压eip，然后进入调用栈帧，保存ebp后才是新的局部变量保存</span><br><span class="line">       | saved %ebp |   \</span><br><span class="line">%ebp-&gt; +------------+   |</span><br><span class="line">       |            |   |</span><br><span class="line">       |   local    |   \</span><br><span class="line">       | variables, |    &gt;- current function<span class="number">&#x27;</span>s <span class="built_in">stack</span> frame</span><br><span class="line">       |    etc.    |   /</span><br><span class="line">       |            |   |</span><br><span class="line">       |            |   |</span><br><span class="line">%esp-&gt; +------------+   /</span><br></pre></td></tr></table></figure>
</li>
<li><p>%esp为栈顶，开辟前增长，移动后减小</p>
</li>
<li><p>%ebp指向前一个%ebp</p>
</li>
<li><p>函数开场：ebp压栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushl %ebp</span><br><span class="line">movl %esp, $ebp</span><br><span class="line">//or,一般不用</span><br><span class="line">enter $0, $0</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数结束：ebp出栈（很容易找到压栈的eip）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl %ebp, %esp</span><br><span class="line">popl %ebp//这是得到了ebp，然后esp到了eip的位置</span><br><span class="line">//or</span><br><span class="line">leave</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>大例子</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//C代码</span><br><span class="line">	int main(void)&#123;return f(8)+1;&#125;</span><br><span class="line">	int f(int x)&#123;return g(x);&#125;</span><br><span class="line">	int g(int x)&#123;return x+3;&#125;</span><br><span class="line">//汇编</span><br><span class="line">_main:</span><br><span class="line">													prologue//函数头：保存ebp</span><br><span class="line">			pushl %ebp</span><br><span class="line">			movl %esp, %ebp</span><br><span class="line">													body</span><br><span class="line">			pushl $8</span><br><span class="line">			call _f</span><br><span class="line">			addl $1, %eax</span><br><span class="line">													epilogue</span><br><span class="line">			movl %ebp, %esp</span><br><span class="line">			popl %ebp</span><br><span class="line">			ret</span><br><span class="line">		_f:</span><br><span class="line">													prologue</span><br><span class="line">			pushl %ebp</span><br><span class="line">			movl %esp, %ebp</span><br><span class="line">													body</span><br><span class="line">			pushl 8(%esp)</span><br><span class="line">			call _g</span><br><span class="line">													epilogue</span><br><span class="line">			movl %ebp, %esp</span><br><span class="line">			popl %ebp</span><br><span class="line">			ret</span><br><span class="line"></span><br><span class="line">		_g:</span><br><span class="line">													prologue</span><br><span class="line">			pushl %ebp</span><br><span class="line">			movl %esp, %ebp</span><br><span class="line">													save %ebx，即传入的参数int x</span><br><span class="line">			pushl %ebx</span><br><span class="line">													body</span><br><span class="line">			movl 8(%ebp), %ebx</span><br><span class="line">			addl $3, %ebx</span><br><span class="line">			movl %ebx, %eax</span><br><span class="line">													restore %ebx</span><br><span class="line">			popl %ebx</span><br><span class="line">													epilogue</span><br><span class="line">			movl %ebp, %esp</span><br><span class="line">			popl %ebp</span><br><span class="line">			ret</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
</li>
<li><p>非常小的g函数汇编形式:在完全不需要栈的情况下，这种情况一般是汇编优化的选择</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_g:</span><br><span class="line">			movl 4(%esp), %eax</span><br><span class="line">			addl $3, %eax</span><br><span class="line">			ret</span><br></pre></td></tr></table></figure>

</li>
<li><p>请你写出最小的f函数汇编形式</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_f:</span><br><span class="line">			call _g</span><br><span class="line">			ret</span><br></pre></td></tr></table></figure>

</li>
<li><p>编译，链接，装载</p>
<ul>
<li>预处理：根据#inlude扩展头文件  –ASCII形式</li>
<li>编译器进行编译得到汇编代码.asm –ASCII形式</li>
<li>编译器汇编处理得到.o可重定位文件，此时机器已经可读 –二进制形式</li>
<li>链接：链接器链接.o文件，产生一个可执行文件的映像 –二进制形式</li>
<li>装载：把映像装载入内存，执行</li>
</ul>
</li>
</ul>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/008i3skNly1gulrrz4qrmj60sg0dljse02.jpg"></p>
<h2 id="PC模拟"><a href="#PC模拟" class="headerlink" title="PC模拟"></a>PC模拟</h2><ul>
<li><p>Bochs模拟器的工作由</p>
<ul>
<li>软件模拟硬件实现（下图给出假设你的主机上安装了Linux虚拟机）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/008i3skNly1gulrst7k45j60d00bi3yq02.jpg"></li>
</ul>
</li>
<li><p>在已有系统上以一个进程的运行来运行</p>
</li>
<li><p>使用内存来存储</p>
<ul>
<li><p>使用全局变量来存储模拟的CPU寄存器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int32_t</span> regs[<span class="number">8</span>];</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> REG_EAX 1;</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> REG_EBX 2;</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> REG_ECX 3;</span></span><br><span class="line">		...</span><br><span class="line">		<span class="type">int32_t</span> eip;</span><br><span class="line">		<span class="type">int16_t</span> segregs[<span class="number">4</span>];</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Boch的内存来存储模拟的物理内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> mem[<span class="number">256</span>*<span class="number">1024</span>*<span class="number">1024</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过for循环模拟CPU指令执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		read_instruction();</span><br><span class="line">		<span class="keyword">switch</span> (decode_instruction_opcode()) &#123;</span><br><span class="line">		<span class="keyword">case</span> OPCODE_ADD:</span><br><span class="line">			<span class="type">int</span> src = decode_src_reg();</span><br><span class="line">			<span class="type">int</span> dst = decode_dst_reg();</span><br><span class="line">			regs[dst] = regs[dst] + regs[src];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> OPCODE_SUB:</span><br><span class="line">			<span class="type">int</span> src = decode_src_reg();</span><br><span class="line">			<span class="type">int</span> dst = decode_dst_reg();</span><br><span class="line">			regs[dst] = regs[dst] - regs[src];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">		eip += instruction_length;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过页表来实现地址转换寻址物理地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KB		1024</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> MB		1024*1024</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LOW_MEMORY	640*KB</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EXT_MEMORY	10*MB</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> low_mem[LOW_MEMORY];</span><br><span class="line">	<span class="type">uint8_t</span> ext_mem[EXT_MEMORY];</span><br><span class="line">	<span class="type">uint8_t</span> bios_rom[<span class="number">64</span>*KB];</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span> <span class="title function_">read_byte</span><span class="params">(<span class="type">uint32_t</span> phys_addr)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (phys_addr &lt; LOW_MEMORY)</span><br><span class="line">			<span class="keyword">return</span> low_mem[phys_addr];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">960</span>*KB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB)</span><br><span class="line">			<span class="keyword">return</span> rom_bios[phys_addr - <span class="number">960</span>*KB];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">1</span>*MB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB+EXT_MEMORY) &#123;</span><br><span class="line">			<span class="keyword">return</span> ext_mem[phys_addr<span class="number">-1</span>*MB];</span><br><span class="line">		<span class="keyword">else</span> ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> write_byte(<span class="type">uint32_t</span> phys_addr, <span class="type">uint8_t</span> val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phys_addr &lt; LOW_MEMORY)</span><br><span class="line">			low_mem[phys_addr] = val;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">960</span>*KB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB)</span><br><span class="line">			; <span class="comment">/* ignore attempted write to ROM! */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (phys_addr &gt;= <span class="number">1</span>*MB &amp;&amp; phys_addr &lt; <span class="number">1</span>*MB+EXT_MEMORY) &#123;</span><br><span class="line">			ext_mem[phys_addr<span class="number">-1</span>*MB] = val;</span><br><span class="line">		<span class="keyword">else</span> ...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模拟IO设备：通过特定的内存访问IO空间来模拟</p>
<ul>
<li>R&#x2F;W的转换：从主机到模拟</li>
<li>使用一个X窗口来模拟W到VGA（屏幕）</li>
<li>同样从X窗口的输入消息队列来模拟R从键盘</li>
</ul>
</li>
</ul>
<p>​    </p>
<p>总结：</p>
<p>1.Boch模拟了以下硬件、</p>
<ul>
<li>硬盘：主机的内存</li>
<li>虚拟屏幕VGA：绘制一个窗口</li>
<li>键盘:API调用</li>
<li>时钟：主机的时钟</li>
<li>等</li>
</ul>
<p>实验的想法实现：</p>
<ul>
<li>存储和进程</li>
<li>栈</li>
<li>内存和IO</li>
<li>硬件抽象为软件管理</li>
</ul>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L1：操作系统概论</title>
    <url>/2024/03/08/L1%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul>
<li><p>目标</p>
<ul>
<li>操作系统设计与实现</li>
<li>手把手建立小os<span id="more"></span></li>
</ul>
</li>
<li><p>os的功能</p>
<ul>
<li>运行程序</li>
<li>抽象硬件</li>
<li>多个应用程序之间多路复用硬件</li>
<li>抽象应用程序来包容bug？</li>
<li>允许程序之间共享信息</li>
<li>高性能</li>
</ul>
</li>
<li><p>os设计</p>
<ul>
<li>小：管理图书馆那样管理</li>
<li>大：硬件抽象</li>
</ul>
</li>
<li><p>组织：结构图</p>
<ul>
<li>CPU，内存，硬盘，C程序的内核，用户程序：vi，gcc，c</li>
<li>关心系统接口和内核结构</li>
</ul>
</li>
<li><p>os内核典型的能提供哪些服务？</p>
<ul>
<li>进程</li>
<li>内存分配</li>
<li>文件内容</li>
<li>目录，文件名</li>
<li>安全性</li>
<li>其他：用户，IPC，网络，时间，中断</li>
</ul>
</li>
<li><p>os抽象？</p>
<ul>
<li><p>应用程序只能通过system call来使用os</p>
</li>
<li><p>例如：UNIX：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fd = open(&quot;out&quot;, 1);</span><br><span class="line">write(fd, &quot;hello\n&quot;,6);</span><br><span class="line">pid = fork();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>为什么os设计或实现会难&#x2F;有趣？</p>
<ul>
<li>环境不友好：快速h&#x2F;w，难debug</li>
<li>底层，高效，逐步抽象</li>
<li>强大且简单</li>
<li>功能抽象</li>
<li>行为互动：CPU级别vs内存分配</li>
<li>开放式问题：安全性，性能</li>
</ul>
</li>
<li><p>你会。。算了不写了</p>
</li>
</ul>
<h2 id="课程结构"><a href="#课程结构" class="headerlink" title="课程结构"></a>课程结构</h2><ul>
<li><a href="https://pdos.csail.mit.edu/6.828">https://pdos.csail.mit.edu/6.828</a></li>
<li>课程<ul>
<li>os知识</li>
<li>传统os：xv6的细节</li>
<li>xv6的编程作业</li>
<li>一些最近（当然现在不是了）的论文</li>
</ul>
</li>
<li>实验：JOS，一个小的os<ul>
<li>5+lab的构建</li>
<li>内核接口：接触硬件，保护硬件（通过抽象）</li>
<li>用户级别的同权限的lib：fork. exec, pipe等</li>
<li>构建环境：gcc，qemu（模拟硬件的虚拟机）</li>
<li>lab1可以直接开始思考了</li>
</ul>
</li>
<li>2个考试：随便吧</li>
</ul>
<h2 id="system-calls-的介绍"><a href="#system-calls-的介绍" class="headerlink" title="system calls 的介绍"></a>system calls 的介绍</h2><ul>
<li><p>6.828主要就是完成这部分，你应该知道如何使用这些接口（在UNIX系的系统下）</p>
</li>
<li><p>注意：对于命令不理解或者没有这个命令，使用man <command>和你的翻译来确定和进一步了解！</p>
</li>
<li><p>例子：ls</p>
<ul>
<li>跟踪你的ls命令执行（这两种系统我都只要ls一个命令就行了）<ul>
<li>OSX: sudo dtruss &#x2F;bin&#x2F;ls</li>
<li>Linux: strace &#x2F;bin&#x2F;ls</li>
</ul>
</li>
<li>有很多这样的system calls（系统调用）</li>
</ul>
</li>
<li><p>例子：cat&#x2F;&#x2F;只要明白功能，会使用cat就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> copy.c//前提是这个文件已经存在</span><br><span class="line">cc -o copy copy.c//编译</span><br><span class="line">./copy//使用</span><br><span class="line"></span><br><span class="line">//copy.c的功能：读取一行，写一行</span><br><span class="line">//note：用C写</span><br></pre></td></tr></table></figure>

<ul>
<li><p>R&#x2F;W第一个参数是fd（文件描述符），是调用open的返回值，告诉内核打开的文件的位置,0代表了“标准输入”，1代表“标准输出”，当然你</p>
</li>
<li><p>sudo dtruss .&#x2F;copy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//结果举例：</span><br><span class="line"><span class="built_in">read</span>(0x0, <span class="string">&quot;123\n\0&quot;</span>, 0x80) =40</span><br><span class="line">write(0x1, <span class="string">&quot;123\n@\213\002\0&quot;</span>, 0x4) =40</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建文件&#x2F;&#x2F;同样的cat使用即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> open.c</span><br><span class="line">cc -o open open.c</span><br><span class="line">./open</span><br><span class="line"><span class="built_in">cat</span> output.txt</span><br><span class="line">//note:creat()调用open()</span><br><span class="line">//note:这些代码忽略错误，一般不要这么写</span><br></pre></td></tr></table></figure>
</li>
<li><p>更有趣的程序：shell（就是你的terminal ）</p>
<ul>
<li><p>通过它你才能使用命令，和内核交互，进行系统调用</p>
</li>
<li><p>一些例子&#x2F;&#x2F;查或者实践，得到这些命令的意义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> &gt;junk</span><br><span class="line"><span class="built_in">ls</span> |<span class="built_in">wc</span> -l</span><br><span class="line"><span class="built_in">ls</span> |<span class="built_in">wc</span> -l &gt;junk</span><br></pre></td></tr></table></figure>
</li>
<li><p>shell里面的命令很多功能也很强大，你可以当作一门新的语言来稍作学习</p>
</li>
<li><p>同时，通过这些命令，你也能写一个脚本来在shell上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; script</span><br><span class="line">	<span class="built_in">echo</span> one</span><br><span class="line">	<span class="built_in">echo</span> two//按ctrl+c退出</span><br><span class="line">sh &lt; script//使用该脚本</span><br><span class="line">//哈哈我第一次把最后一行命令也输了进去，然后无限循环</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上的命令使用了ls, cat, pipe, wc这些常用的命令，了解他们的功能和配合</p>
</li>
</ul>
</li>
<li><p>让我们看看一个简单的sh.c执行过程：明白fork,wait,execv,pipe功能和配合即可</p>
<ul>
<li><p>main()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">首先编译为一棵树，然后执行main进程：getcmd, fork, wait</span><br><span class="line">执行子进程:parsecmd, runcmd</span><br><span class="line"></span><br><span class="line">为什么fork（）来产生子进程？</span><br><span class="line">这是一种组织方式，以后就知道了</span><br><span class="line"></span><br><span class="line">fork()功能？</span><br><span class="line"><span class="number">1.</span>复制：</span><br><span class="line">		复制用户的内存</span><br><span class="line">		分组值内核状态，fd </span><br><span class="line">	因此子进程几乎和父进程相同：如果不了解进程，你可以先思考：进程即“进行的程序”,一个进程在机器上需要哪些东西才能称之为进程？然后在后续的学习中验证你的想法</span><br><span class="line"><span class="number">2.</span>子进程pid不同于父进程，fork（）函数返回子pid，而子进程pid我们让它返回<span class="number">0</span>，这样进程使用时候来区分</span><br><span class="line"><span class="number">3.</span>紧接着运行，然后根据系统的调度（你可以认为随机，因为你管不着）两个进程的切换</span><br><span class="line"></span><br><span class="line">wait（）是什么？</span><br><span class="line">父进程fork（）后会wait（），等待子进程结束后得到一些信息，给一个实例：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> p1 = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">pid_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	p1 = fork();	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p1 == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里一定是子进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子进程，pid = %d.\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p1 &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里一定是父进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent.\n&quot;</span>);</span><br><span class="line">		ret = wait(&amp;status);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子进程已经被回收，子进程pid = %d.\n&quot;</span>, ret);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子进程是否被正常回收: %d.\n&quot;</span>, WIFEXITED(status));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里一定是fork出错了</span></span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果子进程在父进程call wait（）之前结束了怎么办？</span><br><span class="line">你猜</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>runcmd（）:就是跟你shell有关的调用</p>
<ul>
<li>是一种简单的，重定向，管道概念的cmd类型</li>
<li>通过parsecmd（）执行转换树</li>
<li>调用execvp(cmd, args)</li>
<li>即从内存加载可执行文件到进程里</li>
<li>跳回main程序&#x2F;&#x2F;只有出错才有返回值</li>
<li>此时：子进程对execvp没有感知，父进程仍然等待子进程</li>
</ul>
</li>
<li><p>runcmd如何处理IO重定向？例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt; junk</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为什么重定向？子进程的缘故</p>
</li>
<li><p>哪里重定向？shell中的子进程</p>
</li>
<li><p>改什么？由于不同进程的不同fd表，所以改fd：从0改为1</p>
</li>
<li><p>是Parsecmd()的作用：从两个节点开始产生树</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd-&gt;<span class="built_in">type</span>=<span class="string">&#x27;&gt;&#x27;</span>, cmd-&gt;file=<span class="string">&quot;junk&quot;</span>, cmd-&gt;cmd=...</span><br><span class="line">      cmd-&gt;<span class="built_in">type</span>=<span class="string">&#x27; &#x27;</span>, cmd-&gt;argv=[<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;hello&quot;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>open()，dup2()产生了fd&#x3D;1（子进程）</p>
</li>
</ul>
</li>
<li><p>为什么fork要和exec区分？</p>
<ul>
<li>想想fork干了什么，exec干了什么，你就知道两个干的不是一件事</li>
</ul>
</li>
<li><p>如何实现pipe？</p>
<p>ls |wc -l</p>
</li>
<li><p>内核提供pipe抽象在fd表（告诉你pipe的一些实现）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd[2]:一个写fd，一个读fd</span><br><span class="line">还有一个buffer</span><br></pre></td></tr></table></figure>


</li>
<li><p>具体例子：pipe1.c：直到数据可用时读，直到buffer满时写</p>
</li>
<li><p>因此，pipe的功能：进程之间通过fork保存了fd来成功通信</p>
</li>
<li><pre><code class="bash">对于
ls |wc -l，shell做的事
    - 创建管道
    - fork
    - 设置fd为1来保证写
    - 执行ls：写入buffer
    - 设置fd为0来保证读
    - 执行wc：读buffer
    - 等待
ps：写动作会在末尾加一个EOF代表结束
</code></pre>
</li>
<li><p>不用担心，这些东西告诉你抽象的过程，后续的具体实现都会涉及</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L14：Linux_ext3_崩溃恢复</title>
    <url>/2024/03/08/L14%EF%BC%9ALinux_ext3_%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>



<h1 id="讲课计划"><a href="#讲课计划" class="headerlink" title="讲课计划"></a>讲课计划</h1><p>  记录崩溃恢复<br>    xv6：缓慢且立即耐用<br>    ext3：快速但不立即耐用<br>  权衡：性能与安全</p>
<span id="more"></span>

<p>示例问题：<br>  附加到文件<br>  两个写：<br>    在位图中标记块非空闲<br>    将块 # 添加到 inode addrs[] 数组<br>  我们想要原子性：两者兼而有之<br>  所以我们不能一次写一个 FS</p>
<p>为什么要登录？<br> 原子系统调用wrt崩溃<br> 快速恢复（没有长达一小时的 fsck）</p>
<p>xv6 日志回顾<br>  [缓存、磁盘日志、磁盘文件系统]<br>  每个系统调用都是一个事务<br>  系统调用更新内存中的缓存块<br>  在系统调用结束时：<br>    将修改后的块写入磁盘<br>    写入块 #s 和“完成”以登录磁盘——提交点<br>    在磁盘上的 FS 中安装修改后的块<br>      如果我们中途崩溃，恢复可以重播日志中的所有写入<br>      规则：在日志中提交所有写入之前不要开始 FS 写入<br>            即全有或全无——原子<br>    从登录磁盘上擦除“完成”<br>      所以来自下一个 xaction 的记录块看起来没有提交</p>
<p>在家工作<br>   回声嗨 &gt; 一个<br>   commit() 被黑客入侵以忽略其中一个写入，在 commit+install 后崩溃<br>   和恢复被禁用<br>   问：为什么“cat a”（崩溃后）会产生“panic: ilock: no type”？<br>      损坏的 commit() 更新了目录条目但不是 i-node<br>      所以 dirent 在磁盘上并包含 inode#<br>      但 i-node 被标记为空闲 (type&#x3D;0)<br>   Q：恢复后，为什么“cat a”会产生一个空文件？<br>      即使我们运行了“echo hi &gt; a”？<br>      恢复将 inode 写入正确的位置<br>        它现在已分配，并且 dirent 有效<br>      但是 create 和 write 是独立的系统调用和事务<br>        echo 从未调用过 write() – 在文件创建过程中崩溃</p>
<p>xv6 的日志记录有什么问题？它很慢！<br>  每次系统调用后立即提交<br>  提交后立即写入 FS<br>    必须这样做才能重用磁盘日志——即运行下一个系统调用<br>  任何 commit() 期间的所有新系统调用都会阻塞<br>    所以如果有多个进程，并发执行不会太多<br>  每个块两次写入磁盘，一次写入日志，一次写入 FS<br>    对于元数据块来说还不错<br>    大文件的痛苦<br>  所以：<br>    这些写入是同步的——xv6 在继续之前等待每个写入完成<br>    创建一个空文件需要 6 次同步磁盘写入——60 毫秒<br>    所以每秒只有 10 或 20 个磁盘更新系统调用</p>
<p>Linux的ext3设计<br> 将日志记录添加到文件系统所需的详细信息的案例研究<br> Stephen Tweedie 2000 谈话记录“EXT3，日志文件系统”<br>   <a href="http://olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html">http://olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html</a><br> ext3 向 ext2（以前的无日志文件系统）添加日志<br> 有很多模式，我将从“日志数据”开始<br>   日志包含元数据和文件内容块</p>
<p>ext3 结构：<br>  在记忆中：<br>    回写块缓存<br>    每笔交易信息：<br>      要记录的块#s 集<br>      一组出色的“句柄”——每个系统调用一个<br>  在磁盘上：<br>    FS<br>    循环日志</p>
<p>ext3 日志中有什么？<br> 记录超级块：记录最早有效交易的偏移量和起始序列号<br>   （这不是 FS 超级块；它是日志文件开头的块）<br> 描述符块：magic、seq、块#s<br> 数据块（如描述符所描述的）<br> 提交块：魔术，序列<br> |超级：偏移+序列#| … |描述符 4|…块…|提交 4| |描述符 5|…</p>
<p>ext3 如何获得良好的性能？<br>  分批<br>    每隔几秒提交一次，而不是在每次系统调用之后<br>    所以每个事务都包含许多系统调用<br>  为什么批处理有助于提高性能？<br>    1. 将固定的交易成本（描述符和数据块）摊销在许多交易上<br>    2.“写吸收”<br>       批处理中的许多系统调用可能会修改同一个块（i-node、bitmap、dirent）<br>       因此一个磁盘写入许多系统调用的更新<br>    3. 更好的并发性——减少等待前一个系统调用完成提交</p>
<p>注意：系统调用在安全到达磁盘之前返回<br>  这会影响应用程序级别的崩溃恢复情况<br>  例如，邮件服务器接收消息，写入磁盘，然后回复“OK”</p>
<p>ext3 允许并发事务和系统调用<br>  可能有多个事务：<br>    一些完全提交在磁盘日志中<br>    一些做日志写入作为提交的一部分<br>    <em>一个</em>接受新系统调用的“打开”事务 </p>
<p>ext3 系统调用代码：<br>  系统打开（）{<br>    h &#x3D; 开始（）<br>    获取（h，块#）<br>    修改缓存中的块<br>    停止（小时）<br>  }<br>  开始（）：<br>    告诉日志系统进行一组写操作，直到 stop() 原子化<br>    日志系统必须知道未完成的系统调用集<br>      在它们全部完成之前不能提交<br>    如果需要，start() 可以阻止这个系统调用<br>  得到（）：<br>    告诉日志系统我们将修改缓存块<br>      添加到要记录的块列表<br>    在 xaction 提交之前阻止将块写入磁盘<br>  停止（）：<br>    stop() 不会<em>不会</em>导致提交<br>    如果所有包含的系统调用都调用了 stop()，则事务可以提交</p>
<p>将事务提交到磁盘</p>
<ol>
<li>阻止新的系统调用</li>
<li>等待正在进行的系统调用 stop()</li>
<li>开启一个新的事务，解锁新的系统调用</li>
<li>写入描述符以登录到带有块列表的磁盘#s</li>
<li>将缓存中的每个块写入到登录磁盘</li>
<li>等待所有日志写入完成</li>
</ol>
<pre><code>7.写提交记录
</code></pre>
<ol start="8">
<li>现在缓存块允许进入磁盘上的家（但不是强制的）</li>
</ol>
<p>系统调用 B 可以读取系统调用 A 的未提交结果吗？<br>  答：rm x<br>  B: echo &gt; y – 重新使用 x 释放的 i-node<br>  B 可以先提交，以便崩溃会显示异常吗？<br>  情况 1：两者都在同一个 xaction 中——好的，两者都不是<br>  case 2: A in T1, B in T2 – ok, ext3 按顺序提交事务<br>  情况 3：T1 中的 B，T2 中的 A<br>    在 T1：|–B–|<br>    在 T2：|–A–|<br>    B 能看到 A 没有 y 的 i 节点吗？<br>      毕竟，A 写入的缓存与 B 读取的缓存相同<br>      坏：T1 后崩溃可能会使用 i 节点同时保留 x 和 y<br>    否：ext3 等待 prev xaction 中的所有系统调用完成<br>      在让任何人进入下一次之前<br>      因此 B（在 T1 中）在 ext3 让 A（在 T2 中）开始之前完成<br>      所以 B 不会看到 A 的任何写入<br>      因此：<br>        T1：|-系统调用-|<br>        T2：|-系统调用-|<br>        T3：|-系统调用-|<br>  更大的一点：<br>    提交顺序必须与提交的顺序一致<br>      系统调用读&#x2F;写状态。<br>    也许 ext3 在这里牺牲了一些性能以获得正确性。</p>
<p>T2 中的系统调用写入一个也在 T1 中写入的块是否安全？<br>  ext3 允许 T2 在 T1 完成提交之前启动——可能需要一段时间<br>    T1: |-syscalls-|-commitWrites-|<br>    T2：|-syscalls-|-commitWrites-|<br>  危险：<br>    T1 系统调用写入块 17<br>    T1 关闭，开始将缓存块写入日志<br>    T2启动，一个T2系统调用也写入块17<br>    T1 可以将 T2 修改后的第 17 块写入日志中的 T1 事务吗？<br>    坏：不是原子性的，从那以后崩溃会留下一些但不是全部 T2 的写入提交<br>  所以：<br>    ext3 为 T1 提供了块缓存的私有副本，因为它在 T1 关闭时存在<br>    T1 从缓存的这个快照提交<br>    使用写时复制很有效<br>    副本允许 T2 中的系统调用在 T1 提交时继续进行<br>  要点：<br>    正确性需要崩溃后+恢复状态，就像系统调用一样<br>      以原子方式和顺序执行<br>    ext3 使用各种技巧来允许一些并发</p>
<p>ext3 什么时候可以重用事务 T1 的日志空间？<br>  （日志是圆形的）<br>  一次：<br>    T1 之前的所有事务都已在日志中释放，并且<br>    T1的缓存块已经全部写入磁盘上的FS<br>  自由 &#x3D;&#x3D; 提前记录超级块的起始指针&#x2F;序列</p>
<p>如果日志中没有足够的可用空间用于系统调用怎么办？<br>  假设我们开始将系统调用的块添加到 T2<br>  中途，意识到 T2 不适合磁盘<br>  我们不能提交 T2，因为系统调用没有完成<br>  我们也不能退出这个系统调用<br>    无法撤消系统调用<br>    T2 中的其他系统调用可能已读取其修改</p>
<p>解决方案：预订<br>  syscall 预先声明它可能需要多少块日志空间<br>  ext3 的 start() 会阻止系统调用，直到有足够的可用空间<br>  可能需要提交打开的事务，然后释放旧的事务<br>    好的，因为保留意味着所有启动的系统调用都可以完成 + 提交</p>
<p>表现？<br>  rm * 在一个包含 100 个文件的目录中<br>  xv6：超过 10 秒——每个系统调用六个同步磁盘写入<br>  ext3：总共大约 20 毫秒<br>  rm * 重复写入相同的目录和 inode 块<br>    直到提交，只更新缓存的块，没有磁盘写入<br>  然后提交几个元数据块<br>  多久做一次提交？<br>    记录一些块（inode，dirent）<br>    等待磁盘说写在磁盘上<br>    然后写提交记录<br>    两次旋转，或总共约 20 毫秒<br>    现代磁盘接口可以避免浪费革命</p>
<p>如果崩溃怎么办？<br>  崩溃可能会中断写入最后一个 xaction 以登录磁盘<br>  所以磁盘可能有一堆完整的 xactions，然后可能有一个部分<br>  也可能将一些块缓存写入磁盘<br>    但仅适用于完全提交的 xactions，而不是部分最后一个</p>
<p>恢复是如何工作的<br>  1.找到日志的开始——第一个未释放的描述符<br>     日志“超级块”包含第一笔交易的偏移量和序列号<br>     （释放日志空间时高级）<br>  2.找到日志的结尾<br>     扫描直到坏魔法或不是预期的 seq #<br>     返回上次提交记录<br>     提交期间崩溃 -&gt; 没有提交记录，恢复忽略<br>  3.通过最后一个完整的xaction重播所有块，按日志顺序</p>
<p>如果最后一个有效日志块之后的块看起来像一个日志描述符怎么办？<br>  也许是以前使用日志遗留下来的描述符块？<br>    seq # 会太低<br>  也许某些文件数据恰好看起来像一个描述符？<br>    记录的数据块不能包含幻数！<br>    ext3 禁止记录数据块中的幻数 -&gt; 描述符中的标志</p>
<p>“有序数据”模式（到目前为止我们一直在谈论“日志数据”模式）<br>  日志文件内容很慢，每个数据块写入两次<br>  我们可以从日志中完全省略文件内容吗？<br>  如果我们这样做了，我们什么时候将文件内容写入 FS？<br>  我们可以随时写入文件内容块吗？<br>    否：如果首先提交元数据，崩溃可能会留下文件指向<br>        使用其他人的数据写入未写入的块<br>  ext3“有序数据”模式：<br>    不要将文件内容写入日志<br>    将内容块写入磁盘 * 之前 * 提交具有新大小和块的 inode #<br>  如果没有崩溃，就没有问题——读者会看到写入的数据<br>  如果在提交前崩溃：<br>    [图表：i-node和位图以及内存中的新数据，磁盘上的新数据，<br>              但磁盘上的 i-node 和位图未更新]<br>    块有新数据<br>    也许不可见，因为 i-node 大小和块列表没有更新<br>    没有元数据不一致<br>      i-node 和空闲位图写入仍然是原子的<br>  大多数人使用 ext3 有序模式</p>
<p>带有有序模式的正确性挑战：<br>  A. rmdir, 重用块 for write() 到某个文件，<br>       在 rmdir 或写入提交之前崩溃<br>     恢复后，就好像 rmdir 从未发生过一样，<br>       但目录块已被覆盖！<br>     修复：在释放系统调用之前不能重用已释放的块<br>  B. rmdir，提交，重用文件中的块，有序文件写入，提交，<br>       崩溃+恢复，重放 rmdir<br>     文件留下目录内容，例如 . 和 ..<br>       因为不重放文件内容写入<br>     修复：将“撤销”记录放入日志，防止给定块的日志重放<br>  注意：由于更改块的类型（内容与元数据）而导致的两个问题<br>    所以另一个解决方案可能是永远不要这样做</p>
<p>规则概要<br>  经典的预写日志规则：<br>    在磁盘日志中提交之前，不要将元数据块写入磁盘文件系统<br>  在启动 T2 之前等待 T1 中的所有系统调用完成<br>  在日志中之前不要覆盖缓冲区缓存中的块<br>  在所有块都写入 FS 之前不要释放日志空间<br>  订购模式：<br>    提交前将数据块写入 FS<br>    在提交释放系统调用之前不要重用空闲块<br>    不要重播已撤销的系统调用</p>
<p>另一个极端情况：打开 fd 并取消链接<br>  打开一个文件，然后取消链接<br>  取消链接提交<br>  文件已打开，因此取消链接会删除目录条目但不会释放块<br>  碰撞<br>  日志中没有什么有趣的东西可以重播<br>  inode 和 blocks 不在空闲列表中，也无法通过任何名称访问<br>    永远不会被释放！哎呀<br>  解决方案：将inode添加到从FS超级块开始的链表中<br>    连同删除目录一起提交<br>  恢复查看该列表，完成删除</p>
<p>校验和<br>  回想一下：在写入提交块之前，事务的日志块必须在磁盘上<br>    ext3 在开始提交块写入之前等待磁盘说“完成”<br>  风险：磁盘通常具有写入缓存并重新排序写入，以提高性能<br>    有时很难关闭（磁盘位于）<br>    人们经常出于无知而启用重新排序以加快速度<br>    坏消息，如果磁盘在事务的其余部分之前写入提交块<br>  解决方案：提交块包含所有数据块的校验和<br>    恢复时：计算数据块的校验和<br>    如果匹配提交块中的校验和：安装事务<br>    如果不匹配：不安装交易<br>  ext4 有日志校验和</p>
<p>ext3 是否修复了 xv6 日志性能问题？<br>  同步写入磁盘日志——是的，但 5 秒窗口<br>  微小更新 -&gt; 整个块写入 - 也许（如果系统调用允许写入吸收）<br>  提交后同步写入主位置 - 是<br>  ext3&#x2F;ext4 非常成功！</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L13：崩溃恢复，日志记录</title>
    <url>/2024/03/08/L13%EF%BC%9A%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%EF%BC%8C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="课程总览"><a href="#课程总览" class="headerlink" title="课程总览"></a>课程总览</h1><p>  问题：崩溃恢复<br>    崩溃导致磁盘文件系统不一致<br>  解决方案：<br>    日志记录</p>
<span id="more"></span>

<p>Ps：这是最后一次 xv6 讲座<br>  下周我们将转向论文</p>
<h1 id="为什么要崩溃恢复"><a href="#为什么要崩溃恢复" class="headerlink" title="为什么要崩溃恢复"></a>为什么要崩溃恢复</h1><p>什么是崩溃恢复？<br>  你正在编写文件系统<br>  然后停电<br>  你重启<br>  你的文件系统还能用吗？</p>
<p>问题：<br>  多步操作时崩溃<br>  可能会违反 FS 不变量<br>  重启后：<br>    坏：由于损坏的 FS 再次崩溃<br>    更糟糕的是：没有崩溃，但读取&#x2F;写入不正确的数据</p>
<p>例子：</p>
<p><a href="https://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html">目录项</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create:</span><br><span class="line">   新建目录项</span><br><span class="line">   分配一个inode</span><br><span class="line">   突然断电:你的目录指向了一个free的inode  -- disaster!</span><br><span class="line">     突然又断电了, 或许那时候inode因为其他文件的创建被分配</span><br><span class="line">   突然断电: inode 并不是free但是不能使用 -- 不是很糟糕</span><br><span class="line"> write:</span><br><span class="line">   inode addrs[] and len</span><br><span class="line">   使用了间接 block</span><br><span class="line">   block content</span><br><span class="line">   block free bitmap</span><br><span class="line">   突然断电: inode 指向一个free的block -- disaster!</span><br><span class="line">   突然断电: block 并不是free但是不能使用 -- 不是很糟糕</span><br><span class="line"> unlink:</span><br><span class="line">   block free bitmaps</span><br><span class="line">   free inode</span><br><span class="line">   清除目录项</span><br></pre></td></tr></table></figure>

<p>我们能希望结果是什么？<br>  重新启动并运行恢复代码后<br>  1.保持FS内部不变量<br>     例如，空闲列表和文件中都没有块</p>
<ol start="2">
<li>除了最后几个操作之外的所有操作都保存在磁盘上<br>例如，我昨天写的数据被保留了<br>但也许不是我在崩溃时写的数据<br>所以用户可能需要检查最后几个操作</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3.无事物异常</span><br><span class="line"> <span class="built_in">echo</span> 99 &gt; 结果；<span class="built_in">echo</span> <span class="keyword">done</span> &gt; state</span><br></pre></td></tr></table></figure>

<p><strong>正确性和性能经常发生冲突</strong><br>  磁盘写入很慢！<br>  安全 &#x3D;&gt; 尽快写入磁盘<br>  速度 &#x3D;&gt; 不写入磁盘（批处理、回写缓存、按轨道排序）</p>
<p>崩溃恢复是一个反复出现的问题<br>  出现在所有存储系统中，例如数据库<br>  多年来，很多工作都进入了解决方案<br>  许多巧妙的性能&#x2F;正确性权衡</p>
<h1 id="日志解决方案"><a href="#日志解决方案" class="headerlink" title="日志解决方案"></a>日志解决方案</h1><p>最流行的解决方案：日志记录<br>  目标：<strong>原子</strong>系统调用wrt崩溃<br>  目标：<strong>快速恢复</strong>（没有长达一小时的 fsck）</p>
<p>将分两步介绍日志<br>  第一个xv6的日志，只提供安全和快速恢复<br>  然后是Linux EXT3，正常运行也很快（查看本文件夹下的论文和另一节课笔记）</p>
<p>日志背后的基本思想<br>  你想要原子性：所有系统调用的写入，或者没有<br>    让我们将原子操作称为“事务”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.记录所有写入系统调用在磁盘上的日志（日志）</span><br><span class="line">2.然后在磁盘上记录“完成”（提交）</span><br><span class="line">3.然后做 FS 磁盘写入（安装）</span><br><span class="line">日志的记录为什么能够在崩溃后恢复起作用？因为日志记录了应该改动的地方，而这比磁盘写入快很多，或许这跟git的commit <span class="built_in">hash</span>原理相近？</span><br></pre></td></tr></table></figure>

<p>  关于崩溃+恢复：<br>    ！！如果在日志中“完成”，则重播日志中的所有写入<br>    如果没有“完成”，则忽略日志<br>  这是一个可写的日志</p>
<p>预写日志规则<br>  写日志直到“完成”标志后，再真正写文件入磁盘</p>
<p>为什么是这种规则？<br>  一旦我们安装了一个写入磁盘文件的文件，<br>  我们必须做<em>所有</em>交易的其他<br>  写——所以事务是<strong>原子</strong>的。我们有<br>  为第一次安装后的<strong>崩溃做好准备</strong><br>  写入，因此其他写入必须仍然可用<br>  崩溃后——在日志中。</p>
<p>日志是魔法<br>  复杂可变数据结构的崩溃恢复通常很难<br>  日志记录通常可以在现有存储系统上分层<br>  并且它与高性能兼容（下周的主题）</p>
<p>挑战：防止从缓存写回<br>  系统调用可以安全地更新 <em>cached</em> 块，<br>    但是块不能写入FS<br>    直到事务提交（write back回写）<br>  棘手，因为例如缓存可能会耗尽空间，<br>    并试图按顺序逐出一些条目<br>    读取和缓存其他数据。<br>  考虑创建示例：<br>    将脏 inode 写入日志<br>    将目录块写入日志<br>    驱逐脏的 inode<br>  解决方案：<br>    确保缓冲区缓存足够大<br>    在缓冲区缓存中固定脏块<br>    提交后，取消锁定块</p>
<h2 id="xv6-日志表示"><a href="#xv6-日志表示" class="headerlink" title="xv6 日志表示"></a>xv6 日志表示</h2><p>  [图表：</p>
<p>​			缓冲区缓存，内存日志块#数组，<br>​            磁盘上的 FS 树、磁盘上的日志头和块</p>
<p>]</p>
<p>写入：</p>
<p>  在写入时将 blockno 添加到内存数组<br>  将数据本身保存在缓冲区缓存中<br>提交时：<br>    1.将缓冲区写入磁盘上的日志<br>    等待磁盘完成写入（“同步”）<br>    2.将日志头扇区写入磁盘<br>      块号<br>      非零“n”<br>  提交后：<br>    将日志中记录的文件块（写入）到它们在 FS 中的主位置<br>    在磁盘上的日志标题中将零写入“n”</p>
<p>磁盘日志头中的“n”值表示提交<br>  非零 &#x3D;&#x3D; 已提交，日志内容有效并且是一个完整的事务<br>  零 &#x3D;&#x3D; 未提交，可能不完整，恢复应忽略日志<br>  写入非零“n”是“提交点”</p>
<p>挑战：<strong>系统的调用数据必须适合日志</strong><br>  计算每个系统调用写入的块数的上限<br>    设置日志大小 &gt;&#x3D; 上限<br>  将一些系统调用分解成几个事务</p>
<p>挑战：<strong>允许并发系统调用</strong><br>  必须允许来自多个调用的写入记录在日志中<br>  提交时必须将它们全部写入<br>  但是不能从仍在事务中的调用中写入数据</p>
<h2 id="xv6-解决方案"><a href="#xv6-解决方案" class="headerlink" title="xv6 解决方案"></a>xv6 解决方案</h2><p>  如果数据可能不适合日志，则不允许启动新的系统调用<br>    必须等待当前调用完成并提交<br>  当进行中的调用数量降为零时（规定了并发调用数？）<br>    提交<br>    释放日志空间<br>    唤醒等待的调用</p>
<p>挑战：一个区块可能在一个交易中被多次写入<br>  写入仅影响内存中的缓存块<br>  所以一个缓存块可能会反映多个未提交的事务<br>  但只有在没有进行中的事务时才会安装<br>    所以安装的块只反映提交的事务<br>  有利于性能：“写吸收”</p>
<p>带有块号的 xv6 磁盘布局<br>   2：日志头<br>  32：索引节点<br>  58：位图<br>  63：内容块</p>
<p>让我们看一个例子。<br>  我修改了 bwrite() 来打印低级磁盘写入，<br>  即在事务提交期间发生的磁盘写入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a &gt; x</span><br><span class="line"> // create</span><br><span class="line"> bwrite 3   inode, 35</span><br><span class="line"> bwrite 4   directory content, 63</span><br><span class="line"> bwrite 2   commit (block <span class="comment">#s and n)</span></span><br><span class="line"> bwrite 35  install inode</span><br><span class="line"> bwrite 63  install directory content</span><br><span class="line"> bwrite 2   mark <span class="built_in">log</span> <span class="string">&quot;empty&quot;</span></span><br><span class="line"> // write</span><br><span class="line"> bwrite 3</span><br><span class="line"> bwrite 4</span><br><span class="line"> bwrite 5</span><br><span class="line"> bwrite 2</span><br><span class="line"> bwrite 58   bitmap</span><br><span class="line"> bwrite 533  x</span><br><span class="line"> bwrite 35   inode (file size)</span><br><span class="line"> bwrite 2</span><br><span class="line"> // write</span><br><span class="line"> bwrite 3</span><br><span class="line"> bwrite 4</span><br><span class="line"> bwrite 2</span><br><span class="line"> bwrite 533  \n</span><br><span class="line"> bwrite 35   inode</span><br><span class="line"> bwrite 2</span><br></pre></td></tr></table></figure>

<p>让我们看看第二个事务，一个 write()<br>  第一个文件.c:syswrite<br>    计算在日志满之前我们可以写多少块<br>    在一个事务中写入那么多块</p>
<p>  结合 fs.c:writei<br>    begin_op（）<br>      bmap() – 可以写位图，间接块<br>      bread（）<br>      <strong>修改bp-&gt;data</strong><br>      Log_write（）<br>      iupdate()——写入inode<br>    end_op（）</p>
<p>  log.c 中的 begin_op()：<br>    需要指明哪组写入必须是原子的！<br>    需要检查日志是否正在提交<br>    需要检查我们的写入是否适合日志的其余部分<br>  日志写（）：<br>    将扇区 # 添加到内存数组<br>    设置 B_DIRTY，这样 bio.c 就不会驱逐它<br>  结束操作（）：<br>    如果没有未完成的操作，则提交<br>  commit（）：<br>    将更新的块从缓存复制到登录磁盘<br>    在磁盘<strong>日志标头</strong>中记录扇区 #s 和“完成”<br>    安装写入——从磁盘日志复制到磁盘文件系统<br>      ide.c 将清除写入块的 B_DIRTY — 现在它可以被驱逐<br>    从日志中删除“完成”</p>
<h3 id="如果我们在交易过程中崩溃了会发生什么？"><a href="#如果我们在交易过程中崩溃了会发生什么？" class="headerlink" title="如果我们在交易过程中崩溃了会发生什么？"></a>如果我们在交易过程中崩溃了会发生什么？</h3><p>  内存丢失，只剩下崩溃时的磁盘<br>  在使用 FS 之前，内核在引导期间调用 recovery_from_log()<br>    如果日志标题块显示“完成”：<br>      将块从日志复制到磁盘上的实际位置<br>  磁盘日志中有什么？<br>    提交前崩溃<br>    提交期间崩溃——提交点？<br>    install_trans() 期间崩溃<br>    重启后崩溃，而在recover_from_log()<br>  注意：可以多次重放日志！因为我们的恢复是幂等的<br>    只要没有其他活动干预</p>
<p>注意 xv6 假设磁盘是故障停止的<br>  <strong>它要么正确写入，要么不写入</strong>（通过log的完成标志进行决定）<br>    即可能由于电源故障而无法进行最后一次写入<br>  因此：<br>    没有部分写入（每个扇区写入都是原子的）<br>    没有疯狂的写作<br>    没有扇区衰减（没有读取错误）<br>    没有读取错误的扇区</p>
<p>xv6 的日志设计有什么好处？<br>  由于预写日志的正确性<br>  良好的磁盘吞吐量：日志自然批量写入<br>    但数据磁盘块被写入两次<br>  并发</p>
<p>xv6 的日志记录有什么问题？<br>  <strong>效率不高</strong>：<br>    每个块被写入两次（日志和实际写入）<br>    <strong>即使只修改了几个字节，也会记录整个块</strong><br>    同步写入每个日志块<br>      可以批量写入，只能同步写入头<br>    日志写入和安装写入是立即的<br>      我们可以假设两者都可能是懒惰的，为了更多的写作吸收（意思是先记录，后一起写入）<br>      ！！但还是要先写日志<br>  不适合日志的操作有问题<br>    在截断文件时取消链接可能会弄脏许多块（意思是如果我删除文件，相关的文件块部分或许只是在日志上反馈，实际的块没有直接释放）</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L12：文件系统</title>
    <url>/2024/03/08/L12%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="课程总览"><a href="#课程总览" class="headerlink" title="课程总览"></a>课程总览</h1><p>  文件系统<br>  磁盘<br>  磁盘布局<br>  xv6 案例研究</p>
<span id="more"></span>

<h1 id="问题开胃"><a href="#问题开胃" class="headerlink" title="问题开胃"></a>问题开胃</h1><p>为什么文件系统有用？<br>  重启的持久性：为了系统崩溃后恢复时数据的稳定<br>  命名和组织：方便<br>  在程序和用户之间共享：我们通过pathname找到文件，而不是块或者页，符合人的习惯</p>
<p>为什么有趣？<br>  崩溃恢复<br>  表现<br>  分享<br>  安全<br>  抽象很有用：管道、设备、&#x2F;proc、&#x2F;afs、Plan 9<br>    所以面向 FS 的应用程序可以处理多种对象<br>  你将为 JOS 实现一个</p>
<p>API 示例——UNIX&#x2F;Posix&#x2F;Linux&#x2F;xv6&#x2F;&amp;c：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;x/y&quot;</span>, -);</span><br><span class="line"> write（fd，“ABC”，3）；</span><br><span class="line"> <span class="built_in">link</span>（“x/y”，“x/z”）；</span><br><span class="line"> <span class="built_in">unlink</span>（“x/y”）；</span><br></pre></td></tr></table></figure>

<p>UNIX FS API 中可见的高级选项<br>  对象：文件（与虚拟磁盘、DB）<br>  内容：字节数组（对比 80 字节记录，BTree）<br>  命名：人类可读（与对象 ID）<br>  组织：名称层次结构<br>  同步：无（与锁定，版本）<br>  还有其他文件系统 API，有时完全不同！</p>
<p>API 的一些含义：<br>  fd 指的是file descriptor：句柄（可以理解为一种多级指针）<br>    即使文件名更改也会保留<br>    或者如果文件在打开时被删除！<br>  一个文件可以有多个链接（pathname）<br>    即出现在多个目录中<br>    这些事件中没有一个是特别的<br>    所以文件必须有信息存储在目录以外的地方：info node<br>  因此：<br>    FS 在磁盘上的“inode”中记录文件信息<br>    FS 指的是带有 i-number 的 inode（FD 的内部版本）<br>    inode 必须有链接数（告诉我们何时释放）<br>    inode 必须有打开的 FD 数<br>    inode 解除分配推迟到最后一个链接和 FD 消失</p>
<h1 id="让我们谈谈-xv6"><a href="#让我们谈谈-xv6" class="headerlink" title="让我们谈谈 xv6"></a>让我们谈谈 xv6</h1><p>FS 软件层<br>  系统调用<br>  名称操作 | FD 操作<br>  节点<br>  节点缓存<br>  日志<br>  缓冲区缓存<br>  驱动程序</p>
<h3 id="xv6的文件系统磁盘布局"><a href="#xv6的文件系统磁盘布局" class="headerlink" title="xv6的文件系统磁盘布局"></a>xv6的文件系统磁盘布局</h3><p>IDE 是与设备对话的标准<br>  <a href="https://en.wikipedia.org/wiki/Parallel_ATA">https://en.wikipedia.org/wiki/Parallel_ATA</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">先进技术附件（英语：Advanced Technology Attachment，简称“ATA”）是用于连接存储设备的接口标准，与由集成驱动电子设备（英语：Integrated Drive Electronics，简称IDE）技术实现的磁盘驱动器关系最密切。</span><br><span class="line"></span><br><span class="line">IDE是一种计算机系统接口，主要用于硬盘和CD-ROM，本意为“把控制器与盘体集成在一起的硬盘”。数年以前PC主机使用的硬盘，大多数都是IDE兼容的，只需用一根电缆将它们与主板或接口卡连起来就可以了，而目前主要接口为SATA接口。而在SATA技术日益发展下，支持ATA的主板已不再出现，而且Intel在新型的芯片组中已经不默认支持ATA接口，主机版厂商需要另加芯片去对ATA作出支持（通常是为了兼容旧有硬盘和光盘驱动器）。</span><br><span class="line"></span><br><span class="line">SATA（Serial ATA）于2002年推出后，原有的ATA改名为PATA（并行高技术配置，Parallel ATA）。[1] 2013年12月29日，西部数据正式停止PATA硬盘供应，而希捷科技则已停售产多年，这意味着1986年设计的PATA接口在经历27年后正式退出历史舞台[2][3]。</span><br><span class="line"></span><br><span class="line">一般说来，ATA是一个控制器技术，而IDE是一个匹配它的磁盘驱动器技术，但是两个术语经常可以互用。ATA是一个花费低而性能适中的接口，主要是针对台式机而设计的，销售的大多数ATA控制器和IDE磁盘都是更高版本的，称为ATA - 2和ATA - 3，与之匹配的磁盘驱动器称为增强的IDE。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  连接器、接口、协议等。<br>  CPU 与 IDE 控制器对话<br>  控制器与硬盘、SSD、CD-ROM 通信</p>
<p>硬盘驱动器 (HDD)<br>  同心轨道<br>  每个磁道是一个扇区序列，通常为 512 字节（柱面-&gt;磁道-&gt;扇区）<br>  磁头必须寻道，磁盘必须旋转<br>    随机访问很慢（每次访问 5 或 10 毫秒）<br>    顺序访问要快得多（100 MB&#x2F;秒）<br>  每个扇区的 ECC<br>  只能读&#x2F;写整个扇区<br>  因此：子扇区写入代价高昂（读-修改-写）</p>
<p>固态硬盘 (SSD)<br>  非易失性“闪存”存储器<br>  随机访问：100 微秒<br>  顺序：500 MB&#x2F;秒<br>  内部复杂——隐藏除了有时性能<br>    在重新写入之前必须擦除闪存<br>    限制可写入闪存块的次数<br>    SSD 应对一定程度的间接性——重新映射的块</p>
<p>对于 HDD 和 SSD：<br>  顺序访问比随机访问快得多<br>  大读&#x2F;写比小读&#x2F;写快<br>  这些都会影响 FS 设计和性能</p>
<p>磁盘块<br>  大多数 o&#x2F;s 使用多个扇区的块，例如 4 KB 块 &#x3D; 8 个扇区<br>  减少簿记和寻求管理费用<br>  为简单起见，xv6 使用单扇区块</p>
<p>磁盘布局<br>  第二个 IDE 驱动器上的 xv6 文件系统；首先只有内核<br>  xv6 将 IDE 驱动器视为<strong>扇区数组</strong>，忽略磁道结构</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/2021112822234.png">         0：未使用（boot sector）<br>  1：超级块（大小，ninodes）<br>  2：日志头<br>  32：inode 数组，打包成块<br>  58：块使用中的位图（0&#x3D;空闲，1&#x3D;使用)<br>  59：文件&#x2F;目录内容块</p>
<p>  磁盘结束</p>
<p>xv6 的 mkfs 程序为空文件系统生成此布局<br>  布局在文件系统的生命周期内是<strong>静态</strong>的</p>
<p>“元数据”metadata<br>  磁盘上除文件内容以外的所有内容<br>  超级块、索引节点、位图、目录内容</p>
<p>磁盘索引节点</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/2021112822936.png"></p>
<p> type（free、file, dir、dev)<br>  Link cnt<br>  size<br>  block addr[12+1]</p>
<p>直接块和间接块</p>
<p>例子：<br>  如何找到文件的字节 8000？<br>  逻辑块 15 &#x3D; 8000 &#x2F; 512<br>  间接块中的第三个条目</p>
<p>每个 i-node 都有一个 i-number<br>  !!很容易把 i-number 变成 inode<br>  inode 是 64 字节长<br>  磁盘上的字节地址：32<em>512 + 64</em>inum</p>
<p>目录内容<br>  目录当作一个文件<br>    但用户不能直接写<br>  内容是目录的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假如我有一个pathname：/home/hello/hello.c需要通过这个pathname和文件系统找到hello.c？</span><br><span class="line"><span class="number">1.</span>我只能访问根目录/</span><br><span class="line"><span class="number">2.</span>/文件里找到了home</span><br><span class="line"><span class="number">3.</span>home文件里找到了hello</span><br><span class="line"><span class="number">4.</span>hello文件里找到了hello.c</span><br><span class="line"></span><br><span class="line">以上，<span class="number">123</span>步骤中都是文件，但是他们都属于目录文件，只有hello.c才是我们要的目标文件。</span><br><span class="line">因此，假如我增加了这个文件hello.c，实际上向上相关的目录文件都会进行更改/增加，通过这种方式构造了一个文件树的概念</span><br></pre></td></tr></table></figure>

<p>  直接：<br>    枚举<br>    14 字节的文件名<br>  如果 inum 为零，dirent 是免费的</p>
<p>您应该将 FS 视为磁盘上的数据结构<br>  [树：目录、索引节点、块]<br>  有两个分配池：索引节点和块</p>
<p>让我们看看实际运行中的 xv6<br>  专注于磁盘写入<br>  通过如何更新说明磁盘上的数据结构</p>
<h3 id="问：xv6-如何创建文件？"><a href="#问：xv6-如何创建文件？" class="headerlink" title="问：xv6 如何创建文件？"></a>问：xv6 如何创建文件？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &gt; a</span><br><span class="line">write 34 ialloc (from create sysfile.c; mark it non-free)</span><br><span class="line">write 34 iupdate (from create; initialize nlink &amp;c)</span><br><span class="line">write 59 writei (from dirlink fs.c, from create)</span><br><span class="line"></span><br><span class="line">call graph:</span><br><span class="line">  sys_open      sysfile.c</span><br><span class="line">    create      sysfile.c</span><br><span class="line">      ialloc    fs.c</span><br><span class="line">      iupdate   fs.c</span><br><span class="line">      dirlink   fs.c</span><br><span class="line">        writei  fs.c</span><br></pre></td></tr></table></figure>

<p>问：第 34 块中有什么？<br>   查看 sysfile.c 中的 create()</p>
<p>问：为什么 <em>two</em> 写入块 34？</p>
<p>问：59 块是什么？</p>
<p>Q：如果<strong>并发</strong>调用ialloc怎么办？<br>   他们会得到相同的 inode 吗？<br>   在 ialloc 中注意面包 &#x2F; 写 &#x2F; brelse<br>   面包锁定块，可能等待，并从磁盘读取<br>   brese 解锁方块</p>
<h3 id="问：xv6-如何将数据写入文件？"><a href="#问：xv6-如何将数据写入文件？" class="headerlink" title="问：xv6 如何将数据写入文件？"></a>问：xv6 如何将数据写入文件？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> x &gt; a</span><br><span class="line">write 58 balloc  (from bmap, from writei)</span><br><span class="line">write 508 bzero</span><br><span class="line">write 508 writei (from filewrite file.c)</span><br><span class="line">write 34 iupdate  (from writei)</span><br><span class="line">write 508 writei</span><br><span class="line">write 34 iupdate</span><br><span class="line"></span><br><span class="line">call graph:</span><br><span class="line">  sys_write       sysfile.c</span><br><span class="line">    filewrite     file.c</span><br><span class="line">      writei      fs.c</span><br><span class="line">        bmap</span><br><span class="line">          balloc</span><br><span class="line">            bzero</span><br><span class="line">        iupdate</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>问：第 58 块中有什么？<br>   看看 writei 对 bmap 的调用<br>   看看 bmap 对 balloc 的调用</p>
<p>问：508 块中有什么？</p>
<p>Q：为什么是iupdate？<br>   文件长度和地址[]</p>
<p>问：为什么<em>两个</em> writei+iupdate？<br>   echo 调用 write() 两次，第二次调用换行符</p>
<h3 id="问：xv6-如何删除文件？"><a href="#问：xv6-如何删除文件？" class="headerlink" title="问：xv6 如何删除文件？"></a>问：xv6 如何删除文件？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> a</span><br><span class="line">write 59 writei (from sys_unlink; directory content)</span><br><span class="line">write 34 iupdate (from sys_unlink; <span class="built_in">link</span> count of file)</span><br><span class="line">write 58 bfree  (from itrunc, from iput)</span><br><span class="line">write 34 iupdate (from itrunc; zeroed length)</span><br><span class="line">write 34 iupdate (from iput; marked free)</span><br><span class="line"></span><br><span class="line">call graph:</span><br><span class="line">  sys_unlink</span><br><span class="line">    writei</span><br><span class="line">    iupdate</span><br><span class="line">    iunlockput</span><br><span class="line">      iput</span><br><span class="line">        itrunc</span><br><span class="line">          bfree</span><br><span class="line">          iupdate</span><br><span class="line">        iupdate</span><br></pre></td></tr></table></figure>

<p>问：第 59 块中有什么？<br>   sysfile.c 中的 sys_unlink</p>
<p>问：第 34 块中有什么？</p>
<p>问：第 58 块中有什么？<br>   看输入</p>
<p>Q：为什么是三个iupdate？</p>
<p>我们来看看bio.c中的块缓存<br>   块缓存只保存几个最近使用的块<br>   bio.c 开始时的 bcache</p>
<p>FS调用bread，调用bget<br>   bget 查看块是否已经缓存<br>   如果存在而不是 B_BUSY，则返回块<br>   如果存在且 B_BUSY，则等待<br>   如果不存在，重新使用现有的缓冲区<br>   b-&gt;refcnt++ 防止 buf 在我们等待时被回收</p>
<p>这里有两级锁定<br>  bcache.lock 保护缓存中内容的描述<br>  buf-&gt;lock 只保护一个缓冲区</p>
<p>Q：什么是LRU替换策略？<br>   简单来说，就是时间轴的更新</p>
<p>1.如果使用，就放到队尾</p>
<p>2.如果替换，那么先替换队头（拿出清除后放入）</p>
<p>问：那是最好的更换政策吗？</p>
<p>Q：如果有很多进程需要读盘怎么办？谁先走？<br>   iderw 附加到 idequeue 列表<br>   ideintr 在 idequeue 列表的头部调用 idestart<br>   先进先出</p>
<p>问：FIFO (先进先出)是一个好的磁盘调度策略吗？<br>   优先调度？<br>   电梯排序？</p>
<p>问：为什么拥有 I&#x2F;O 的双重副本是有意义的？<br>   磁盘到缓冲缓存<br>   缓冲区缓存到用户空间<br>   我们可以修复它以获得更好的性能吗？</p>
<p>问：我们应该为磁盘缓冲区分配多少 RAM？</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L11 ：协调（sleep&amp;wakeup）</title>
    <url>/2024/03/08/L11%EF%BC%9A%E5%8D%8F%E8%B0%83%EF%BC%88sleep&amp;wakeup%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="笔记计划"><a href="#笔记计划" class="headerlink" title="笔记计划"></a>笔记计划</h1><p>  完成调度<br>  协调<br>        xv6：睡眠和唤醒<br>        丢失唤醒问题<br>        终止睡眠线程</p>
<span id="more"></span>

<p>  大图：<br>        进程、每个进程的内核堆栈、内核、每个内核的调度堆栈<br>        yield&#x2F;swtch&#x2F;scheduler&#x2F;swtch&#x2F;yield示意图</p>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>xv6 从内核线程到调度器使用 ptable.lock 和 swtch 是不寻常的</p>
<p>  大多数情况下，xv6 是一个普通的<strong>并行共享内存程序</strong><br>  但是这种线程切换和锁的使用是非常特定于操作系统的</p>
<p>关于 xv6 上下文切换与并发的问题</p>
<p> 1.为什么 yield() 跨 sched&#x2F;swtch 持有 ptable.lock？因为sched&#x2F;swtch必须是原子操作，否则可能出现切换一个线程堆栈，但是sched选择了另一个线程。<br>    如果另一个内核的调度程序立即看到 RUNNABLE 进程怎么办？进入switch<br>    如果在 swtch() 期间发生定时器中断怎么办？关中断<br>  2.我们怎么知道 scheduler() 线程已经准备好让我们 swtch() 进入？锁<br>  3.两个scheduler（）可以选择同一个 RUNNABLE 进程吗？ptable.lock</p>
<h1 id="为什要协调（coordination）："><a href="#为什要协调（coordination）：" class="headerlink" title="为什要协调（coordination）："></a>为什要协调（coordination）：</h1><p>  线程需要等待特定的事件或条件：<br>    等待磁盘读取完成<br>    等待管道读取器在管道中腾出空间<br>    等待任何子进程退出</p>
<p>为什么不只是有一个循环直到事件发生？想象死锁：循环等待，所以如果构建一个优先队列，就能破坏这个循环等待</p>
<p>更好的解决方案：产生 CPU 的协调原语</p>
<p>  睡眠和唤醒 (xv6)<br>  条件变量（作业）<br>  障碍（家庭作业）<br>  等等。</p>
<h1 id="协调的实现：睡眠和唤醒"><a href="#协调的实现：睡眠和唤醒" class="headerlink" title="协调的实现：睡眠和唤醒"></a>协调的实现：睡眠和唤醒</h1><p>  sleep（old，lock）<br>    睡在一个“channel”上，一个用来命名我们正在睡觉的条件的地址<br>  wakeup（old）<br>    唤醒所有沉睡在 chan 上的线程<br>    可能会唤醒多个线程：加入磁盘读取完毕，那么我们就会唤醒所有等待磁盘写的线程</p>
<h1 id="协调的例子"><a href="#协调的例子" class="headerlink" title="协调的例子"></a>协调的例子</h1><h2 id="sleep-x2F-wakeup-的使用示例-–-iderw-x2F-ideintr"><a href="#sleep-x2F-wakeup-的使用示例-–-iderw-x2F-ideintr" class="headerlink" title="sleep&#x2F;wakeup 的使用示例 – iderw() &#x2F; ideintr()"></a>sleep&#x2F;wakeup 的使用示例 – iderw() &#x2F; ideintr()</h2><p>  iderw() 排队阻塞读请求，然后 sleep()s<br>    b 是一个缓冲区，将填充块内容<br>    iderw() 休眠等待 B_VALID——磁盘读取完成<br>    chan 是 b – 这个缓冲区（在 iderw() 中可能还有其他进程）<br>  当前磁盘读取完成后，通过中断调用 ideintr()<br>    标记 b B_VALID<br>    唤醒（b）-与睡眠相同的chan</p>
<p>图像<br>  iderw() 在调用 sleep 时持有 <strong>idelock</strong><br>  但是 ideintr() 需要获取 <strong>idelock</strong>！<br>  为什么 iderw() 在调用 sleep() 之前不释放 idelock？：ideintr中断需要切换，那么假如未睡眠就先切换，就会可能导致下一个该睡眠的先睡眠，破坏队列的优先级。所以为了保证优先级，必须要睡眠判断（可能是另一个锁）和睡眠操作都在临界区内。</p>
<h1 id="协调的问题"><a href="#协调的问题" class="headerlink" title="协调的问题"></a>协调的问题</h1><ul>
<li>丢失唤醒</li>
<li>终止休眠线程</li>
</ul>
<h1 id="协调的第一个问题–丢失唤醒"><a href="#协调的第一个问题–丢失唤醒" class="headerlink" title="协调的第一个问题–丢失唤醒"></a>协调的第一个问题–丢失唤醒</h1><h2 id="丢失唤醒演示"><a href="#丢失唤醒演示" class="headerlink" title="丢失唤醒演示"></a>丢失唤醒演示</h2><p>  修改 iderw() 调用 release ：broken_sleep；acquire<br>  看看broken_sleep()<br>  看看wakeup（）<br>  发生什么了？</p>
<p>  ideintr() 在 iderw() 没有看到 B_VALID 之后运行<br>    但在 Broken_sleep() 设置 state &#x3D; SLEEPING 之前<br>    wakeup（）扫描可处理但没有线程处于休眠状态<br>  然后 sleep() 将当前线程设置为 SLEEPING 并产生睡眠错过唤醒 -&gt; 死锁</p>
<p>  这是一个“丢失的唤醒”，简单来说就是wakeup（）执行之后才将state设置为SLEEPING</p>
<h2 id="xv6-解决方案："><a href="#xv6-解决方案：" class="headerlink" title="xv6 解决方案："></a>xv6 解决方案：</h2><p>  目标：<br>    1）在条件之间的整个时间内锁定wakeup()<br>       检查并state &#x3D; 睡眠<br>    2）在休眠时释放条件锁<br>  xv6 策略：<br>    需要wakeup（）在条件和 ptable.lock 上保持锁定<br>    睡眠者始终持有一个或另一个锁<br>      持有 ptable.lock 后可以释放条件锁<br>  看 ideintr() 对wakeup() 的调用<br>    并唤醒自己<br>    在寻找chan时，两把锁都被持有<br>  看看 iderw() 对 sleep() 的调用<br>    条件锁在调用 sleep() 时被持有<br>    查看 sleep() – 获取 ptable.lock，然后在条件下释放锁<br>  图表：<br>    |—-idelock—-|<br>                  |—ptable.lock—|<br>                                     |—-idelock—-|<br>                                      |-ptable.lock-|<br>  因此：<br>    要么运行完整的 sleep() 序列，然后运行wakeup()，<br>      睡觉的人会被吵醒<br>    或唤醒（）首先运行，在潜在的睡眠者检查条件之前，<br>      但唤醒将设置条件为真<br>  要求 sleep() 接受一个锁定参数</p>
<p>人们已经开发了许多序列协调原语，</p>
<p>  所有这些都必须解决丢失唤醒问题。<br>  例如<strong>条件变量</strong>（类似于睡眠&#x2F;唤醒）<br>  例如计数<strong>信号量</strong></p>
<h2 id="另一个例子：piperead"><a href="#另一个例子：piperead" class="headerlink" title="另一个例子：piperead()"></a>另一个例子：piperead()</h2><p>  while 循环正在等待缓冲区中多于零字节的数据<br>    唤醒在 pipewrite() 结束时<br>    old线程是&amp;p-&gt;nread<br>  如果 piperead() 使用了broken_sleep()，那么竞争是什么？write和read，read和read<br>  为什么在 sleep() 周围有一个循环？每个字节读取之后睡眠等待<br>  为什么在 piperead() 的末尾有 wakeup()？因为唤醒之后读取，</p>
<h1 id="协调第二个问题–如何终止一个休眠线程？"><a href="#协调第二个问题–如何终止一个休眠线程？" class="headerlink" title="协调第二个问题–如何终止一个休眠线程？"></a>协调第二个问题–如何终止一个休眠线程？</h1><p>首先，kill(target_pid) 是如何工作的？</p>
<p>  问题：强行终止进程可能不安全<br>    它可能在内核中执行<br>      使用其内核堆栈、页表、proc[] 条目<br>    可能处于临界区，需要完成以恢复不变量<br>    所以我们不能立即终止它<br>  <strong>解决方案</strong>：目标在下一个方便的点退出<br>    kill() 设置 p-&gt;killed 标志<br>    目标线程在 trap() 和 exit()s 中检查 p-&gt;killed<br>      所以 kill() 不会干扰例如临界区<br>    <strong>exit() 关闭 FD，设置 state&#x3D;ZOMBIE，让出 CPU</strong><br>      为什么它不能释放内核堆栈和页表？<br>    父级 wait() 释放内核堆栈、页表和 proc[] 槽</p>
<h2 id="如果kill-目标是sleep-呢？"><a href="#如果kill-目标是sleep-呢？" class="headerlink" title="如果kill() 目标是sleep() 呢？"></a>如果kill() 目标是sleep() 呢？</h2><p>  例如等待控制台输入，或在 wait() 或 iderw()<br>  我们希望目标停止sleep并exit（）：想想终端命令的ctrl-C<br>  但这并不总是合理的<br>    也许目标是在复杂操作的中途睡眠（）<br>      （为了一致性）必须完成<br>    例如创建一个文件</p>
<h2 id="xv6-解决方案"><a href="#xv6-解决方案" class="headerlink" title="xv6 解决方案"></a>xv6 解决方案</h2><p>  参见 proc.c 中的 kill()<br>    将 SLEEPING 更改为 RUNNABLE – 就像 wakeup()<br>  <strong>一些睡眠循环检查 p-&gt;killed</strong><br>    例如piperead()<br>    <strong>sleep() 将由于 kill 的 state&#x3D;RUNNABLE 而返回</strong><br>    在一个循环中，所以重新检查<br>      条件为真 -&gt; 读取一些字节，然后陷阱 ret 调用 exit()<br>      条件 false -&gt; 看到 p-&gt;killed、return、trap ret 调用 exit()<br>    无论哪种方式，对 piperead() 中线程的 kill() 的近乎即时响应<br>  一些睡眠循环不检查 p-&gt;killed<br>    问：为什么不修改 iderw() 来检查睡眠循环中的 p-&gt;killed 并返回？<br>    A：如果读取，调用sFS代码期望看到磁盘缓冲区中的数据！<br>       如果写（或读），可能是 create() 的一半<br>       现在exit会使磁盘 FS 不一致。<br>  因此 iderw() 中的线程可能会在内核中继续执行一段时间<br>    trap() 将在系统调用完成后退出()</p>
<p>简单来说，对于kill会对state检查，将sleeping改为runnable，然后像正常退出子线程一样操作</p>
<h1 id="xv6-kill规范"><a href="#xv6-kill规范" class="headerlink" title="xv6 kill规范"></a>xv6 kill规范</h1><p>  如果目标在用户空间：立即放弃使用CPU，但是放弃内存在<br>    将在下次进行系统调用或接受定时器中断时死亡<br>  如果目标在内核中：并不直接放弃使用CPU<br>    目标永远不会执行另一个用户指令<br>    但可能会在内核中花费相当长的时间</p>
<h1 id="JOS-是如何应对这些问题的？"><a href="#JOS-是如何应对这些问题的？" class="headerlink" title="JOS 是如何应对这些问题的？"></a>JOS 是如何应对这些问题的？</h1><p>  失去了唤醒？<br>    JOS 是单处理器，内核中禁止中断<br>    所以唤醒不能在条件检查和睡眠之间潜行<br>  阻塞时终止？<br>    JOS 只有几个系统调用，而且它们相当简单<br>      没有像 create() 这样的阻塞多步操作<br>      因为内核中没有 FS 和磁盘驱动程序<br>    实际上只有一个阻塞调用——IPC recv()<br>      如果 env_destroy() 正在运行，则目标线程未运行<br>      recv() 使 env 处于可以安全销毁的状态</p>
<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>  睡眠&#x2F;唤醒让线程等待特定事件<br>  并发和中断意味着我们必须担心丢失的唤醒<br>  终止是线程系统中的痛苦<br>    上下文切换 vs 进程退出<br>    sleep vs kill</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>L10：进程，线程和调度</title>
    <url>/2024/03/08/L10%EF%BC%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="计划："><a href="#计划：" class="headerlink" title="计划："></a>计划：</h1><p>  为什么需要进程&#x2F;线程的调度<br>  调度实现</p>
<span id="more"></span>

<h1 id="为什么需要进程-x2F-线程的调度"><a href="#为什么需要进程-x2F-线程的调度" class="headerlink" title="为什么需要进程&#x2F;线程的调度"></a>为什么需要进程&#x2F;线程的调度</h1><p>过程<br>  一个抽象的虚拟机，好像它有自己的 CPU 和内存，<br>    不会意外地受到其他进程的影响。<br>  但是这也导致了似乎没有其他进程能进行并行的切换调度</p>
<p>进程生命周期中的API调用：<br>  fork<br>  exec<br>  exit<br>  wait<br>  kill<br>  sbrk<br>  get pid</p>
<p>挑战：进程多于处理器<br>  你的笔记本电脑有两个处理器<br>  你要运行三个程序：窗口系统、编辑器、编译器<br>  我们需要在 M 个进程之间复用 N 个处理器<br>  称为分时、调度、上下文切换</p>
<p>解决目标：<br>  对用户进程透明<br>  先发制人的用户进程<br>  先发制人的内核，方便的地方<br>  有助于保持系统响应</p>
<p>xv6 解决方案：<br>  每个进程 1 个用户线程和 1 个内核线程<br>  每个处理器 1 个调度程序线程<br>  n 个处理器</p>
<p>什么是线程？<br>  正在执行的 CPU 内核（带有寄存器和堆栈），或<br>  未执行但是存在的一组保存的寄存器和一个可以执行的堆栈</p>
<p>xv6 处理切换概述（单用户没实现多线程，而是内核的多线程）<br>  用户 -&gt; 内核线程（通过系统调用或定时器）<br>  内核线程产量，由于抢占或等待 I&#x2F;O<br>  内核线程 -&gt; 调度程序线程<br>  调度程序线程找到一个 RUNNABLE 内核线程（切换进程的细节在此）<br>  调度线程 -&gt; 内核线程<br>  内核线程 -&gt; 用户</p>
<p>每个 xv6 进程都有一个 proc-&gt;state<br>  running<br>  runnable<br>  sleep<br>  zombie<br>  unused（还记得我们的env数组吗）</p>
<p>笔记：<br>  xv6 有很多内核线程共享单个内核地址空间<br>  xv6 每个进程只有一个用户线程<br>  更严重的操作系统（例如 Linux）支持每个进程多个用户线程</p>
<p>上下文（context）切换是 xv6 中最难做到的事情之一<br>  多核<br>  锁定<br>  中断<br>  进程终止</p>
<h1 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h1><h2 id="swtch（）"><a href="#swtch（）" class="headerlink" title="swtch（）"></a>swtch（）</h2><p>  hog.c – 两个受 CPU 限制的进程<br>  我的 qemu 只有一个 CPU<br>  让我们看看 xv6 如何在它们之间切换</p>
<p>使用定时器中断被动进入调度<br>  列出 trap.c:124<br>  设置yield() 上的断点<br>  【堆栈图】<br>  print myproc()-&gt;name<br>  print myproc()-&gt;pid<br>  print&#x2F;x tf-&gt;cs<br>  print&#x2F;x tf-&gt;eip<br>  print tf-&gt;trapno (T_IRQ0+IRQ_TIMER &#x3D; 32+0)<br>  step into yield<br>  state &#x3D; RUNNABLE – 放弃 CPU 但想再次运行<br>  step intosched</p>
<p>swtch – 切换到调度后的线程<br>  上下文保存了内核线程的寄存器<br>  xv6将其保存在对栈中，通过特定位置保存的esp来寻找上下文<br>    (不要忘记了user环境保存是在trapframe和堆栈上)<br>    proc.h, struct context<br>  两个参数: from and to contexts<br>    在 *from 保存esp<br>    从 to得到esp， pop registers, return<br>  确保swtch能够切换（返回）到scheduler（）&#x2F;&#x2F;为什么？因为我们在swtch并没有恢复代码段的环境<br>    p&#x2F;x *mycpu()-&gt;scheduler<br>    p&#x2F;x &amp;scheduler<br>  stepi – and look at swtch.S<br>    [两个栈]<br>    eip (saved by call instruction)<br>    ebp, ebx, esi, edi<br>    save esp in *from<br>    load esp from to argument<br>    x&#x2F;8x $esp<br>    pops<br>    ret<br>    现在 – 我们返回到了scheduler的堆栈上</p>
<h2 id="scheduler（）"><a href="#scheduler（）" class="headerlink" title="scheduler（）"></a>scheduler（）</h2><p>  print p-&gt; 状态<br>  print p-&gt; 名称<br>  print p-&gt;pid<br>  swtch 刚从<em>前一个</em>调度程序-&gt;进程切换返回<br>  scheduler释放旧页表，cpu-&gt;proc<br>    vm.c 中的 switchkvm()<br>  接下来几次 – scheduler() 找到其他进程<br>  print p-&gt;pid<br>  vm.c 中的 switchuvm()<br>  让我们通过 swtch() stepi看看情况<br>    <strong>线程堆栈上有什么</strong>？上下文（根据esp找到）&#x2F;调用记录（保存esp）&#x2F;trapframe<br>    从定时器中断返回到用户空间<br>    其中显示trap&#x2F;yield&#x2F;sched</p>
<p>Q：调度策略是什么？<br>   调用 yield() 的线程会立即再次运行吗？不会</p>
<p>Q：为什么scheduler()循环找到进程后释放锁，并且立即重新获取？<br>   让其他处理器有机会使用 proc 表<br>   否则两核CPU，单进程&#x3D;死锁</p>
<p>问：为什么 scheduler() 会短暂启用中断？<br>   可能没有 RUNNABLE 线程<br>     它们可能都在等待 I&#x2F;O，例如磁盘或控制台<br>   启用中断，以便设备有机会发出完成信号<br>     从而唤醒一个线程</p>
<p>Q：为什么yield()获取ptable.lock，而scheduler()释放它？<br>   不寻常：锁是由与获取它的不同的线程释放的！<br>   为什么锁必须保持在 swtch() 上？<br>   如果另一个核心的 scheduler() 立即看到 RUNNABLE 进程怎么办？</p>
<p> sched() 和 scheduler() 是“<strong>协同程序</strong>”<br>   调用者知道 swtch() 正在做什么<br>   被调用者知道 switch 来自哪里<br>   例如 yield() 和 scheduler() 关于 ptable.lock 的合作<br>   不同于普通的线程切换，其中既不<br>     派对通常知道哪个线程在之前&#x2F;之后出现</p>
<p>问：我们怎么知道 scheduler() 线程已经准备好让我们 swtch() 进入？<br>   它可以是 swtch() 以外的任何地方吗？</p>
<p>这些是 ptable.lock 保护的一些不变量：<br>  如果 RUNNING，处理器寄存器保存值（不在上下文中）<br>  如果 RUNNABLE，则上下文保存其保存的寄存器<br>  如果 RUNNABLE，则没有处理器正在使用其堆栈<br>  保持从 yield() 一直到调度程序的锁强制执行：<br>    中断关闭，因此计时器不能使 swtch 保存&#x2F;恢复无效<br>    另一个 CPU 直到堆栈切换后才能执行</p>
<p>Q：内核线程有抢占式调度吗？使用关中断<br>   如果在内核中执行时定时器中断怎么办？<br>   内核线程堆栈是什么样的？</p>
<p>问：为什么在让出 CPU 时禁止持有锁？<br>   （除了 ptable.lock）<br>   即 sched() 检查 ncli &#x3D;&#x3D; 1<br>   获取可能会浪费大量时间旋转<br>   更糟糕的是：死锁，因为在中断关闭的情况下等待，记得我们的自旋锁和关中断区别！</p>
<h2 id="线程清理"><a href="#线程清理" class="headerlink" title="线程清理"></a>线程清理</h2><p>  1.看 kill（pid）<br>    目的：停止目标进程<br>  kill() 可以释放被杀进程的资源吗？内存、FD 等？<br>    太难了：它可能正在运行、持有锁等。<br>    所以一个进程必须杀死自己，而不是kill能够直接解决的！<br>    trap() 检查 p-&gt;killed<br>    并调用 exit()<br>  2.看看 exit()<br>    被杀死的进程运行 exit()<br>    线程可以释放自己的堆栈吗？<br>      否：它正在使用它，并且需要它以 swtch() 到 scheduler()。<br>    所以 <strong>exit() 设置 proc-&gt;state &#x3D; ZOMBIE</strong>; 父母完成清理<br>    ZOMBIE 子进程保证<em>不</em> 正在执行&#x2F;使用堆栈！<br>  3.wait() 进行最后的清理<br>    预计父级会调用 wait() 系统调用<br>    堆栈、分页表、proc[] </p>
<p>简单来说，kill-&gt;trap-&gt;exit-&gt;wait：当你使用kill，只是将p-&gt;killed设置，然后trap检查，将会调用exit，其中exit只是设置proc-&gt;state &#x3D; ZOMBIE，然后由swtch和scheduler，切换到父进程，父进程的wait在一开始等待到此刻，将会清理内存的堆栈，页表，进程表。</p>
<p>因此xv6中大部分内存都是wait来清理的，其余的调用只是确定flag来保证某些东西不被使用，锁释放等麻烦的状态。</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>JOS虚拟内存布局</title>
    <url>/2024/03/08/JOS%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h1 id="如何在-JOS-中使用分页（和段）"><a href="#如何在-JOS-中使用分页（和段）" class="headerlink" title="如何在 JOS 中使用分页（和段）"></a>如何在 JOS 中使用分页（和段）</h1><ul>
<li>仅使用段来将权限级别切换到&#x2F;切换出内核</li>
<li>使用分页来构建进程地址空间<span id="more"></span></li>
<li>使用分页来限制进程内存访问它自己的地址空间</li>
<li>下面是 JOS 虚拟内存映射</li>
<li>为什么同时映射内核和当前进程？为什么不是每个 4GB？这与 xv6 相比如何？</li>
<li>为什么内核在顶部？</li>
<li>为什么将所有物理内存映射到顶部？即为什么多重映射？</li>
<li>（稍后将讨论 UVPT…）</li>
<li>我们如何为不同的进程切换映射？</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="number">4</span> Gig --------&gt;  +------------------------------+</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                    :              .               :</span><br><span class="line">                    :              .               :</span><br><span class="line">                    :              .               :</span><br><span class="line">                    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">                    |   Remapped Physical Memory   | RW/--</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">   KERNBASE, ----&gt;  +------------------------------+ <span class="number">0xf0000000</span>      --+</span><br><span class="line">   KSTACKTOP        |     CPU0<span class="number">&#x27;</span>s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                   |</span><br><span class="line">                    |      Invalid <span class="title function_">Memory</span> <span class="params">(*)</span>      | --/--  KSTKGAP    |</span><br><span class="line">                    +------------------------------+                   |</span><br><span class="line">                    |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line">                    |      Invalid <span class="title function_">Memory</span> <span class="params">(*)</span>      | --/--  KSTKGAP    |</span><br><span class="line">                    +------------------------------+                   |</span><br><span class="line">                    :              .               :                   |</span><br><span class="line">                    :              .               :                   |</span><br><span class="line">   MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line">                    |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line">ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line">                    |  Cur. Page <span class="title function_">Table</span> <span class="params">(User R-)</span>   | R-/R-  PTSIZE</span><br><span class="line">   UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line">                    |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line">   UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line">                    |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line">UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line">UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line">                    +------------------------------+ 0xeebff000</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       | --/--  PGSIZE</span><br><span class="line">   USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line">                    |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line">                    +------------------------------+ 0xeebfd000</span><br><span class="line">                    |                              |</span><br><span class="line">                    |                              |</span><br><span class="line">                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                    .                              .</span><br><span class="line">                    .                              .</span><br><span class="line">                    .                              .</span><br><span class="line">                    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line">                    |     Program Data &amp; Heap      |</span><br><span class="line">   UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line">   PFTEMP -------&gt;  |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |        PTSIZE</span><br><span class="line">                    |                              |</span><br><span class="line">   UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |                   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                   |</span><br><span class="line">                    |  User STAB <span class="title function_">Data</span> <span class="params">(optional)</span>   |                 PTSIZE</span><br><span class="line">   USTABDATA ----&gt; +------------------------------+ 0x00200000 |</span><br><span class="line">                    | 空内存 <span class="params">(*)</span> | |</span><br><span class="line">   0 ------------&gt; +------------------------------+ --+</span><br></pre></td></tr></table></figure>

<h1 id="UVPT和UVPD"><a href="#UVPT和UVPD" class="headerlink" title="UVPT和UVPD"></a>UVPT和UVPD</h1><p>我们有一个很好的页表概念模型，它是一个 2^20 条目的数组，我们可以用物理页号索引。x86 2 级分页方案打破了这一点，将巨型页表分成许多页表和一个页目录。我们想以某种方式取回巨大的概念页表——JOS 中的进程将查看它以弄清楚它们的地址空间中发生了什么。但是具体怎么做呢？</p>
<p>幸运的是，分页硬件非常适合这一点——将一组碎片页面放在一个连续的地址空间中。事实证明，我们已经有一个表，其中包含指向所有碎片页表的指针：就是页目录！</p>
<p>因此，我们可以使用页<em>目录</em>作为页<em>表</em> ，在虚拟地址空间中某个连续的 2^22 字节范围内映射我们概念上的巨型 2^22 字节页表（由 1024 个页面表示）。我们可以通过将 PDE 条目标记为只读来确保用户进程不能修改他们的页表。</p>
<p>问题：我们是否也需要创建单独的 UVPD 映射？</p>
<hr>
<p>更详细的理解这个设计：</p>
<p>记住 X86 如何将虚拟地址转换为物理地址：</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2017/lec/pagetables.png" alt="img"></p>
<p>CR3 指向页目录。地址的 PDX 部分索引到页目录中，为您提供一个页表。PTX 部分索引到页表中为您提供一个页面，然后您添加低位。</p>
<p>但是处理器没有页目录、页表和页不是普通内存的概念。所以没有什么说内存中的特定页面不能同时用作其中的两个或三个。处理器只跟随指针： 页目录 &#x3D; lcr3(); 页表 &#x3D;* (pd+4*PDX); 页 &#x3D; *(pt+4 * PTX);  &#x2F;&#x2F;注：10位有1024个entry，每个entry4B，每页4KB大小</p>
<p>从图表上看，它从 CR3 开始，沿着三个箭头，然后停止。</p>
<p>如果我们将一个指针放入页面目录中，该指针指向索引 V 处的自身，如</p>
<p><img src="https://pdos.csail.mit.edu/6.828/2017/lec/vpt.png" alt="img"></p>
<p>然后当我们尝试转换一个 PDX 和 PTX 等于 V 的虚拟地址时，跟随三个箭头将我们留在页目录。这样<strong>虚拟页面</strong>就会<strong>转换为</strong>保存页面目录的<strong>物理页面</strong>。在Jos中，V是0x3BD，所以UVPD的虚拟地址是(0x3BD&lt;&lt;22)|(0x3BD&lt;&lt;12)。</p>
<p>现在，如果我们尝试使用 PDX &#x3D; V 但任意 PTX !&#x3D; V 来转换虚拟地址，那么跟随来自 CR3 的三个箭头结束比通常早一个级别（而不是最后一种情况中的两个），也就是说页表。因此，PDX&#x3D;V 的一组虚拟页面形成了一个 4MB 的区域，其页面内容，就处理器而言，就是页表本身。在 Jos 中，V 是 0x3BD，因此 UVPT 的虚拟地址是 (0x3BD&lt;&lt;22)。</p>
<p>因此，由于我们巧妙地插入了页目录中的“无操作”箭头，我们已将用作页目录和页表（通常实际上是不可见的）的页映射到虚拟地址空间中。</p>
<p>注：简单介绍一下这个机制：看页目录那个“回头”的箭头。你会发现“页目录”的中间部分才是真正的页目录，剩下的部分根据第一个页目录entry跳转到头，也是第一个页表的位置。实验中虚拟布局总共整个”页表“大小约定为4MB，你将会在实验代码中看到第一个页目录entry的设置。</p>
<p>然后我们再看偏移。JOS采用了偏移的方式进行找到页目录和页表的物理地址。</p>
<p>这里的0x3BD&lt;&lt;12就是”页目录“,也就是第一个页表的物理地址，(0x3BD&lt;&lt;12)|(0x3BD)是页目录的物理地址。</p>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>Improvisation Note:No.1</title>
    <url>/2024/03/08/Improvisation%20Note:No.1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="系列笔记"><a href="#系列笔记" class="headerlink" title="系列笔记"></a>系列笔记</h1><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>我们以CM7的 2 5 1 6为例子，即Dm7 - G7 - CM7 - A7</p>
<h1 id="STEP1-Diatonic-Tone-amp-Chord-Tone"><a href="#STEP1-Diatonic-Tone-amp-Chord-Tone" class="headerlink" title="STEP1: Diatonic Tone &amp; Chord Tone"></a>STEP1: Diatonic Tone &amp; Chord Tone</h1><p>对于CM7，我们可以使用C的自然音阶来solo，同时，着重使用各个chord tone，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dm7: D F A C</span><br><span class="line">G7:  G B D F</span><br><span class="line">CM7: C E G B</span><br><span class="line">A7:  A C# E G</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>关注chord tone连接的“就近原则”，比如从A-G</p>
<h1 id="STEP2-Add-9-or-b9"><a href="#STEP2-Add-9-or-b9" class="headerlink" title="STEP2: Add 9 or b9"></a>STEP2: Add 9 or b9</h1><p>对于chord tone我们通常添加9来稍微增加变化，同时对于A7使用b9听感较于9更好</p>
<p>可以选择9作为小节按键的第一个音</p>
<p>当然其他chord使用b9也行，但是下面提供了另外一种方法来使用b9</p>
<h1 id="STEP3-Approach-patterns"><a href="#STEP3-Approach-patterns" class="headerlink" title="STEP3: Approach patterns"></a>STEP3: Approach patterns</h1><p>对于chord tone，我们使用上行半音（例如Dm7的Db-D），节奏为目的音的1&#x2F;2或者1，来完成落键</p>
<h1 id="STEP4-Enclosures"><a href="#STEP4-Enclosures" class="headerlink" title="STEP4: Enclosures"></a>STEP4: Enclosures</h1><p>对于某个chord tone目标比如D，我们可以在C-E之间环绕来靠近D，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E-C-Db-D</span><br><span class="line">Db-E-Eb-D</span><br></pre></td></tr></table></figure>



<h1 id="STEP5-Rhythm"><a href="#STEP5-Rhythm" class="headerlink" title="STEP5: Rhythm"></a>STEP5: Rhythm</h1><ol>
<li>普通四拍，一节4或8个音符</li>
<li>两拍换为swing，即一节4个音符数量不变</li>
<li>填充第二拍为triple</li>
</ol>
<h1 id="STEP6-Mimic-Speech"><a href="#STEP6-Mimic-Speech" class="headerlink" title="STEP6: Mimic Speech"></a>STEP6: Mimic Speech</h1><p>演奏应该模仿日常对话，因此</p>
<ol>
<li>在合适的时候停顿（比如CM7只弹奏一半时间）</li>
<li>在停顿的基础上不同chord转换时八度偏移的弹奏，模仿男女对话（通常先高后低）<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202208281727838.png"></li>
<li>同时应用停顿和八度转换<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202208281729607.png"></li>
</ol>
<h1 id="STEP7-Ended-on-resolved-notes"><a href="#STEP7-Ended-on-resolved-notes" class="headerlink" title="STEP7: Ended on resolved notes"></a>STEP7: Ended on resolved notes</h1><p>结尾通常为1 3 5，对此目标我们可以应用以上所有的STEP</p>
<h1 id="STEP8-4-Licks-to-practice"><a href="#STEP8-4-Licks-to-practice" class="headerlink" title="STEP8: 4 Licks to practice"></a>STEP8: 4 Licks to practice</h1><p>实际上有个PDF，太长了就不全放</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202208281748437.png"></p>
<p>参考文献</p>
<p>[1] <a href="https://www.youtube.com/watch?v=lhNZEIFv3uk">https://www.youtube.com/watch?v=lhNZEIFv3uk</a></p>
<p>[2] <a href="https://jazztutorial.com/">https://jazztutorial.com/</a></p>
]]></content>
      <tags>
        <tag>Improvisation</tag>
      </tags>
  </entry>
  <entry>
    <title>Bossa Nova:No.1</title>
    <url>/2024/03/08/Bossa%20Nova:No.1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="系列笔记"><a href="#系列笔记" class="headerlink" title="系列笔记"></a>系列笔记</h1><span id="more"></span>

<h1 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h1><h1 id="和弦和手癖"><a href="#和弦和手癖" class="headerlink" title="和弦和手癖"></a>和弦和手癖</h1><h1 id="练习：251-x2F-1625"><a href="#练习：251-x2F-1625" class="headerlink" title="练习：251&#x2F;1625"></a>练习：251&#x2F;1625</h1><h1 id="标准曲"><a href="#标准曲" class="headerlink" title="标准曲"></a>标准曲</h1>]]></content>
      <tags>
        <tag>Bossa Nova</tag>
      </tags>
  </entry>
  <entry>
    <title>Transaction Isolation Levels</title>
    <url>/2024/02/25/Transaction%20Isolation%20Levels/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>This article will briefly introduce different transaction isolation levels and how to implement them in a roughly way.  </p>
<span id="more"></span>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><h1 id="READ-UNCOMMITED"><a href="#READ-UNCOMMITED" class="headerlink" title="READ UNCOMMITED"></a>READ UNCOMMITED</h1><h1 id="READ-COMMITED"><a href="#READ-COMMITED" class="headerlink" title="READ COMMITED"></a>READ COMMITED</h1><h1 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h1><h1 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h1><h1 id="LOCKING-OR-MVCC"><a href="#LOCKING-OR-MVCC" class="headerlink" title="LOCKING OR MVCC"></a>LOCKING OR MVCC</h1>]]></content>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/2024/01/17/Raft/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>This article will briefly introduce the Raft protocol in distributed systems. It will cover the basic ideas of Raft and the essential functions it supports to explain “consensus”.</p>
<span id="more"></span>

<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082107443.png"></p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li></li>
<li></li>
</ul>
<p>Please start by watching the animation demonstration for an intuitive understanding. (P.s. In the election section, a <strong>follower</strong> can only vote once, and some animations may be incorrect.)</p>
<h1 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h1><p>A new <strong>leader</strong> needs to be elected when there is no <strong>leader</strong> or the <strong>leader</strong> breaks down for some reason.</p>
<p>Each server is regarded as a <em><strong>follower</strong></em> initially, with a period called the <em>election timeout</em>. It will transit to be a <strong>candidate</strong> for an election. Each <strong>candidate</strong> sends all left servers messages to request a vote. Each <em><strong>follower</strong></em> votes or rejects as a response to the request. As long as any majority of the servers vote for a <strong>candidate</strong>, it becomes a <strong>leader</strong>.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082107933.png"></p>
<hr>
<!--The transition among 3 states-->



<p>You can recognize that there will be a disaster when too many <strong>candidate</strong>s exist, the “Timing and availability” subsection will mitigate this issue.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082107485.png"></p>
<hr>
<!--Terms are numbered with consecutive integers-->

<h1 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h1><p>We need multiple servers for recovery backup and there needs to be a consensus process.</p>
<p>After a server is a <strong>leader</strong>, log entries received from the clients are appended to the <strong>follower</strong>, and corresponding responses are obtained. If any majority of responses are received, commit the log and inform the <strong>follower</strong>s to also commit.</p>
<p>Raft ensures the following:</p>
<ul>
<li>The <strong>leader</strong> never overwrites or deletes its own logs, only appends to them (Leader Append-Only)</li>
<li>If two logs have the same index and term, then the logs are the same (Log Matching)</li>
<li>If two logs are the same, then all logs that come before them are also the same.</li>
</ul>
<p>The <strong>leader</strong> maintains two arrays, nextIndex and matchIndex, which respectively keep track of the log index that each <strong>follower</strong> is about to append and the log index that has already been matched.<br>Each time a new <strong>leader</strong> is elected, initialize nextIndex to the index of the <strong>leader</strong>’s log plus one, and matchIndex is initialized to zero.</p>
<p>然后发送包来append日志.对于follower,考虑两种情况</p>
<ol>
<li>缺少日志,只需要append,然后更新next和match</li>
<li>append多次后重启follower丢失部分日志,需要leader减少next,直到找到匹配的日志,然后append后更新next和match</li>
</ol>
<p>当log replication后得到的follower的回应超过半数时,commit然后发送包告知可以进行commit（更新相应字段）</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082106992.png" alt="img"></p>
<p>回过头看raft保证的几点</p>
<ol>
<li>显式指定</li>
<li>leader最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变.</li>
<li>初始空日志状态满足,每次append保持这个特性,因此每个成功而存在的index及前面日志都满足这个特性</li>
</ol>
<h1 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h1><p>状态切换和故障情况下的日志冲突的解决办法.</p>
<h2 id="Election-restriction"><a href="#Election-restriction" class="headerlink" title="Election restriction"></a>Election restriction</h2><p>保证了每个leader拥有所有被commit过的日志.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082106994.png" alt="img"></p>
<p>如图,</p>
<p>( a )中S1是领导者并且部分复制索引2处的日志条目。</p>
<p>( b ) S1崩溃；S5以S3、S4和自身的票数当选第3任期的领导人，并在对数指标2接受不同的进入。</p>
<p>( c ) S5崩溃；S1重新启动，当选领导者，继续复制。此时，term2的日志条目已经在大部分服务器上被复制，但并没有被提交。</p>
<p>如果S1像( d )一样崩溃，则S5可以当选领导者(投票来自S2、S3和S4)，并从第3项开始用自己的条目覆盖该条目。</p>
<p>然而，如果S1在崩溃前在大多数服务器上复制了当前项，如( e )所示，则该项为提交( S5无法赢得选举)。此时，日志中的所有前项也被提交。</p>
<p>这里约束的原则为term和index,raft偏好于任期更高的和日志更多的leader选举.因此一个follower给出vote并非仅仅先来后到,只有</p>
<ol>
<li>term更大</li>
<li>相同term时,index更大</li>
</ol>
<p>才会vote,否则拒绝</p>
<h2 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h2><p>同样图中(c)我们会发现即使log replication占据majority仍然会被(d)中的s5 overwrite.</p>
<p>为了防止这个情况,我们对于leader不仅仅关心旧任期的log replication.也就是说.对于c,我们不进行term2的log replication,而是对还未replication的所有log进行log replication.因此如果term4进行了commit,能够保证了term2的log也会被commit.如果没有被commit,也会因为election restriction而阻止s5在s1下线后成为leader</p>
<h2 id="Timing-and-availability"><a href="#Timing-and-availability" class="headerlink" title="Timing and availability"></a>Timing and availability</h2><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p>
<p>广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。</p>
<p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p>
<h1 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h1><p>讨论成员数量变化下的情况。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082108651.png"></p>
<h1 id="Log-compaction"><a href="#Log-compaction" class="headerlink" title="Log compaction"></a>Log compaction</h1><p>讨论日志增长的背景下，如何减少日志的占用空间。</p>
<h1 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h1><h1 id="ToDo-Lists"><a href="#ToDo-Lists" class="headerlink" title="ToDo Lists"></a>ToDo Lists</h1><ul>
<li>状态列表</li>
<li>RPC各种</li>
<li>?commited的状态谁知情：leader存储commitIndex，然后发送给follower。</li>
<li>日志复制时:append多次后重启leader丢失部分日志.这时候会出现强行覆盖follower的log,这是raft不考虑的部分</li>
<li>日志复制的参数和过程</li>
</ul>
]]></content>
      <tags>
        <tag>MIT6_8224</tag>
      </tags>
  </entry>
  <entry>
    <title>DiskANN</title>
    <url>/2024/01/04/DiskANN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>This article translates the <a href="https://zhuanlan.zhihu.com/p/655865563">blog</a> basically to improve English writing skills.</p>
<p>DiskANN series include DiskANN, FreshDiskANN, and Filtered-DiskANN, which solve several real-world scenarios, including handling billions of vectors on a single machine, real-time updates, and query filtering. We will analyze the implementation principles of these one by one. I am interested in DiskANN and Filtered-DIskANN and will briefly introduce these two papers.</p>
<span id="more"></span>

<h1 id="DiskANN"><a href="#DiskANN" class="headerlink" title="DiskANN"></a>DiskANN</h1><p>Compared to HNSW, DiskANN can provide solutions for data on disk, which is demanded by the increasingly large scale of vector data. Obviously, a singleton service is easier to implement than a distributed solution.</p>
<p>The search in Graph usually uses the greedy algorithm, which adds the unvisited nearest node’s neighbors from the candidate list(initialized with a node s) to the candidate list and repeats the process until no nodes will be processed. Finally, it returns the top-k <strong>approximately</strong> nearest nodes. Here is the pseudocode:</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102598.png"></p>
<p>But here are some issues:</p>
<ol>
<li>A lot of Neighbors should be reduced!</li>
<li>Near nodes but far from other nearby nodes will not be returned.</li>
</ol>
<p>The issues above point to the construction of the graph to apply the greedy search. “Sparse Neighborhood Graph”(SNG) proposes an ideal state that any selection will lead to the nearest node: </p>
<ul>
<li>For all node p in a visited set P that GreedySearch returned and initialize a set S $\leftarrow$ P \ {p}<ul>
<li>While S is not empty<ul>
<li>find the nearest $p^* \in S$ for p and add p* as a neighbor of p</li>
<li>Delete all node p’ which satisfies the condition $||p^* - p’|| &lt; ||p-p’||$</li>
</ul>
</li>
<li>end while</li>
</ul>
</li>
<li>end for</li>
</ul>
<p>SNG is an excellent way to satisfy the <a href="https://gulico.github.io/2019/08/12/%E8%BF%91%E4%BC%BC%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95SSG%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8B%E7%BB%8D/">convergence</a> property of “greedy search”, but is not the fastest way to convergence. Assuming all nodes are in a straight line, the greedy search algorithm will search all nodes and cost tens of ms(single ssd read latency is 100us, for hundreds of reads) and real-world demands for ms-level latency.</p>
<p>So, in the second phase, we need to speed up the “nearest neighbor” processing. DiskANN adds some long connections in the graph, which modifies the RobustPrune algorithm by a multiplier factor $\alpha(\alpha &gt; 1)$. Here is the pseudocode.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102599.png"></p>
<p>Finally, DiskANN proposes a two-phase construction of a graph for greedy search. Here is the conclusion:</p>
<ol>
<li>Initialize a graph with each node of random R neighbors.</li>
<li>Apply GreedySearch(s, p, 1, L) for each node p, then the RobustPrune(p, V, $\alpha$, R), then connect (p’, p) which $p’ \in N_{out}(p)$. if $|N_{out}(p’)| &gt; R$, fix the graph by RobustPrune(p’, $N_{out}(p’), \alpha$, R).</li>
<li>Apply phase 2 twice with $\alpha &#x3D; 1 \ and\ \alpha &gt; 1$.</li>
</ol>
<p>The algorithm is called “Vamana” and it’s just a “$\alpha$-NSG” with a random initial graph.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102600.png"></p>
<p>We can see the graphs in the second line, the algorithm with a new $\alpha$ reduce some removal of connections.</p>
<p>Here are some other methods in the DisANN search, which may sacrifice the accuracy to speed up the process.</p>
<ul>
<li>Divide the dataset into k classes by k-means and distribute each node to 2 classes. We are building Vamana for each class and merging all graphs by the out-edges into the complete graph.</li>
<li>The process requires the original vector to be quantized by pq, and the quantized value should be stored in memory. The actual value will be kept in the SSD for precise calculation and rearrangement purposes. The quantized value is essential for the greedy search process, memory usage, and calculation. as it reduces m</li>
<li>Each node in the SSD is a structure that contains padding-R-neighbors, enabling us to locate the appropriate position based on the ID.</li>
<li>Store the entry node and its 3-4 hops of neighbors in memory to reduce SSD access.</li>
<li>A beam-search strategy will be added in algorithm 1: parallel accessing multiple nodes’ neighbors to reduce SSD access.</li>
</ul>
<h1 id="FilterDiskANN"><a href="#FilterDiskANN" class="headerlink" title="FilterDiskANN"></a>FilterDiskANN</h1><p>FilterDiskANN supports the “OR” filter function in DiskANN.</p>
<p>The only difference between FilterGreedySearch and GreedySearch is that FilterGreedySearch only adds nodes with the proper filter constraints to the candidate list.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102601.png"></p>
<p>Samely, we can see that the removal of connections also considers the filter constraints: connection (a, c) can be removed only if there exists a node b, which $F_c \cap F_a \subset F_b$.</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102602.png"></p>
<h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><ul>
<li>“How can we use the k-means algorithm to balance class sizes?”</li>
<li>Initialize the graph by random r neighbors selection, which can cause extreme performance fluctuations.</li>
<li>The $\alpha$ the parameter will cause the addition of both long edges and short edges: the actual performance is not under control.</li>
</ul>
]]></content>
      <tags>
        <tag>Paper</tag>
        <tag>Vector DB</tag>
      </tags>
  </entry>
  <entry>
    <title>23年末总结-语重心不长</title>
    <url>/2023/12/27/23%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="完成的大事"><a href="#完成的大事" class="headerlink" title="完成的大事"></a>完成的大事</h1><ul>
<li>独自一人去日本关东关西环游15日</li>
<li>投了一篇论文</li>
<li>新的舍友相处融洽</li>
</ul>
<p>今年相对去年比较轻松，没有特别痛苦的事情发生，总是间歇性忙碌，持续性懒散。</p>
<p>首先是去了日本，其实本来准备自驾到云南，但是种种原因，最后决定不浪费时间直接一个人去日本，中途还临时加了住宿呆满15天。这十几天预算超标+舟车劳顿，不过对我应该还是留下的很深的印象，以至于我这几个月时不时就会引用当初的所见所闻。</p>
<p>然后是论文，只能说“法乎其上取其中，法乎其下无所得”。原意是为了满足日本因为路线问题放弃的Gifu游览，但是后来也因为和组内节奏的摩擦而堪堪投出去，并没有做的多好，甚至多亏了很多人的帮忙和投稿推期，否则更是无从谈起。</p>
<p>新的舍友相处不错，当然可能也是我运气好，碰到了人品都比较好的舍友（除了我也都很上进），看着他们因为各自的追求而对某些trash赋予自己的意义，开始思考间接目的或许才是事情发展的动力的常态，这点稍后再谈。</p>
<span id="more"></span>

<h1 id="完成的小事"><a href="#完成的小事" class="headerlink" title="完成的小事"></a>完成的小事</h1><ul>
<li>买了平板和电脑</li>
<li>买了可搅拌的便携水壶</li>
<li>滑雪</li>
</ul>
<p>写这句话的时候是圣诞节后一天，虽然我这两天也没出去玩，准备过年底的时候去滑雪或者电影院吧。（更新）29号去滑雪，第一次就上了高级道，一整天的时间基本在等待-步行-摔倒中度过，以至于晚上吃饭回寝室之后还有点神晕目眩。不过好在大致学会了双板滑雪，以滚了七八次的代价完成了冲坡的基本操作，自我感觉还是ok的。</p>
<p>话说回来，平板作为生产力用品，着实提高了一部分效率，尤其是在app的使用上，无纸化办公是以前老早就听说但是没有实际体验的，但是售价也确实比较昂贵，只能说按个人实际需求来。而电脑买来的初衷就是玩游戏，4060的拯救者R9对于我所有的游戏都能够比较舒适的运行，也不太担心配置不够的问题，带来了非常好的体验。</p>
<p>考虑到早餐&#x2F;蛋白粉的冲泡，我选择了内置塑料搅拌棒的水壶，大致原理就是在水壶底部放置电机带动水壶内部的塑料棒旋转来搅拌，由于是TypeC接口充电，所以显得非常的小巧。思路和实现看起来不难，但是非常work，唯一需要解决的问题是做工问题会导致内部的铜材料因为渗水而氧化发绿，maybe用久了会有重金属中毒的风险，我不好说。</p>
<h1 id="完不成的事"><a href="#完不成的事" class="headerlink" title="完不成的事"></a>完不成的事</h1><p>非常的多，多到如果我不写这篇总结，都没有意识到无声的放弃了这么多。</p>
<ul>
<li>15445的剩余博客</li>
<li>15721的剩余论文阅读</li>
<li>duckdb的源码阅读</li>
<li>DDIA</li>
<li>MIT-6.828的相关工作</li>
</ul>
<p>基本上以上列举的事情都没有一个好的结尾。未来填坑的欲望也在减弱。其中的博客部分甚至开始疑惑，既然很多东西重看都如新看，为什么还需要记录？或者说，到底哪些东西需要记录，哪些东西不需要？</p>
<p>（更新）30号开始准备下一年的计划，对我来说，制定一整年的计划看起来似乎非常不可靠，因此我最多制定大致一两个月要干的事情，因此接下来的时间里希望刷<a href="https://pdos.csail.mit.edu/6.824/schedule.html">6.5840</a>的lab，在简单学习go语言之后，配合copilot就开始快速上手研读和修改相关代码。在这之中有很多零碎的或者相对较连贯的思路，我认为值得记录下来，将来可以使用博客内置搜索进行输出，忘记是难免的，但是配合着ai，我认为产生一篇详尽的博客付出的心力也不如以前那么高，还是值得的。</p>
<p>说到ai，和组里这接下来的一段时间都会研究vector DB的一些混合查询和磁盘算法，调研了pgvector和看了一些论文，大致了解了思路。或许将来我的博客也能进行向量化来模拟一个自己。</p>
<h1 id="计划赶不上变化"><a href="#计划赶不上变化" class="headerlink" title="计划赶不上变化"></a>计划赶不上变化</h1><p>越往年后突然时不时有一种宿命的无力感。在和组里的磨合中， 似乎对于某些东西的热情也随着磨合慢慢的消失。以至于当我看到别人博客&#x2F;视频里介绍一些新技术&#x2F;idea的时候，对于他们展现的热情居然有了些许的隔阂。</p>
<p>另外一个产生的原因是，自己的懒惰似乎是这么些年产生的注定结果，不可否认我真的是个懒狗，但是我也不觉得自己多么特殊，也就是是说，像我这样的人，一定是大量存在的。今年对于世界是一个比烂的年份，但是我还是不太能接受一些可以预见的未来。</p>
<p>总而言之，之前的计划和开的坑的失败让我有些挫败。话接上文，假如我今年的论文只是为了科研的理想或者自我的要求，那么我一定不可能发出来，而我的目的恰恰仅仅只是为了能够到想去的地方开会玩一玩，反而却能坚持并最终投稿。</p>
<p>另外一个例子就是，舍友们都因为将来所要承担的责任而十分努力的学习，或许这些课真的如我判断那么没有意义，但是能有一个好结果也是他们乐于接受的。做一天和尚撞一天钟，做完小和尚当大方丈，或许就是意义了。</p>
<h1 id="新的一年的想法"><a href="#新的一年的想法" class="headerlink" title="新的一年的想法"></a>新的一年的想法</h1><p>因此，”构建一个好的系统，而不是贪心算法“其实也是一种trade off，没有永远适用的银弹，看起来正确的方法在不同的语境下也会有完全相反的结论。去到能接受你想法的地方，不用死磕到底，好的不一定难，简单的也不一定差，这大概是我今年发生这么多事情的一句话概括了。</p>
]]></content>
      <tags>
        <tag>Archive</tag>
      </tags>
  </entry>
  <entry>
    <title>OLAP下的优化技术</title>
    <url>/2023/08/15/OLAP%E4%B8%8B%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1694495">https://cloud.tencent.com/developer/article/1694495</a></li>
<li><a href="https://www.youtube.com/watch?v=J0nbgXIarhc&amp;ab_channel=CMUDatabaseGroup">https://www.youtube.com/watch?v=J0nbgXIarhc&amp;ab_channel=CMUDatabaseGroup</a></li>
<li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/144926830">https://zhuanlan.zhihu.com/p/144926830</a></li>
<li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/35622907">https://zhuanlan.zhihu.com/p/35622907</a></li>
<li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/54484592">https://zhuanlan.zhihu.com/p/54484592</a></li>
<li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/100933389">https://zhuanlan.zhihu.com/p/100933389</a></li>
<li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://links.jianshu.com/go?to=https://www.bilibili.com/video/BV1Bt411v7ST">https://www.bilibili.com/video/BV1Bt411v7ST</a></li>
<li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://links.jianshu.com/go?to=https://www.the-paper-trail.org/post/2013-01-30-columnar-storage/">https://www.the-paper-trail.org/post/2013-01-30-columnar-storage/</a></li>
</ul>
<h1 id="compression"><a href="#compression" class="headerlink" title="compression"></a>compression</h1><span id="more"></span>

<h1 id="vectorized-query-processing"><a href="#vectorized-query-processing" class="headerlink" title="vectorized query processing"></a>vectorized query processing</h1><h1 id="late-materialization"><a href="#late-materialization" class="headerlink" title="late materialization"></a>late materialization</h1><h1 id="Hash-join"><a href="#Hash-join" class="headerlink" title="Hash join*"></a>Hash join*</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102166.png" alt="join strategies misunderstood"></p>
<p>对于多线程下的join，我们的评估标准如下：</p>
<ul>
<li>尽量减少执行阻塞（锁等待）</li>
<li>尽量保证提高cpu缓存命中率或者数据为工作线程局部持有</li>
</ul>
<h2 id="Hash-join-vs-index-join"><a href="#Hash-join-vs-index-join" class="headerlink" title="Hash join vs. index join"></a>Hash join vs. index join</h2><p>Hash join由于build的哈希表在probe之后立即丢弃，因此只有在大join（TiDB中大于1万行才会采用），相对的index join的索引会持久化，硬币的另一端就选择 index join</p>
<h2 id="Partition-hash-join-vs-non-partition-hash-join"><a href="#Partition-hash-join-vs-non-partition-hash-join" class="headerlink" title="Partition hash join vs. non-partition hash join"></a>Partition hash join vs. non-partition hash join</h2><h2 id="Hash-Join-workload"><a href="#Hash-Join-workload" class="headerlink" title="Hash Join workload"></a>Hash Join workload</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102167.png"></p>
<p>partition主要将某些特性（比如日期，区分度）来将大数据划分为相对小数据，从而减轻计算压力，增加cpu使用率</p>
<h3 id="Partition-phase"><a href="#Partition-phase" class="headerlink" title="Partition phase"></a>Partition phase</h3><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102168.png"></p>
<p>由于hashing是基于 join key和扫描数据基于行，因此</p>
<p>NSM（行存）：每一行都得扫描才能包含join key</p>
<p>DSM（列存）：相当于扫描基于列，因此只要特定的列（如果想找同行的其余元素就加上offset）即可完成hashing</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102169.png"></p>
<p>Non-blocking parittioning遇到的问题主要在于lock-free的工程复杂</p>
<p>Blocking partitioning的问题主要是性能的相对弱势</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102170.png"></p>
<p>两种方法，根据partition的写入是否全局&#x2F;局部进行区分，但是全局共享不可避免带来读写竞争和锁的管理，这种方法的分区只起到了缓解的作用</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102171.png" alt="image-20230817175255056"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102172.png" alt="image-20230817175317278"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102173.png"></p>
<p>radix sort我们都接触过，是基数排序，简单讲就是按每位来迭代排序。</p>
<p>而radix partitioning相比于non-blocking的一次性，使用迭代来操作，其中使用prefix sum来确定每次写入的offset，同时先申请大小再实际写入，减少了后续竞争</p>
<h3 id="Build-phase"><a href="#Build-phase" class="headerlink" title="Build phase"></a>Build phase</h3><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102174.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102175.png"></p>
<p>我们知道哈希碰撞的解决办法有开放地址和拉链两种解决办法，因此哈希函数需要做碰撞率和性能的取舍：少碰撞就占空间，多碰撞换读取速度</p>
<p>不同应用场景下我们有不同的加减法，给出一些我的调研：</p>
<ul>
<li>MySQL8</li>
<li>PostgreSQL</li>
<li>Oceanbase</li>
<li>TiDB</li>
</ul>
<h3 id="Probe-phase"><a href="#Probe-phase" class="headerlink" title="Probe phase"></a>Probe phase</h3>]]></content>
      <tags>
        <tag>DB</tag>
        <tag>OLAP</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 FALL CMU15445：lab3</title>
    <url>/2023/02/18/2022%20FALL%20CMU15445%EF%BC%9Alab3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022">https://15445.courses.cs.cmu.edu/fall2022</a> 课程官网</li>
<li><a href="https://github.com/cmu-db/bustub">https://github.com/cmu-db/bustub</a> Bustub Github Repo</li>
<li><a href="https://www.gradescope.com/">https://www.gradescope.com/</a> 自动测评网站 GradeScope</li>
<li><a href="https://discord.gg/YF7dMCg">https://discord.gg/YF7dMCg</a> Discord 论坛，课程交流用</li>
<li><a href="https://www.bilibili.com/video/BV1Bg411w7kW/?spm_id_from=333.999.0.0&amp;vd_source=06def12065e2f44a1283169bd13b48bc">https://www.bilibili.com/video/BV1Bg411w7kW/?spm_id_from=333.999.0.0&amp;vd_source=06def12065e2f44a1283169bd13b48bc</a> Moody老师的中文讲解ppt </li>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/</a> B+ 树插入删除的官方printer</li>
</ul>
<span id="more"></span>

<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h1 id="Task-1-Access-Method-Executors"><a href="#Task-1-Access-Method-Executors" class="headerlink" title="Task 1 Access Method Executors"></a>Task 1 Access Method Executors</h1><h2 id="SeqScan"><a href="#SeqScan" class="headerlink" title="SeqScan"></a>SeqScan</h2><h2 id="Insert-amp-Delete"><a href="#Insert-amp-Delete" class="headerlink" title="Insert &amp; Delete"></a>Insert &amp; Delete</h2><h2 id="IndexScan"><a href="#IndexScan" class="headerlink" title="IndexScan"></a>IndexScan</h2><h1 id="Task-2-Aggregation-amp-Join-Executors"><a href="#Task-2-Aggregation-amp-Join-Executors" class="headerlink" title="Task 2 Aggregation &amp; Join Executors"></a>Task 2 Aggregation &amp; Join Executors</h1><h2 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h2><h2 id="NestedLoopJoin"><a href="#NestedLoopJoin" class="headerlink" title="NestedLoopJoin"></a>NestedLoopJoin</h2><h2 id="NestedIndexJoin"><a href="#NestedIndexJoin" class="headerlink" title="NestedIndexJoin"></a>NestedIndexJoin</h2><h1 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task 3 Sort + Limit Executors and Top-N Optimization"></a>Task 3 Sort + Limit Executors and Top-N Optimization</h1><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h2 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h2><h2 id="TopN"><a href="#TopN" class="headerlink" title="TopN"></a>TopN</h2><h2 id="Sort-Limit-As-TopN"><a href="#Sort-Limit-As-TopN" class="headerlink" title="Sort + Limit As TopN"></a>Sort + Limit As TopN</h2>]]></content>
      <tags>
        <tag>CMU-15445</tag>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 FALL CMU15445：lab2</title>
    <url>/2023/02/17/2022%20FALL%20CMU15445%EF%BC%9Alab2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022">https://15445.courses.cs.cmu.edu/fall2022</a> 课程官网</li>
<li><a href="https://github.com/cmu-db/bustub">https://github.com/cmu-db/bustub</a> Bustub Github Repo</li>
<li><a href="https://www.gradescope.com/">https://www.gradescope.com/</a> 自动测评网站 GradeScope</li>
<li><a href="https://discord.gg/YF7dMCg">https://discord.gg/YF7dMCg</a> Discord 论坛，课程交流用</li>
<li><a href="https://www.bilibili.com/video/BV1Bg411w7kW/?spm_id_from=333.999.0.0&amp;vd_source=06def12065e2f44a1283169bd13b48bc">https://www.bilibili.com/video/BV1Bg411w7kW/?spm_id_from=333.999.0.0&amp;vd_source=06def12065e2f44a1283169bd13b48bc</a> Moody老师的中文讲解ppt </li>
<li><a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/</a> B+ 树插入删除的官方printer</li>
</ul>
<span id="more"></span>

<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>这一个project主要是实现B+树作为索引，通常数据库会使用b树或者b+树作为索引，比如mysql会使用b树。索引的作用通常是用来加快查询，比如在project3中就会出现index优化的join算子task。<br>至于二者的比较，b+树纯粹是用来存储索引，因此占据的页更少；同时b+树的遍历只能通过中序遍历，而b+树叶子结点可以认为是一个单向链表，因此只需要找到左侧边界就可以顺序遍历所有kv，更加快速。</p>
<p>本次难度相对于project1陡增，具体表现在只给了接口自由发挥，实现细节则没有强制要求。所以这是一个思路相对实现简单的project。</p>
<p>B+索引的底层基于project1的Buffer Pool实现，同时采用了非聚簇索引（即叶子结点作为指针指向数据的page）。</p>
<h1 id="CheckPoint1-SingleThread-B-Tree"><a href="#CheckPoint1-SingleThread-B-Tree" class="headerlink" title="CheckPoint1 SingleThread B+Tree"></a>CheckPoint1 SingleThread B+Tree</h1><p>在B+的结构中，分为叶子结点（leaf node）和非叶子结点（internal node），并且每个结点占据空间为一个page，目的是为了加快和磁盘的存取时间。首先我们应该对继承了tree page的leaf page 和internal page来实现getter和setter，相对简单。而对于B+树的增删查，因为删除和插入需要找到叶子结点，因此首先实现查询。</p>
<p>我们先来看Task1，在Buffer Pool中我们接触过page，观察定义可以发现page size为4kb，而其中的data_部分即为我们的leaf page和internal page，因此在使用时需要通过reinterpret_cast来转型。</p>
<h1 id="Task1-B-Tree-Pages"><a href="#Task1-B-Tree-Pages" class="headerlink" title="Task1 B+Tree Pages"></a>Task1 B+Tree Pages</h1><h2 id="B-PLUS-TREE-PAGE"><a href="#B-PLUS-TREE-PAGE" class="headerlink" title="B_PLUS_TREE_PAGE"></a>B_PLUS_TREE_PAGE</h2><p>比较简单，重点是子类的实现</p>
<h2 id="B-PLUS-TREE-LEAF-PAGE"><a href="#B-PLUS-TREE-LEAF-PAGE" class="headerlink" title="B_PLUS_TREE_LEAF_PAGE"></a>B_PLUS_TREE_LEAF_PAGE</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102494.png"></p>
<p>唯一需要注意的是采取了flexible array，通常用在固定长度对象中，具体来说我们在类最后位置的成员变量放一个长度为1的数组，同时维护一个size。在实际使用时会在数组后进行填充，而size来判定合法边界，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="comment">// other member field</span></span><br><span class="line">  <span class="type">int</span> array[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="B-PLUS-TREE-INTERNAL-PAGE"><a href="#B-PLUS-TREE-INTERNAL-PAGE" class="headerlink" title="B_PLUS_TREE_INTERNAL_PAGE"></a>B_PLUS_TREE_INTERNAL_PAGE</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102495.png"></p>
<p>布局和leaf page唯二区别</p>
<ul>
<li><p>少了next page id</p>
</li>
<li><p>第一位的key是空的<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102496.png"></p>
</li>
</ul>
<h1 id="Task2-B-Tree-Data-Structure-Insertion-Deletion-Search"><a href="#Task2-B-Tree-Data-Structure-Insertion-Deletion-Search" class="headerlink" title="Task2 B+Tree Data Structure(Insertion, Deletion, Search)"></a>Task2 B+Tree Data Structure(Insertion, Deletion, Search)</h1><p>这部分的debug强烈建议使用printer和网站的printer做对比（尤其是逻辑实现有问题的时候），这里给出个人写的一个随机数生成脚本，略微减轻debug的辛苦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">  echo &quot;Usage: $0 range&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete file exist</span></span><br><span class="line">if [ -e input.txt ]</span><br><span class="line">then</span><br><span class="line">rm input.txt</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">range=$1</span><br><span class="line">touch input.txt</span><br><span class="line">echo &quot;Generating $range random numbers in the range [1, $range]...&quot;</span><br><span class="line"></span><br><span class="line">for (( i=1; i&lt;=$range;i++ ));</span><br><span class="line">do</span><br><span class="line">	number=$(( RANDOM%range + 1))	</span><br><span class="line">  echo $number &gt;&gt; input.txt</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Done. The numbers are stored in the file input.txt.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>对于查找而言，就是左小右大比较的向下查找，由于internal page 和 leaf page的定义不同，无论是采取迭代还是递归，都需要区分逻辑。个人实现如下</p>
<ul>
<li>kv的查找作为page内函数而不是b+tree的函数，减少耦合</li>
<li>使用upper bound的bsearch来优化查找</li>
</ul>
<p>拿到pageid后我们以此得到node</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> *page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(page_id);</span><br><span class="line"><span class="keyword">auto</span> *node = <span class="built_in">reinterpret_case</span>&lt;TYPE *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br></pre></td></tr></table></figure>

<p>也正是这种cast保证了flexible array的实现前提。</p>
<p>另外，从这里开始，就会开始容易出现忘记unpin。你可以仔细查看自己的每一个case并unpin，也可以估计pin的承受能力在某个时间点集中unpin（如果你的buffer pool manager实现合理的话，unpin应该是幂等的，即多次unpin是安全的）。</p>
<h3 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h3><p>我们需要调用search来找到叶子结点，然后插入。</p>
<p>流程大致分为三个case：</p>
<ul>
<li>叶子结点的插入</li>
<li>叶子结点的分裂</li>
<li>非叶子结点的分裂</li>
</ul>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202302172016301.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102497.png"></p>
<p>根据这个自顶向下查找，自底向上分裂的情况，很容易写出递归或者迭代的代码。需要额外注意的</p>
<blockquote>
<p>You should correctly perform splits if insertion triggers the splitting condition (number of key&#x2F;value pairs <strong>AFTER</strong> insertion equals to max_size for leaf nodes, number of children <strong>BEFORE</strong> insertion equals to max_size for internal nodes.).</p>
</blockquote>
<p>也就是说假设max_size为n，leaf node最多容纳n-1个而internal node最多容纳n个kv（假设空key也算在内）</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202302172021755.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102496.png"></p>
<h3 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h3><p>作为single thread最难的部分，delete的case相对复杂得多，一开始我设计了如下流程：</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102498.png"></p>
<p>注意到中间的三个判断上下重复出现，可以考虑一个范型函数</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102499.png"></p>
<p>又由于min_size和max_size的关系</p>
<ul>
<li>leaf node : max_size_ &#x2F; 2</li>
<li>internal node : (max_size_ + 1) &#x2F; 2</li>
</ul>
<p>三个判断可以整合为一个：如果size + ssize &gt;&#x3D; max_size_，那么就可以borrow kv，否则就直接merge</p>
<p>最后说三个小细节：</p>
<ol>
<li>在insertion中我们会在分裂时将key上推，而deletion中我们会在borrow&#x2F;merge时将key下推，如图我们可以发现删除6后，p4 p5进行merge，因此7下推，borrow类似就不说了<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202302172106283.png"><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102500.png"></li>
<li>一个internal node的corner case：</li>
</ol>
<p>回忆insertion的初始流程可以发现，如果根结点只剩一个孩子，那么应该直接删除根结点，将孩子作为根结点</p>
<ol start="3">
<li>merge时，两个结点应该右向左merge，因此左侧的sibling需要和结点swap</li>
</ol>
<p>总之建议配合printer手动模拟一遍，找到所有case后再动手。而官方推荐的database concept书上也列举了出来，有很大帮助。</p>
<h1 id="CheckPoint2-Multi-Thread-B-Tree"><a href="#CheckPoint2-Multi-Thread-B-Tree" class="headerlink" title="CheckPoint2 Multi Thread B+Tree"></a>CheckPoint2 Multi Thread B+Tree</h1><p>完成了自顶向下查找，自底向上插入&#x2F;删除后，需要完成锁的实现。</p>
<h2 id="Index-Iterator"><a href="#Index-Iterator" class="headerlink" title="Index Iterator"></a>Index Iterator</h2><p>这个实现相对简单，只需要实现begin 和end两个函数，而interator保存指针就好。个人理解中，end是开区间，如果是闭区间一般使用final来描述，第一次接触的话略微注意就好，记得注意unpin完遍历的page。</p>
<h2 id="Concurrent-Index"><a href="#Concurrent-Index" class="headerlink" title="Concurrent Index"></a>Concurrent Index</h2><p>前面一个实验我使用了一把大锁保平安，这部分就不行了。我们将使用一种叫做latch crabbing的方式来加锁，顾名思义就像螃蟹一样来加锁和解锁。</p>
<ul>
<li>对parent加锁</li>
<li>对child加锁</li>
<li>如果安全插入&#x2F;删除（安全意味着不split&#x2F;merge&#x2F;borrow），那么释放parent锁</li>
</ul>
<p>那么怎么样算安全，很容易我们可以得知：</p>
<ul>
<li>insert  <ul>
<li>leaf node’s size &lt; max_size_ - 1</li>
<li>internal node’s size &lt; max_size_</li>
</ul>
</li>
<li>delete <ul>
<li>node’s size &gt; minsize</li>
</ul>
</li>
</ul>
<h3 id="Search-1"><a href="#Search-1" class="headerlink" title="Search"></a>Search</h3><p>search的流程没什么好说的，由于child肯定安全，按着方式加r锁即可。</p>
<h3 id="Insertion-1"><a href="#Insertion-1" class="headerlink" title="Insertion"></a>Insertion</h3><p>对于insertion而言，我们需要在不安全时继续持有parent的锁，直到child安全时，释放所有祖先的写锁，需要用到transaction来实现：调用AddIntoPageSet()函数来记录加锁路径，释放时对set存在的锁释放。由于上层的锁竞争激烈，因此最好自顶向下释放锁。而split得到的页面不可能会被其他线程访问，所以不需要加锁只需要unpin。</p>
<p>最后不要忘记结束insert后释放剩余的所有锁。</p>
<p>同样这里也有个corner case：</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102501.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102502.png"></p>
<p>假如在一个leaf node（12）作为根结点时，由于父结点的保护</p>
<ol>
<li><p>线程1上锁，线程2等待</p>
</li>
<li><p>线程1插入3后分裂，得到1和23两个leaf node, 更新根结点</p>
</li>
<li><p>线程2得到锁，错误地插入了2</p>
<p>因此我们需要额外对root page id访问加锁，让线程2得到锁后访问的永远是最新的根结点。</p>
</li>
</ol>
<h3 id="Deletion-1"><a href="#Deletion-1" class="headerlink" title="Deletion"></a>Deletion</h3><p>deletetion基本也按照流程，但是merge会导致sibling页面的回收，因此不要忘记unlock。</p>
<p>同样corner case：</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102503.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102504.png"></p>
<p>在borrow&#x2F;merge时，假如两个线程</p>
<ol>
<li><p>t1一个安全删除3，释放父结点</p>
</li>
<li><p>t2删除2将borrow</p>
</li>
<li><p>t2将可能在t1未删除成功时对sibling修改</p>
<p>所以我们应该在borrow&#x2F;merge时先获取sibling的锁，保证t1的删除成功后进行t2的操作。</p>
</li>
</ol>
<h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>前面讲的都是需要加锁的case，有没有不需要，加了反而会死锁的情况呢？</p>
<p>有，</p>
<ol>
<li>对于自底向上split&#x2F;merge&#x2F;borrow&#x2F;修改parent page id时，如果加锁很明显会陷入死锁。</li>
<li>在使用index iterator时，如果在获得sibling时左右向中间获取时也会得到死锁，所以这时在无法得到锁时应该立即放弃锁。</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在insertion中，相同路径会以不同方向进行访问，因此向上时我们可以使用transaction里的set得到page的指针，减少bpm的重复fetch（前提是确保为重复fetch）</p>
<p>同时我们可以发现insertion&#x2F;deletion条件中“安全”两个字难以确定，没有拿到leaf node无法确定是安全。因此这里可以两种方式：</p>
<ul>
<li>默认悲观：全部加锁不释放</li>
<li>乐观优化：一开始加读锁，对leaf page加写锁，确定不安全后回退，重新加悲观锁</li>
</ul>
<p>由于根结点的瓶颈问题解决，乐观锁是一种有效优化方式，我们只需要对FindLeafPage修改即可。</p>
<h3 id="unpin和unlock先后"><a href="#unpin和unlock先后" class="headerlink" title="unpin和unlock先后"></a>unpin和unlock先后</h3><p>如果是先unpin，那么可能在安全释放父结点后被其他线程使用buffer pool manager时替换页。所以unlock后才能unpin。</p>
<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>草草实现了下，没怎么做优化，有机会再回来实现。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102506.png"></p>
]]></content>
      <tags>
        <tag>CMU-15445</tag>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>PLRG：record1</title>
    <url>/2023/01/20/PLRG%EF%BC%9Arecord1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今天分享的曲子是《The Nearness of You》</p>
<p>参考链接：</p>
<ul>
<li>Transcription <a href="https://www.youtube.com/watch?v=6g9IdpdKfXQ&amp;ab_channel=EdmundB">https://www.youtube.com/watch?v=6g9IdpdKfXQ&amp;ab_channel=EdmundB</a></li>
<li>Unknown transcription anaylysis <a href="https://www.youtube.com/watch?v=1kBA09Hugcs&amp;ab_channel=JazzPianoSchool.com-LearningFreedom(OnlineJazzPianoCourses)">https://www.youtube.com/watch?v=1kBA09Hugcs&amp;ab_channel=JazzPianoSchool.com-LearningFreedom%28OnlineJazzPianoCourses%29</a></li>
<li>Red garland course <a href="https://community.pianogroove.com/t/how-to-play-like-red-garland/4101/4">https://community.pianogroove.com/t/how-to-play-like-red-garland/4101/4</a></li>
<li>Solo analysis <a href="https://www.freejazzlessons.com/red-garlands-solo-on-what-is-this-things-called-love-learn-to-really-solo/">https://www.freejazzlessons.com/red-garlands-solo-on-what-is-this-things-called-love-learn-to-really-solo/</a></li>
<li>Play like red garland <a href="https://jazz-library.com/articles/red-garland/">https://jazz-library.com/articles/red-garland/</a></li>
<li>Solo analysis <a href="http://thejazzlanguage.com/tag/rhythm-changes/">http://thejazzlanguage.com/tag/rhythm-changes/</a></li>
<li>Red garland’s block chords style <a href="https://www.riccardoscivales.com/billy-boy-red-garlands-block-chords-style/">https://www.riccardoscivales.com/billy-boy-red-garlands-block-chords-style/</a></li>
</ul>
<span id="more"></span>

<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h1 id="Voicing"><a href="#Voicing" class="headerlink" title="Voicing"></a>Voicing</h1><h1 id="Melody"><a href="#Melody" class="headerlink" title="Melody"></a>Melody</h1><h1 id="Solo"><a href="#Solo" class="headerlink" title="Solo"></a>Solo</h1><h1 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h1>]]></content>
      <tags>
        <tag>Solo</tag>
      </tags>
  </entry>
  <entry>
    <title>PLRG：record0</title>
    <url>/2023/01/20/PLRG%EF%BC%9Arecord0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://community.pianogroove.com/uploads/default/original/2X/f/f878c63d791b8e0e4fb38d169b7e443f9ab9c62b.jpeg"></a></p>
<p>新开坑，目测相当长的一段时间里会更新一系列”play like red garland”文章（虽然大家都不屑于把Red Garland和George Shearing, Nat King Cole, Oscar Peterson, Barry Harris等人放在一起比较，但是对于初学者的我来讲很好听），当然说是analysis，更算是笔记</p>
<p>当然可以先看看<a href="https://community.pianogroove.com/uploads/short-url/eR3K8uKMdptu8nMASgRAOI32a1q.pdf">大致风格</a></p>
<span id="more"></span>

<p>每篇笔记可能包括：</p>
<ul>
<li>transcription </li>
<li>链接分享</li>
<li>red garland line推荐</li>
<li>个人分析心得</li>
</ul>
<p>截至目前已更新：</p>
<p>&#x2F;  <a href="#">Post not found: PLRG： analysis1</a>   &#x2F;   </p>
]]></content>
      <tags>
        <tag>Solo</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 FALL CMU15445：lab1</title>
    <url>/2023/01/09/2022%20FALL%20CMU15445%EF%BC%9Alab1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​	这次的lab&#x2F;project分为三个步骤：实现extendible hash table, 实现LRU k replacer，实现buffer pool manager instance。值得注意的是在第三个实现会调用前两个实现，因此如果使用autograder，最好先让前两个满分（56），然后再测评第三个。</p>
<p>​	对我而言，在实现时画类图蛮有效的（毕竟无法过目不忘），因此实验完成之后整理了大类关系图。接下来也会部分截图辅助说明思路。</p>
<span id="more"></span>

<p>​	本次试验并没有用到gdb调试，而是print直接把数据结构给画了出来（个人觉得非并发下调试直接画图对于小例子测试实现逻辑bug来讲更快）。当然并发就无法解决这个问题，因此我直接一个全局lock，希望不会超时（1: ok, 2: ok, 3:ok ）。</p>
<h1 id="Task-1-Extendible-Hash-Table"><a href="#Task-1-Extendible-Hash-Table" class="headerlink" title="Task #1 - Extendible Hash Table"></a>Task #1 - Extendible Hash Table</h1><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102775.png"></p>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p>除了insert的逻辑基本都封装在bucket里，insert逻辑相对复杂一点，具体如下：</p>
<ul>
<li>&#x2F;&#x2F;插入那个图</li>
</ul>
<p>其中遇到的问题主要是bucket分裂时逻辑弄错了</p>
<p>bucket spilit的逻辑如下：</p>
<p><img src="https://blog.eleven.wiki/imgs/15-445-1-4.png" alt="img"></p>
<p>开两个新桶，对索引hash，得到的结果分为两类，放进两个桶里（一开始以为会开多个桶，后来发现测试例子不会，就优化掉了）</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102777.png"></p>
<h1 id="Task-2-LRU-K-Replacement-Policy"><a href="#Task-2-LRU-K-Replacement-Policy" class="headerlink" title="Task #2 - LRU-K Replacement Policy"></a>Task #2 - LRU-K Replacement Policy</h1><h2 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h2><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102778.png"></p>
<h2 id="实现逻辑-1"><a href="#实现逻辑-1" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p>这里我主要使用了双向链表std::list和std::unordered_map来实现，如果不知道LRU可以先做<a href="https://leetcode.cn/problems/lru-cache/">146.LRU缓存</a></p>
<p>​	LRU-K是LRU的变种。这种算法认为设置一个K可以有效减少页面的抖动（刚换入又换出），通常K设置为2，再大虽然会增加效率，但是需要大量的数据访问作为前提，否则近似FIFO</p>
<p>​	和LRU最大的区别在于，新增维护一个history队列，在这个队列中访问次数到达k，则移入cache队列。而替换页面时history队列实行FIFO，而cache队列实行LRU</p>
<h1 id="Task-3-Buffer-Pool-Manager-Instance"><a href="#Task-3-Buffer-Pool-Manager-Instance" class="headerlink" title="Task #3 - Buffer Pool Manager Instance"></a>Task #3 - Buffer Pool Manager Instance</h1><h2 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h2><p>给出所需要的UML图</p>
<ul>
<li>BufferPoolManagerInstance</li>
<li>Page</li>
<li>DiskManager</li>
</ul>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102779.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102780.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102781.png" alt="image-20230112203430532"></p>
<h2 id="实现逻辑-2"><a href="#实现逻辑-2" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p>一开始以为replacer应该是替换page的，后来想想替换frame也可以</p>
<p>这里因为并发编程学的不是很好，先用一把大锁保平安，等下一个实验再做做</p>
<h1 id="跑分结果"><a href="#跑分结果" class="headerlink" title="跑分结果"></a>跑分结果</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102782.png"></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102783.png"></p>
<p><img src="https://blog.eleven.wiki/imgs/15-445-3-2.png" alt="img"></p>
]]></content>
      <tags>
        <tag>CMU-15445</tag>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 FALL CMU15445：hw1</title>
    <url>/2022/12/31/2022%20FALL%20CMU15445%EF%BC%9A%20hw1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>​	目的就是让你熟悉一下SQL查询的书写，大致了解查询的</p>
<ul>
<li>语法</li>
<li>嵌套</li>
<li>执行优先顺序</li>
</ul>
<span id="more"></span>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Q1</p>
<p>没什么好说的，就是样例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT(language)</span><br><span class="line">FROM akas</span><br><span class="line">ORDER BY language</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>



<p>Q2</p>
<p>||是用来append string的，然后就是基本的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT PRIMARY_TITLE, PREMIERED, RUNTIME_MINUTES ||&#x27; (mins)&#x27;</span><br><span class="line">FROM titles</span><br><span class="line">WHERE genres like &quot;%Sci-Fi%&quot; </span><br><span class="line">ORDER BY runtime_minutes DESC</span><br><span class="line">LIMIT 10; </span><br></pre></td></tr></table></figure>



<p>Q3</p>
<p>需要一个coalesce函数来设置default值，搜了一下才找到这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT NAME, (coalesce(died,2022) - born) as AGE </span><br><span class="line">FROM people</span><br><span class="line">where born &gt;= 1900</span><br><span class="line">order by age desc, name asc</span><br><span class="line">limit 20;</span><br></pre></td></tr></table></figure>



<p>Q4</p>
<p>出现了第一次嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select NAME, count(person_id) as NUM_APPEARANCES</span><br><span class="line">From (SELECT *</span><br><span class="line">FROM crew inner join people on crew.person_id = people.person_id)</span><br><span class="line">group by name</span><br><span class="line">order by num_appearances desc</span><br><span class="line">LIMIT 20;</span><br></pre></td></tr></table></figure>



<p>Q5</p>
<p>这个比较坑，因为计算后得到数字，再append string就失效了，所以找了半天终于找到了个能用的，原理是转换为4位的string，再append就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CAST(premiered / 10 * 10 AS CHAR(4)) || &#x27;s&#x27; AS decade,</span><br><span class="line">    ROUND(AVG(rating), 2) AS AVG_RATING, </span><br><span class="line">    MAX(rating) as TOP_RATING, </span><br><span class="line">    MIN(rating) as MIN_RATING, </span><br><span class="line">    count(*) as NUM_RELEASES</span><br><span class="line">FROM titles inner join ratings </span><br><span class="line">on titles.title_id = ratings.title_id</span><br><span class="line">where premiered is not null    </span><br><span class="line">group by decade</span><br><span class="line">order by AVG_RATING desc, decade asc</span><br><span class="line">LIMIT 1000;</span><br></pre></td></tr></table></figure>



<p>Q6</p>
<p>普通联表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT primary_title , votes</span><br><span class="line">FROM titles inner join ratings </span><br><span class="line">on titles.title_id = ratings.title_id</span><br><span class="line">where titles.title_id in (select title_id</span><br><span class="line">from crew inner join people </span><br><span class="line">on crew.person_id = people.person_id</span><br><span class="line">where name like &#x27;%Cruise%&#x27; and  born = 1962)</span><br><span class="line">order by votes desc</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>



<p>Q7</p>
<p>蛮简单的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT count(title_id)</span><br><span class="line">FROM titles </span><br><span class="line">where premiered = (</span><br><span class="line">select premiered</span><br><span class="line">from titles </span><br><span class="line">where primary_title == &#x27;Army of Thieves&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>Q8</p>
<p>两次嵌套，但是在纸上画一画就行，主要是抓住相同的key，逐步找到目标select就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT distinct name </span><br><span class="line">FROM crew inner join people </span><br><span class="line">on crew.person_id = people.person_id</span><br><span class="line">where category in (&#x27;actor&#x27;,&#x27;actress&#x27;) and title_id in(</span><br><span class="line">	select distinct title_id </span><br><span class="line">	from crew </span><br><span class="line">	where person_id = (</span><br><span class="line">		select person_id</span><br><span class="line">		from people</span><br><span class="line">		where name = &#x27;Nicole Kidman&#x27; and born = 1967</span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line">order by name asc;</span><br></pre></td></tr></table></figure>



<p>Q9</p>
<p>需要学习一下NTILE，意思就是按照规则等分表到bucket中，比如m行n等分：NTILE(n) over (order by avg(rating) asc)（默认是asc）。首先每bucket分配m&#x2F;n，余数mod不够m行则前mod bucket分配+1，如果够m行则继续除法分配</p>
<p>这里由于约束较多，于是直接联表，也可以使用select得到的结果进行union，注意union是上下拼接（自动distinct），join是左右拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name , ROUND(avg_rating, 2)</span><br><span class="line">FROM (</span><br><span class="line">    SELECT name, AVG(rating) as avg_rating, NTILE(10) OVER (ORDER BY AVG(rating)) as decile</span><br><span class="line">    FROM people</span><br><span class="line">    INNER JOIN crew ON people.person_id = crew.person_id</span><br><span class="line">    INNER JOIN ratings ON crew.title_id = ratings.title_id</span><br><span class="line">    INNER JOIN titles ON titles.title_id = crew.title_id</span><br><span class="line">    WHERE born = 1955 and type = &#x27;movie&#x27;</span><br><span class="line">    GROUP BY name</span><br><span class="line">) t</span><br><span class="line">WHERE decile = 9 </span><br><span class="line">ORDER BY avg_rating DESC, name ASC </span><br></pre></td></tr></table></figure>



<p>Q10</p>
<blockquote>
<p>Concatenate all the unique titles for the <strong>TV Series</strong> “House of the Dragon” as a string of comma-separated values in alphabetical order of the titles.</p>
<p><strong>Details:</strong> Find all the unique dubbed titles for the new <strong>TV show</strong> “House of the Dragon” and order them alphabetically. Print a single string containing all these titles separated by commas.<br><strong>Hint:</strong> You might find <a href="https://sqlite.org/lang_with.html">Recursive CTEs</a> useful.<br><strong>Note:</strong> Two titles are different even if they differ only in capitalization. Elements in the comma-separated value result should be separated with both a comma and a space, e.g. “foo, bar”.</p>
</blockquote>
<p>这个说简单也简单，说复杂也有一点点复杂(一般可以使用GROUP_CONCAT函数直接完成)</p>
<ul>
<li>目标：所有叫做”House of the Dragon”tv series的别名（各种语言）进行字符串拼接并输出</li>
<li>1.p表存放所有别名<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102419.png"></li>
<li>2.c表将p表中的primary_title改为序号，方便下面比较<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102420.png"></li>
<li>3.f表递归拼接union<ul>
<li>递归出口：第一个select</li>
<li>递归函数：第二个select，将上下两行拼接，比如将两行<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202212311803056.png">拼接为<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102421.png"></li>
</ul>
</li>
<li>4.降序得到最终的拼接，即为答案</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with p as (</span><br><span class="line">      select titles.primary_title as name, akas.title as dubbed</span><br><span class="line">      from titles</span><br><span class="line">      inner join akas on titles.title_id = akas.title_id</span><br><span class="line">      where titles.primary_title = &quot;House of the Dragon&quot; AND titles.type = &#x27;tvSeries&#x27;</span><br><span class="line">      group by titles.primary_title, akas.title</span><br><span class="line">      order by akas.title</span><br><span class="line">),</span><br><span class="line">c as (</span><br><span class="line">      select row_number() over (order by p.name asc) as seqnum, p.dubbed as dubbed</span><br><span class="line">      from p</span><br><span class="line">),</span><br><span class="line">flattened as (</span><br><span class="line">      select seqnum, dubbed</span><br><span class="line">      from c</span><br><span class="line">      where seqnum = 1 </span><br><span class="line">      union all </span><br><span class="line">      select c.seqnum, f.dubbed || &#x27;, &#x27; || c.dubbed</span><br><span class="line">      from c join</span><br><span class="line">            flattened f</span><br><span class="line">            on c.seqnum = f.seqnum + 1 </span><br><span class="line">)</span><br><span class="line">select dubbed from flattened</span><br><span class="line">order by seqnum desc limit 1;</span><br></pre></td></tr></table></figure>

<h1 id="跑分结果"><a href="#跑分结果" class="headerlink" title="跑分结果"></a>跑分结果</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102422.png"></p>
]]></content>
      <tags>
        <tag>CMU-15445</tag>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 SPRING CMU15721：Query Execution &amp; Processing</title>
    <url>/2022/12/31/2023%20SPRING%20CMU15721%20%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><a href="https://15721.courses.cs.cmu.edu/spring2023/">课程官网</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjYzlLMbX3cR0sxWnRM7CLFn">官方课程视频</a></li>
<li><a href="https://www.bilibili.com/video/BV1K24y1L7Ae/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click">Bilibili 课程视频</a></li>
<li>P. Boncz, et al., <a href="https://15721.courses.cs.cmu.edu/spring2023/papers/06-execution/boncz-cidr2005.pdf">MonetDB&#x2F;X100: Hyper-Pipelining Query Execution</a>, in <em>CIDR</em>, 2005</li>
<li>L. Shrinivas, et al., <a href="https://15721.courses.cs.cmu.edu/spring2023/papers/06-execution/shrinivas-icde2013.pdf">Materialization Strategies in the Vertica Analytic Database: Lessons Learned</a>, in <em>ICDE</em>, 2013 <em>(Optional)</em></li>
<li>M. Kester, et al., <a href="https://15721.courses.cs.cmu.edu/spring2023/papers/06-execution/kester-sigmod17.pdf">Access Path Selection in Main-Memory Optimized Data Systems: Should I Scan or Should I Probe?</a>, in <em>SIGMOD</em>, 2017 <em>(Optional)</em></li>
</ul>
<span id="more"></span>

<h1 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h1><p>DBMS的优化是一大堆优化的综合体，没有哪个优化比其他优化更重要。我个人总结为三个原则：</p>
<ul>
<li>没必要做的不必做</li>
<li>能多线程就多线程</li>
<li>要多利用硬件优化</li>
</ul>
<p>而其中在查询执行的优化主要用到以下的技术</p>
<ul>
<li>数据预取 &#x2F; 扫描共享</li>
<li>任务并行化 &#x2F; 多线程</li>
<li>聚簇 (Cluster) &#x2F; 排序</li>
<li>延迟物化</li>
<li>物化视图 &#x2F; 结果缓存</li>
<li>数据跳过 Data Skipping</li>
<li>数据并行化 &#x2F; 向量化</li>
<li>代码特化 (Specification) &#x2F; 编译</li>
</ul>
<p>对于这些技术，对应上面的原则，我们可以很容易理解，延迟物化&#x2F;数据向量化 这些就是减少没必要做的，代码特化也就是多用SIMD指令的就是利用硬件优化。</p>
<p>由于我个人对于OLAP更加感兴趣，所以接下来我主要关注于</p>
<ol>
<li>代码层面的硬件优化例子</li>
<li>查询向量化的处理例子以及性能提升</li>
<li>并行执行的例子</li>
</ol>
<p>这三个方面。</p>
<h1 id="Hardware-optimization-in-code-level"><a href="#Hardware-optimization-in-code-level" class="headerlink" title="Hardware optimization in code level"></a>Hardware optimization in code level</h1><h1 id="Processing-of-query-vectorization"><a href="#Processing-of-query-vectorization" class="headerlink" title="Processing of query vectorization"></a>Processing of query vectorization</h1><h1 id="Parallel-execution"><a href="#Parallel-execution" class="headerlink" title="Parallel execution"></a>Parallel execution</h1>]]></content>
      <tags>
        <tag>DB</tag>
        <tag>CMU-15721</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 FALL CMU15445：lab0</title>
    <url>/2022/12/30/2022%20FALL%20CMU15445%EF%BC%9A%20lab0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><a href="https://github.com/cmu-db/bustub">2022官网</a>，跟着配置即可，推荐使用linux，windows&#x2F;docker官网不推荐，个人不推荐mac，因为mac的新版本发布后导致gdb使用困难</p>
<span id="more"></span>

<h1 id="Task-1-Templated-Trie"><a href="#Task-1-Templated-Trie" class="headerlink" title="Task #1 - Templated Trie"></a>Task #1 - Templated Trie</h1><p>leecode上有个相近的实现，可以先做做：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208:Tire实现</a>。对比起来只有一个remove删除和prefix查找不同，其他的都大同小异</p>
<p>​	给出UML类图：<img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102431.png"></p>
<p>​	基本上对着图就能写个大概，最重要的部分就是Tire里的	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(...argvs)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Remove</span><span class="params">(...argvs)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">GetValue</span><span class="params">(...argvs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​	实际在实现过程中需要一些c++11的知识，包括但不限于</p>
<ul>
<li>smart pointer：std::unique_ptr&lt; ClassName&gt;, std::make_unique&lt; ClassName&gt;</li>
<li>move constructor and perfect forwarding：std::move(), Constructor(ClassName &amp;&amp;obj)</li>
<li>cast：dynamic_cast&lt; ClassName1 *&gt;(ClassName2 *)</li>
</ul>
<p>​	上面的内容会用到一些基本的语法，但是使用时都是串起来用的。比如unique_ptr注定了只能用std::move传递rvalue参数和onwership，只能用移动构造而不是拷贝构造。</p>
<p>​	同时，假如你使用’&#x3D;‘来触发移动构造，而如果你的move constructor标注了expilcit，那么就会失败。</p>
<p>​	最后的cast必须只能在单继承关系，多态时（至少一个virtual function）的指针转换里使用（这里给的继承关系很简单）</p>
<h1 id="Task-2-Concurrent-Trie"><a href="#Task-2-Concurrent-Trie" class="headerlink" title="Task #2 - Concurrent Trie"></a>Task #2 - Concurrent Trie</h1><p>​	header里面给了读写锁，但是在实现过程中多分支判断结束前都写个unlock显然非常麻烦。如果你写过&#x2F;了解过smart pointer的简单实现。可以模仿lock_guard写个简单版本（RAII机制）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RLockGuard</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RLockGuard</span>(ReaderWriter *latch):<span class="built_in">latch_</span>(latch)&#123;latch_-&gt;<span class="built_in">RLock</span>();&#125;</span><br><span class="line">    ~<span class="built_in">RLockGuard</span>()&#123;latch_-&gt;<span class="built_in">RUnlock</span>();&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">	ReaderWriter *latch_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WLockGuard</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WLockGuard</span>(ReaderWriter *latch):<span class="built_in">latch_</span>(latch)&#123;latch_-&gt;<span class="built_in">WLock</span>();&#125;</span><br><span class="line">    ~<span class="built_in">WLockGuard</span>()&#123;latch_-&gt;<span class="built_in">WUnlock</span>();&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">	ReaderWriter *latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	这样就可以在开头lock，在函数结束时自动调用析构函数unlock</p>
<h1 id="跑分结果"><a href="#跑分结果" class="headerlink" title="跑分结果"></a>跑分结果</h1><p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202403082102432.png"></p>
]]></content>
      <tags>
        <tag>CMU-15445</tag>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>mit-6.828_overview</title>
    <url>/2021/11/29/mit-6-828-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<p>课程安排</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2017/schedule.html">https://pdos.csail.mit.edu/6.828/2017/schedule.html</a></p>
<p>b站视频</p>
<p><a href="https://www.bilibili.com/video/BV19k4y1C7kA?from=search&amp;seid=14266879966158464981&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV19k4y1C7kA?from=search&amp;seid=14266879966158464981&amp;spm_id_from=333.337.0.0</a></p>
<p>个人安排：书–讲义–视频–材料–实验–回顾笔记–循环</p>
<span id="more"></span>

<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ol>
<li>C，汇编，工具和引导</li>
<li>内存管理</li>
<li>用户级别环境</li>
<li>进程调度</li>
<li>文件系统，IO和shell</li>
<li>网络</li>
</ol>
<h1 id="材料和讲义"><a href="#材料和讲义" class="headerlink" title="材料和讲义"></a>材料和讲义</h1><p>注：你可以随时查看期中与期末考的卷子与答案，找到你想要的题目，对于实验理论掌握会有帮助。</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2017/quiz.html">期中与期末考汇总</a></p>
<ol>
<li><p>实验1</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-overview.txt">第一节课笔记：总览</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/xv6-rev10.pdf">xv6源码</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf">xv6书</a>：这本书从头到尾都用得到，根据进度看</li>
<li><a href="https://www.youtube.com/watch?v=tc4ROCJYbm0">Unix系统视频</a></li>
<li>阅读《C程序语言设计》2.9&#x2F;5.1&#x2F;5.5&#x2F;6.4章节</li>
<li>指针作业（见lab1文件夹下）</li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-x86.pdf">ppt关于硬件和x86</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-x86.html">第二节课笔记：PC结构</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/gdb_slides.pdf">第三节课笔记：gdb使用</a></li>
</ul>
</li>
<li><p>实验2</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-shell.txt">第四节课笔记：shell和os结构</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-internal.txt">第五节课笔记：资源隔离</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-vm.md">第六节课笔记：虚拟内存</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/x86_translation_and_registers.pdf">分页和寄存器ppt</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-vm.pdf">第六节课幻灯片</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-usevm.md">第七节课笔记：使用虚拟内存</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-josmem.html">JOS虚拟内存布局</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-usingvm.pdf">第七节课ppt</a></li>
</ul>
</li>
<li><p>实验3</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-interrupt.txt">第八节课笔记：系统调用，中断，异常</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/x86_idt.pdf">第八节课笔记：IDT</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf">陷阱，中断和驱动的xv6源文件</a></li>
</ul>
</li>
<li><p>实验4</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-lockv2.txt">第九节课笔记：多进程和锁</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf">锁</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-threads.txt">第十节课笔记：进程和切换</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/xv6/book-rev10.pdf">进程调度</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-coordination.txt">第十一节课笔记：睡眠和唤醒</a></li>
</ul>
</li>
<li><p>实验5</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-fs.txt">第十二节课笔记：文件系统</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-crash.txt">第十三节课笔记：故障恢复</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-journal.txt">第十四节课笔记：文件系统性能和快速恢复</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/homework/journal-ext2fs.html">Linux ext3文件系统</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/homework/mmap.c">mmap代码</a></li>
</ul>
</li>
<li><p>实验6</p>
<ul>
<li>无资料，默认通过<a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab6/">lab6</a>独立完成</li>
</ul>
</li>
<li><p>额外内容</p>
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-vm-again.txt">第十五节课笔记：虚拟内存</a><ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/readings/appel-li.pdf">论文：虚拟内存</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-organization.txt">OS组织</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/readings/engler95exokernel.pdf">论文：针对应用程序资源管理的一个操作系统结构</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/lec/l-singularity.md">语言&#x2F;OS的协同设计</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2017/readings/hunt07singularity.pdf">论文：软件栈的重新思考</a></li>
<li>。。。暂时搁置</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Mit-6.828</tag>
      </tags>
  </entry>
  <entry>
    <title>Standards Note#1</title>
    <url>/2021/03/31/standards%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Misty"><a href="#Misty" class="headerlink" title="Misty"></a>Misty</h1><ol>
<li>初级</li>
</ol>
<ul>
<li>八度制造轻巧</li>
<li>737:向下寻找八度弥补单调感</li>
<li>157轻停顿感 137重听顿感<span id="more"></span></li>
<li>左手15右手37，左手17右手35旋律，其余延伸音就近调整</li>
<li>右手至少保证特征存在（比如3，7，9）</li>
<li>左手153增加抒情</li>
<li>dim-&gt;maj7 左手16 右手35 -&gt; 左手15 右手35（半音上行）</li>
<li>dim左手16或者17，减少思考</li>
<li>7和弦可以b9b13，比如Adim7-&gt;D7的Eb不动，下行G</li>
</ul>
<p>2.中级</p>
<p>&#x2F;&#x2F;todo</p>
<h1 id="Pure-Imagination"><a href="#Pure-Imagination" class="headerlink" title="Pure Imagination"></a>Pure Imagination</h1><ul>
<li>9 11 13是一个mtrid，halfdim 的357是一个mtrid，拆分也要思考音程关系</li>
<li>7-&gt;4纯五度</li>
<li>3-&gt;13纯四度</li>
<li>Im7-&gt;I#dim7-&gt;Ib&#x2F;II进行</li>
</ul>
<h1 id="Autumn-Leaves"><a href="#Autumn-Leaves" class="headerlink" title="Autumn Leaves"></a>Autumn Leaves</h1><ul>
<li>就近解决的方式</li>
<li>旋律同左手15 右37转同左手的顺序进行，增加节奏</li>
<li>EbM 的37同Em37</li>
<li>BbM-&gt;EbM可以增加中间的EM</li>
<li>旋律跟其他音靠太近会粘在一起变模糊</li>
</ul>
]]></content>
      <tags>
        <tag>Standard</tag>
      </tags>
  </entry>
  <entry>
    <title>学会用听力来练习和弦</title>
    <url>/2020/12/26/%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9A%E5%AD%A6%E4%BC%9A%E7%94%A8%E5%90%AC%E5%8A%9B%E6%9D%A5%E7%BB%83%E4%B9%A0%E5%92%8C%E5%BC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>学习听流行歌曲来练习（三和弦）</p>
<ul>
<li>流行歌曲大多数只是四个和弦的循环（1456）</li>
<li>旋律：首先哼出旋律，然后在琴键上找到notes<span id="more"></span></li>
<li>识别音程：对于音阶（大调小调）的理解有益于旋律识别，有益于配和弦</li>
<li>和弦：（举例Eb Ab Bb Db）scale ：Eb<ul>
<li>旋律的音阶决定了和弦，比如Eb一定出现在剩下的三个和弦中，剩下的note只能出现在各自和弦内，比如D和F只出现在Bb中&#x2F;Ab只出现在Ab中</li>
<li>Eb大调的关系小调是C小调（6级），或者其他情况（小调时但音阶同Eb&#x2F;Cm）：F minor（同Ab major功能）&#x2F; G minor（同Bb major功能）</li>
<li>c minor是Eb minor的关系小和弦，F minor是Ab major的关系小和弦，G minor是Bb major的关系小和弦</li>
<li>因此解决了和弦和调的另一个角度思考后，得C minor(1)    F minor(4)     G minor(5)</li>
<li>和弦的识别可以通过baseline，因为流行音乐大多数情况下都只弹根音</li>
<li>选择的时候只考虑5音存在的和弦，因此只剩下了 Cm，Db，Eb，Fm，Gm，Ab，Bb可以选择</li>
</ul>
</li>
<li>配和声举例（可能性很多）：Umbrella<ul>
<li>scale是C minor</li>
<li>第一节：最多是c和Eb，首先选择了Cm，听出不符合原曲情况，所以下行得到Ab</li>
<li>第二节：最多是Eb，然后F，选择Eb</li>
<li>第三节：最多是D，然后Eb，选择Bb</li>
<li>第四节：最多是C，然后D，然后Eb，选择Cm</li>
<li>规则是找出旋律音众数队列然后按照和弦队列来找和弦（比如D根音不行就作为3音，最后得到Bb和弦）</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Ear practice</tag>
      </tags>
  </entry>
  <entry>
    <title>自己搭建个人博客HEXO记录</title>
    <url>/2020/08/31/Logs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>写在前言：本文分为两个部分：从零建立hexo博客和深入了解并修改中的第一个部分</p>
<ol>
<li><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>（自行搜索或者进行基本尝试）</p>
<ul>
<li>明白hexo是什么，局限性和优越性</li>
<li>明白node.js是什么以及和npm的关系</li>
<li>明白github是什么以及和gitee的关系</li>
<li>明白terminal是什么</li>
<li>明白markdown格式书写<span id="more"></span></li>
</ul>
</li>
<li><h2 id="初步建立"><a href="#初步建立" class="headerlink" title="初步建立"></a>初步建立</h2><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><p>提前装好 Git，这里不多讲解了，可以百度安装下。</p>
<h3 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h3><p>下载 nodejs：<code>https://nodejs.org/en/</code></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9hno9wr2j30hw0a4q3p.jpg"></p>
<p>来进行安装。</p>
<p>安装完以后会有两个组件：1.是 npm 包管理器；2.是 Nodejs 。</p>
<p><strong>如果是 mac，需打开终端切换到 root 用户（目的是root时候不需要多次输入密码，这步可自选）:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>

<p>输入密码，敲回车。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202111292304874.png"></p>
<p>输入<code>clear</code>清一下。</p>
<p>查看 node 的版本：<code>node -v</code></p>
<p>查看 npm 包管理器的版本：<code>npm -v</code></p>
<p><strong>Windows 电脑我是直接以管理员身份打开 cmd，mac端打开terminal输入:</strong></p>
<p>查看 node 的版本：<code>node -v</code></p>
<p>查看 npm 包管理器的版本：<code>npm -v</code></p>
<p>因为 Hexo 需要 Nodejs 支持的、生成的，所以这是前置步骤。</p>
<h3 id="二、安装-Hexo-博客框架"><a href="#二、安装-Hexo-博客框架" class="headerlink" title="二、安装 Hexo 博客框架"></a>二、安装 Hexo 博客框架</h3><p>需借助 npm 包管理器来安装。因为国内安装镜像源很慢，所以利用 npm 安装 cnpm。</p>
<h4 id="用淘宝链接进行安装："><a href="#用淘宝链接进行安装：" class="headerlink" title="用淘宝链接进行安装："></a>用淘宝链接进行安装：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9i7vukb0j30v80cq108.jpg"></p>
<p>看下 cnpm 的版本：<code>cnpm -v</code></p>
<p>这个是mac的截图，Windows一样操作</p>
<h4 id="安装-Hexo-框架："><a href="#安装-Hexo-框架：" class="headerlink" title="安装 Hexo 框架："></a>安装 Hexo 框架：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9i8j17rhj30km0fkn1h.jpg"></p>
<p><code>hexo -v</code>来验证下。</p>
<p>可以看到 Hexo 的博客框架是基于 node 的。</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9j8arbqtj30ve0iqtf7.jpg"></p>
<h3 id="三、使用-Hexo-搭建博客（本地启动）"><a href="#三、使用-Hexo-搭建博客（本地启动）" class="headerlink" title="三、使用 Hexo 搭建博客（本地启动）"></a>三、使用 Hexo 搭建博客（本地启动）</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>在开始之前，输入 pwd 看下所处路径。</p>
<p>新建一个 blog 文件夹：<code>mkdir (blog文件夹名字)， 举例： mkdir myBlog </code></p>
<h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>在自己方便查看的位置手工创建一个 blog 文件夹。</p>
<p>所有博客的东西全部都在 blog 里面生成。<strong>所以大家如果出了什么错，直接文件夹整个删除就行了。注意：千万不能只删除 blog 文件夹里面的内容，却不删除 blog 文件夹，这样操作会出问题的。</strong></p>
<p>进入 blog 的目录中，位于这个目录下，就可以使用 Hexo 生成我们的博客。</p>
<p>（未sudo su情况下）mac 下输入 sudo，表示用管理员的命令来执行，用 mac 电脑需要加上。</p>
<p>初始化一个博客：<code>sudo hexo init</code></p>
<p>初始化一个博客：<code>hexo init</code></p>
<p>安装完成后</p>
<p>看该目录下的所有子目录和文件：<code>ls</code></p>
<p>启动博客：<code>hexo s</code></p>
<p>输入<code>localhost:4000</code>问下，看看博客是不是已经成功，已经有了，就像这样：</p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9jbw4d7hj310e0m0k1c.jpg"></p>
<h4 id="其中上图介绍来hexo博客的基本使用："><a href="#其中上图介绍来hexo博客的基本使用：" class="headerlink" title="其中上图介绍来hexo博客的基本使用："></a>其中上图介绍来hexo博客的基本使用：</h4><p><code>hexo s</code>就是<code>hexo server</code> ，写一篇博客，可以用<code>hexo s</code>这个命令启动预览，在本地修改文件可以及时渲染到页面上，非常方便。</p>
<p>切换到 source，输入命令：<code>cd source/_posts/</code></p>
<h4 id="用-vim-编辑器-x2F-自己使用合适的app建立markdown文章放在文件夹内："><a href="#用-vim-编辑器-x2F-自己使用合适的app建立markdown文章放在文件夹内：" class="headerlink" title="用 vim 编辑器&#x2F;自己使用合适的app建立markdown文章放在文件夹内："></a>用 vim 编辑器&#x2F;自己使用合适的app建立markdown文章放在文件夹内：</h4><p>可以进行编辑，也可以不编辑直接发布。</p>
<p>如果是vim：点击键盘的 i 进行编辑，shift 和 esc 同时按下(这里我记得是这样用的，如果不行可以百度下），然后输入<code>:wq</code>保存退出。</p>
<p>这样博客文章就创建好了。</p>
<p>输入 pwd，看到在 source 目录下，需要退 2 层回去：<code>cd ../..</code></p>
<p>这样就到了 blog 目录。</p>
<h4 id="接着输入以下命令："><a href="#接着输入以下命令：" class="headerlink" title="接着输入以下命令："></a>接着输入以下命令：</h4><ul>
<li><p>启动下（渲染成页面）：<code>hexo s</code></p>
</li>
<li><p>刷新下页面</p>
</li>
</ul>
<p>以上 Hexo 博客的搭建已经完成了。</p>
<h3 id="四、部署到远端（Gitee-x2F-Github）上公开使用"><a href="#四、部署到远端（Gitee-x2F-Github）上公开使用" class="headerlink" title="四、部署到远端（Gitee&#x2F;Github）上公开使用"></a>四、部署到远端（Gitee&#x2F;Github）上公开使用</h3><p>目前我们的博客还是在本地的，接下来要把它部署到远端，这样别人就可以访问你的博客了。本文记录使用<code>Github</code>和<code>Gitee</code>来托管我们的博客。</p>
</li>
</ol>
<hr>
<h4 id="1-托管方案"><a href="#1-托管方案" class="headerlink" title="1.托管方案"></a>1.托管方案</h4><p>   <code>Github</code>或者<code>Gitee</code>（码云）的<code>Pages</code>服务，它们都能够<strong>免费</strong>托管站点，没必要专门弄个服务器。其中<code>Gitee</code>访问会比较快点，毕竟是国内的。</p>
<h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><ul>
<li>创建一个仓库，<strong>仓库设置为公开</strong>的才能免费使用<code>Github Pages</code>服务。</li>
<li>仓库名必须设置为：**&lt;用户名&gt;.github.io**</li>
<li>如下图：我的<code>Github</code>用户名为khalil-chen，那么就需要创建一个名为<code>sakura-mac.github.io</code>的公开仓库。</li>
</ul>
<p>   <img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9k79dtvyj317g0u0aft.jpg"></p>
<ul>
<li><p>创建完成后，我们就可以通过<code>&lt;用户名&gt;.github.io</code>来访问我们的站点了。</p>
<h4 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h4></li>
<li><p>创建一个仓库</p>
</li>
<li><p>仓库名如果设置成和个人空间地址一样，那么访问地址就是： <code>&lt;个人空间地址名&gt;.gitee.io</code></p>
</li>
<li><p>个人空间地址可在个人资料中查看。我的个人空间地址是<code>khalil-chen</code>，那么我的博客地址就是：<code>khalil-chen.gitee.io</code></p>
</li>
</ul>
<p>   <img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gmacrnunguj31400akmy8.jpg"></p>
<h4 id="2-开始部署"><a href="#2-开始部署" class="headerlink" title="2.开始部署"></a>2.开始部署</h4><p>   以gitee为例子</p>
<p>   接下来，我们就可以把本地博客部署远端了。</p>
<ul>
<li><h4 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装部署插件</h4></li>
</ul>
<p>   在博客根目录中执行以下命令来下载自动部署工具：</p>
   <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="修改部署配置"><a href="#修改部署配置" class="headerlink" title="修改部署配置"></a>修改部署配置</h4><ul>
<li><p><code>ssh</code>配置</p>
<ul>
<li>git用户信息配置（创建仓库完成后）</li>
</ul>
<p>在Git Bash（终端）命令行输入：<br>git config –global user.name “你的用户名”+回车<br>git config –global user.email “你的邮箱”+回车</p>
<ul>
<li>生成&#x2F;添加SSH公钥</li>
</ul>
<p>码云提供了基于SSH协议的Git服务，在使用SSH协议访问仓库之前，需要先配置好账户&#x2F;仓库的SSH公钥。<br>1、本机生成SSH公钥<br>1）本地打开 Git Bash（终端），输入命令：ssh-keygen<br>2）在暂停时按回车键，三次回车后，即可生成了SSH公钥<br>3）命令：cat &#x2F;.ssh&#x2F;id_rsa.pub（“cat”与“”之间有空格）查看SSH公钥<br>2、Gitee （码云）添加SSH公钥：<br>在gitee上找到个人设置-&gt;安全设置-&gt;SSH公钥，然后将刚才生成的公钥输入公钥框，点击确定即可。<br>3、确认是否配置成功<br>在命令行输入：ssh -T <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>+回车<br>在询问yes&#x2F;no是，输入yes。这是因为首次使用需要确认并添加主机到本机SSH可信列表。<br>若返回 “Hi XXX! You’ve successfully authenticated, but Gitee.com does not provide shell access.”内容，则证明添加成功。</p>
</li>
<li><p>在文件夹_config.yml站点配置文件中修改如下配置：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@gitee.com:&lt;仓库名&gt;/&lt;路径&gt;.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：部署分支要和我们远端仓库的部署分支对应，没设置的话<code>Hexo</code>会自动创建一个分支作为部署分支。</p>
</blockquote>
</li>
</ul>
<h4 id="3-执行部署命令"><a href="#3-执行部署命令" class="headerlink" title="3.执行部署命令"></a>3.执行部署命令</h4><ul>
<li>在博客根目录中执行以下命令：</li>
</ul>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br><span class="line">//hexo clean 意味着清理一下</span><br><span class="line">//hexo g 意味着生成相应的html代码保存</span><br><span class="line">//hexo d 意味着远程推送到托管仓库里（如果远程推送一定要hexo g，否则页面代码未改变即推送了个寂寞，无法再渲染更新页面）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于<code>Gitee Pages</code>，由于不支持自动更新，每次执行命令部署后需要手动点击更新，等待更新完成后访问地址即可看到效果。</li>
</ul>
<p>   <img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gmaetl8yh5j30w40im40i.jpg"></p>
<blockquote>
<p>如果看不到效果的话，暂停服务，然后再重新启动。</p>
</blockquote>
<ul>
<li>对于<code>GitHub Pages</code>，它支持自动更新，无需额外操作，稍等片刻后访问即可。</li>
</ul>
<p>   访问页面的网站地址可看到主题成功换了！</p>
<p>   <img src="https://bed1.oss-cn-beijing.aliyuncs.com/0081Kckwly1gm9jwor29jj31ta0u0b2c.jpg"></p>
<p>   以上整个过程已经完成了。</p>
<ol start="3">
<li><h2 id="美化改进"><a href="#美化改进" class="headerlink" title="美化改进"></a>美化改进</h2><ul>
<li>添加后台评论系统</li>
<li>添加live2D（电子宠物）</li>
<li>添加网易云播放器</li>
<li>添加点击烟花特效</li>
<li>添加个人网盘</li>
<li>添加友链</li>
<li>添加个人影院（解析口）</li>
<li>添加公共聊天室</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Logs</tag>
      </tags>
  </entry>
</search>
