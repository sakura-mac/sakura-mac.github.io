<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    实验 2：内存管理 |  
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/images/ayer.png" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="海猫栖息地" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-lab2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  实验 2：内存管理
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2024/03/08/lab2/" class="article-date">
  <time datetime="2024-03-08T13:16:50.325Z" itemprop="datePublished">2024-03-08</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">14.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">64 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>lab通关记录</p>
<a href="/2024/03/08/MIT-6.828%E5%AE%9E%E9%AA%8C%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/" title="MIT-6.828实验通关记录">MIT-6.828实验通关记录</a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在本实验中，将为操作系统编写内存管理代码。内存管理有两个组成部分。</p>
<p>第一部分是内核的物理内存分配器，以便内核可以分配内存并稍后释放它。分配器将以 4096 字节为一页运行。我们将维护数据结构，记录哪些物理页面是空闲的，哪些已分配，以及有多少进程正在共享每个分配的页面。并且还将编写分配和释放内存页的代码。</p>
<p>第二部分是<em>虚拟内存</em>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86 硬件的内存管理单元 (MMU) 在指令使用内存时执行映射，查询一组页表。我们将编写页表填写的代码。</p>
<span id="more"></span>

<h3 id="进入新的实验代码"><a href="#进入新的实验代码" class="headerlink" title="进入新的实验代码"></a>进入新的实验代码</h3><p>实验采取了git来管理代码，因此我们对于远程的labx进行切换，合并lab（x-1）的代码，这样就能在原有代码基础上引入新实验必要的代码框架，进行进一步的修改和提交，以此类推一直到最后的lab6.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout lab2</span><br><span class="line"><span class="variable">$git</span> merge lab1</span><br></pre></td></tr></table></figure>

<p>实验 2 包含以下新源文件，您应该浏览这些文件：（看关键文件代码注释）</p>
<ul>
<li><code>inc/memlayout.h</code></li>
<li><code>kern/pmap.c</code></li>
<li><code>kern/pmap.h</code></li>
<li><code>kern/kclock.h</code></li>
<li><code>kern/kclock.c</code></li>
</ul>
<p><code>memlayout.h</code>描述了必须通过修改<code>pmap.c</code>来实现的虚拟地址空间的布局。 <code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code> 用于跟踪哪些物理内存页面空闲的结构。 <code>kclock.c</code>和<code>kclock.h</code> 操作 PC 的电池供电时钟和 CMOS RAM 硬件，其中 BIOS 记录 PC 包含的物理内存量等。<code>pmap.c 中</code>的代码需要读取这个设备硬件，以便计算出有多少物理内存，但这部分代码是为你完成的：你不需要知道 CMOS 硬件如何工作的细节。</p>
<p>请特别注意<code>memlayout.h</code>和<code>pmap.h</code>，因为本实验要求您使用并理解它们包含的许多定义。您可能还想查看<code>inc/mmu.h</code>，因为它还包含许多对本实验有用的定义。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%./grade-lab2</span><br></pre></td></tr></table></figure>

<p>会给你一个评分和错误显示。</p>
<p><strong>首先</strong>你必须明白一个道理：当你写代码的时候，代码里的给定<strong>地址操作</strong>中地址都会被mmu进行转换。因此即便是内核代码：假如你编写页表时候，你根据基址和偏移取页表项这个动作，也应该给出虚拟基址而不是物理地址，否则你直接变量名。为什么用变量名可以呢？前面的lab中已经知道了ELF规定里内核的代码也按照虚拟内存布局来存放。因此当你创建一个数组a的时候，数组自然存放在物理内存中，但是如果你把a当作地址，那么很不幸你只能得到虚拟地址，除非你做更多的转换动作。</p>
<p>那么内核的地址到底怎么在页表创立之前进行高低转换呢？前面的lab给出了答案：位移</p>
<p>如果没有明白以上的内容，你将完全看不懂本实验。</p>
<h2 id="第-1-部分：物理页面管理"><a href="#第-1-部分：物理页面管理" class="headerlink" title="第 1 部分：物理页面管理"></a>第 1 部分：物理页面管理</h2><p>操作系统必须跟踪物理 RAM 的哪些部分是空闲的，哪些是当前正在使用的。JOS 以<em>页面粒度</em>管理 PC 的物理内存， 以便它可以使用 MMU 来映射和保护每块分配的内存。</p>
<p>您现在将编写物理页面分配器。它通过一个<code>struct PageInfo</code>对象链接列表来跟踪哪些页面是空闲的（与 xv6 不同的是，它们<em>没有</em>嵌入到空闲页面本身中），每个页面对应一个物理页面。您需要先编写物理页分配器，然后才能编写其余的虚拟内存实现，因为页表管理代码需要分配物理内存来存储页表。</p>
<h3 id="Exercise1"><a href="#Exercise1" class="headerlink" title="Exercise1"></a><strong>Exercise1</strong></h3><p>在文件<code>kern/pmap.c 中</code>，您必须为以下函数实现代码（可以按照给定的顺序）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init()（仅限于调用`check_page_free_list(<span class="number">1</span>)`）</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>

<p><code>check_page_free_list()</code>并 <code>check_page_alloc()</code>测试您的物理页面分配器。您应该启动 JOS 并查看是否<code>check_page_alloc()</code> 报告成功。修复您的代码，使其通过。您可能会发现添加您自己的<code>assert()</code> 以验证您的假设是否正确很有帮助。</p>
<h2 id="第-2-部分：虚拟内存"><a href="#第-2-部分：虚拟内存" class="headerlink" title="第 2 部分：虚拟内存"></a>第 2 部分：虚拟内存</h2><p>在做任何其他事情之前，先熟悉 x86 的保护模式内存管理架构：即<em>分段</em>和<em>页面转换</em>。</p>
<h3 id="Exercise2"><a href="#Exercise2" class="headerlink" title="Exercise2"></a><strong>Exercise2</strong></h3><p>查看<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm"> Intel 80386 参考手册的</a>第 5 章和第 6 章 ，如果您还没有这样做的话。仔细阅读有关页面转换和基于页面的保护的部分（5.2 和 6.4）。我们建议您还浏览有关细分的部分；虽然 JOS 使用分页硬件进行虚拟内存和保护，但不能在 x86 上禁用段转换和基于段的保护，因此您需要对其有基本的了解。</p>
<h3 id="虚拟、线性和物理地址"><a href="#虚拟、线性和物理地址" class="headerlink" title="虚拟、线性和物理地址"></a>虚拟、线性和物理地址</h3><p>jos和linux一样，放弃了段的管理，只是用来描述符和选择子的权限检查。因此内存管理主要是针对分页管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们通常把指针是当作虚拟地址的“偏移量”。在<code>boot/boot.S 中</code>，我们安装了一个全局描述符表 (GDT)，它通过将所有段基地址设置为 0 并将限制设置为 来有效地禁用段转换<code>0xffffffff</code>。因此“选择子”不起作用，线性地址总是等于虚拟地址的偏移量。在实验 3 中，我们将不得不与分段进行更多交互以设置权限级别，但是对于地址映射，我们可以在整个 JOS 实验中忽略分段，而只关注页表映射。</p>
<p>回想一下，在实验 1 的第 3 部分中，我们安装了一个简单的页表，以便内核可以在其链接地址 0xf0100000 处运行，即使它实际上加载到 ROM BIOS 上方 0x00100000 处的物理内存中。这个页表只映射了 4MB 的内存。在本实验中您要为 JOS 设置的虚拟地址空间布局中，我们将扩展它以映射从虚拟地址 0xf0000000 开始的前 256MB 物理内存，并映射虚拟地址空间的许多其他区域。</p>
<h3 id="Exercise3"><a href="#Exercise3" class="headerlink" title="Exercise3"></a><strong>Exercise3</strong></h3><p>虽然 GDB 只能通过虚拟地址访问 QEMU 的内存，但在设置虚拟内存时能够检查物理内存通常很有用。查看实验室工具指南中的 QEMU<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/labguide.html#qemu">监视器命令</a>。</p>
<p>从在 CPU 上执行的代码来看，一旦我们处于保护模式（我们首先在<code>boot/boot.S 中输入</code>），就无法直接使用线性或物理地址。 <em>所有</em>内存引用都被解释为虚拟地址并由 MMU 翻译，这意味着 C 中的<strong>所有指针都是虚拟地址</strong>。</p>
<p>JOS 内核通常需要将地址作为不透明值或整数进行操作，而不是取消引用它们，例如在物理内存分配器中。有时这些是虚拟地址，有时它们是物理地址。为了帮助记录代码，JOS 源区分了两种情况：类型<code>uintptr_t</code>表示虚拟地址，和<code>physaddr_t</code>表示物理地址。这两种类型实际上只是 32 位整数 ( <code>uint32_t</code>) 的同义词。所以你应该自己做好识别。</p>
<p>JOS 内核可以<code>uintptr_t</code>通过首先将其转换为指针类型来取消引用 a 。相比之下，内核无法合理地取消引用物理地址，因为 MMU 会转换所有内存引用。如果您将 a<code>physaddr_t</code>转换为指针并取消引用它，您可能能够加载并存储到结果地址（硬件会将其解释为虚拟地址），但您可能无法获得您想要的内存位置。</p>
<p>总结一下：</p>
<table>
<thead>
<tr>
<th>类型声明</th>
<th>地址类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>T*</code></td>
<td>虚拟</td>
</tr>
<tr>
<td><code>uintptr_t</code></td>
<td>虚拟</td>
</tr>
<tr>
<td><code>physaddr_t</code></td>
<td>物理</td>
</tr>
</tbody></table>
<p><strong>问题</strong></p>
<ol>
<li><p>假设下面的 JOS 内核代码是正确的，变量x应该是什么类型： unitptr_t,还是physaddr_？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value= 10；</span><br><span class="line">x = (mysetyry_t)value；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>JOS 内核有时需要读取或修改，它只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核无法绕过虚拟地址转换，因此无法直接加载和存储到物理地址。JOS 重新映射从物理地址 0 开始到虚拟地址 0xf0000000 的所有物理内存的原因之一是帮助内核读取和写入它只知道物理地址的内存。为了将一个物理地址转换成内核可以实际读写的虚拟地址，内核必须在物理地址上加上0xf0000000（也就是位移），才能在重映射的区域中找到其对应的虚拟地址。你应该使用<code>KADDR(pa)</code> 做那个加法。</p>
<p>给定存储内核数据结构的内存的虚拟地址，JOS 内核有时也需要能够找到物理地址。内核全局变量和分配的内存 <code>boot_alloc()</code>位于加载内核的区域，从 0xf0000000 开始，也就是我们映射所有物理内存的区域。因此，要将这个区域中的虚拟地址转换为物理地址，内核可以简单地减去 0xf0000000。你应该<code>PADDR(va)</code> 用来做那个减法。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在未来的实验中，您通常会将相同的物理页面同时映射到多个虚拟地址（或多个环境的地址空间中）。您将在物理页面对应的<code>pp_ref</code>字段中记录对每个物理页面的引用次数<code>struct PageInfo</code>。当一个物理页面的这个计数变为零时，该页面可以被释放，因为它不再被使用。一般来说，这个计数应该等于物理页在所有页表中出现*在下面 <code>UTOP</code>*的次数（上面的映射 <code>UTOP</code>大部分在启动时由内核设置，永远不应该被释放，所以没有必要对它们进行引用计数）。我们还将使用它来跟踪我们保留的指向页表的指针的数量，进而跟踪页目录对页表页的引用数量。</p>
<p>使用<code>page_alloc</code>时要小心。它返回的页面将<strong>始终具有 0 的引用计数</strong>，因此，只要您对返回的页面进行了某些操作（例如将其插入到页表中），就应该增加<code>pp_ref</code>。有时这由其他函数处理（例如，<code>page_insert</code>），有时调用<code>page_alloc</code>的函数必须直接执行此操作。</p>
<h3 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h3><p>现在您将编写一组例程来管理页表：插入和删除线性到物理映射，以及在需要时创建页表页。</p>
<h3 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a><strong>Exercise4</strong></h3><p>在文件<code>kern/pmap.c 中</code>，您必须实现以下函数的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br></pre></td></tr></table></figure>

<p><code>check_page()</code>调用  <code>mem_init()</code>，测试您的页表管理。在继续之前，您应该确保它报告成功。</p>
<h2 id="第-3-部分：内核地址空间"><a href="#第-3-部分：内核地址空间" class="headerlink" title="第 3 部分：内核地址空间"></a>第 3 部分：内核地址空间</h2><p>JOS 将处理器的 32 位线性地址空间分为两部分。我们将在实验 3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。分割线由符号定义ULIM在 <code>inc/memlayout.h</code>，保留约256MB的虚拟地址空间是内核。这就解释了为什么我们需要在lab 1 中给内核一个如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境。</p>
<p>您会发现参考<code>inc/memlayout.h 中</code>的 JOS 内存布局图 对本部分和后续实验<code>很有帮助</code>。</p>
<h3 id="权限和故障隔离"><a href="#权限和故障隔离" class="headerlink" title="权限和故障隔离"></a>权限和故障隔离</h3><p>由于内核和用户内存都存在于每个环境的地址空间中，我们将不得不在 x86 页表中使用权限位来允许用户代码仅访问地址空间的用户部分。否则用户代码中的错误可能会覆盖内核数据，导致崩溃或更微妙的故障；用户代码也可能窃取其他环境的私人数据。请注意，可写权限位 ( <code>PTE_W</code> ) 会影响用户和内核代码！</p>
<p>用户环境对上面的任何内存都没有权限<code>ULIM</code>，而内核将能够读写这块内存。对于地址范围 <code>[UTOP,ULIM)</code>，内核和用户环境都拥有相同的权限：可以读但不能写这个地址范围。该地址范围用于向用户环境公开某些只读的内核数据结构。最后，下面的地址空间 <code>UTOP</code>是供用户环境使用的；用户环境将设置访问此内存的权限。</p>
<h3 id="初始化内核地址空间"><a href="#初始化内核地址空间" class="headerlink" title="初始化内核地址空间"></a>初始化内核地址空间</h3><p>现在您将设置上面的地址空间<code>UTOP</code>：地址空间的内核部分。 <code>inc/memlayout.h</code>显示您应该使用的布局。您将使用刚刚编写的函数来设置适当的线性到物理映射。</p>
<h3 id="Exercise5"><a href="#Exercise5" class="headerlink" title="Exercise5"></a><strong>Exercise5</strong></h3><p>在<code>mem_init()</code>调用 之后填写缺少的代码<code>check_page()</code>。</p>
<p>您的代码现在应该通过<code>check_kern_pgdir()</code> 和<code>check_page_installed_pgdir()</code>检查。</p>
<p><strong>问题</strong></p>
<ol>
<li><p>页面目录中的哪些条目（行）此时已被填充？它们映射哪些地址以及指向何处？换句话说，尽可能多地填写这张表：</p>
<table>
<thead>
<tr>
<th>入口</th>
<th>基本虚拟地址</th>
<th>指向（逻辑上）：</th>
</tr>
</thead>
<tbody><tr>
<td>1023</td>
<td>?</td>
<td>前 4MB 物理内存的页表</td>
</tr>
<tr>
<td>1022</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>.</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>2</td>
<td>0x00800000</td>
<td>?</td>
</tr>
<tr>
<td>1</td>
<td>0x00400000</td>
<td>?</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td>[见下一个问题]</td>
</tr>
</tbody></table>
</li>
<li><p>我们已经将内核和用户环境放在相同的地址空间中。为什么用户程序不能读写内核内存？什么具体机制保护内核内存？</p>
</li>
<li><p>此操作系统可以支持的最大物理内存量是多少？为什么？</p>
</li>
<li><p>如果我们实际上拥有最大数量的物理内存，那么管理内存有多少空间开销？这个开销是如何分解的？</p>
</li>
<li><p>重新访问<code>kern/entry.S</code>和 <code>kern/entrypgdir.c 中</code>的页表设置。在我们打开分页后，EIP 仍然是一个很小的数字（略高于 1MB）。我们在什么时候过渡到在 KERNBASE 之上的 EIP 上运行？是什么让我们可以在启用分页和开始在高于 KERNBASE 的 EIP 上运行之间继续以低 EIP 执行？为什么需要这种转变？</p>
</li>
</ol>
<h1 id="回答问题汇总"><a href="#回答问题汇总" class="headerlink" title="回答问题汇总"></a>回答问题汇总</h1><h3 id="Exercise1-1"><a href="#Exercise1-1" class="headerlink" title="Exercise1"></a>Exercise1</h3><p>boot_alloc:分配虚拟地址，实际分配为page_alloc，（因为只是增加指针而已，页表项，PageInfo等都没有设置）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// 下一个空页虚拟地址，static非常重要，接下来有用</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化nextfree ：第一次被boot_alloc时候</span></span><br><span class="line">	<span class="comment">// &#x27;end&#x27; 指向.bss节最高处:</span></span><br><span class="line">	<span class="comment">// 从此代码和数据分配完成，接下来自由分配</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//你应该1.分配足够大的内存，2.并更新nextfree，确保了nextfree（地址）以PGSIZE倍数对齐，如果不明白对齐含义，你应该看《深入理解操作系统》中虚拟内存里堆malloc地址对齐的讲解</span></span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP(result + n, PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;<span class="comment">//分配页的va</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mem_init：创建二级页表，填充页表项，建立映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line">	<span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到这个机器以页为单位到底有多大 (npages &amp; npages_basemem).</span></span><br><span class="line">	i386_detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当你准备好测试的时候，把这一行注释：因为是报错用</span></span><br><span class="line">	<span class="comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 创建初始页目录表</span></span><br><span class="line">	kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 插入 PD 作为页表映射：</span></span><br><span class="line">	<span class="comment">// 目前而言，下面这行，不用太多的理解，即：</span></span><br><span class="line">	<span class="comment">// 权限: 内核 R, 用户 R</span></span><br><span class="line">	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 你应该分配一个PageInfo的数组，你应该知道这个结构体定义，什么用：所有能分配和访问的物理页</span></span><br><span class="line">	<span class="comment">// 内核通过这个数组追踪页， &#x27;npages&#x27; 代表了数组的长度：页面总数。 你应该使用 memset，来完成初始化页面为0。同时虚拟页表映射部分pages数组</span></span><br><span class="line">	<span class="comment">// 你的代码:模仿上面的页目录表设置即可</span></span><br><span class="line">	pages = (<span class="keyword">struct</span> PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages);</span><br><span class="line">	<span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 完成了内核的页目录表，页表，空页分配，初始化后，以后的操作将会通过 page_* functions. 完成。其中的操作，指映射内存：boot_map_region或者page_insert</span></span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">1</span>);</span><br><span class="line">	check_page_alloc();</span><br><span class="line">	check_page();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 现在我们解决以下虚拟内存sd：flags</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 对于线性地址 UPAGES （用户只读）进行页面映射</span></span><br><span class="line">	<span class="comment">// 权限设定:</span></span><br><span class="line">	<span class="comment">//    -  UPAGES 的新快照--权限 内核 读，用户 读</span></span><br><span class="line">	<span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">	<span class="comment">//    - 页面本身权限 -- 内核 RW, 用户无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line">	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//  使用 &#x27;bootstack&#x27; 引用的物理内存作为内核栈.  内核栈从虚拟地址 KSTACKTOP 开始向下增长.</span></span><br><span class="line">	<span class="comment">// 从 [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">	<span class="comment">// 作为内核栈, 但是划分为两块:</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- 有物理内存作为映射</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- 没有物理内存对应; 所以如果内核栈溢出, 会出错而不是覆写溢出对应的内存，比如guard page</span></span><br><span class="line">	<span class="comment">//     权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line">	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 映射所有 KERNBASE 开始的物理内存.</span></span><br><span class="line">	<span class="comment">// Ie.  虚拟地址范围 [KERNBASE, 2^32) 应该映射</span></span><br><span class="line">	<span class="comment">//      到实际物理地址范围 [0, 2^32 - KERNBASE)</span></span><br><span class="line">	<span class="comment">// 我们可能实际没有这么大： 2^32 - KERNBASE 物理内存的字节, but</span></span><br><span class="line">	<span class="comment">// 但是你应该还是要设置这个映射.</span></span><br><span class="line">	<span class="comment">// 权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br><span class="line">	<span class="comment">// 检查初始化的页目录表是否正确设置</span></span><br><span class="line">	check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从小页表转换到 我们创建的全kern_pgdir</span></span><br><span class="line">	<span class="comment">// 页目录表.	我们的pc现在应该指向</span></span><br><span class="line">	<span class="comment">// 在 KERNBASE and KERNBASE+4MB , 那么两个页表都会有这样的地址映射</span></span><br><span class="line">	<span class="comment">// 如果机器这时候重启了, 你应该就是设置kern_pgdir页目录表的时候错了.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// entry.S 设置了cr0中的 flags  (包括了小页表建立).  我们这里设置一些我们需要的flags</span></span><br><span class="line">	cr0 = rcr0();</span><br><span class="line">	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">	cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">	lcr0(cr0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些更多的设置,只有当kern_pgdir页目录表初始化后才能起效果</span></span><br><span class="line">	check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_init：对pages数组初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">			&#123;	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">				pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; i&lt;npages_basemem)</span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">			pages[i].pp_link = page_free_list; </span><br><span class="line">			page_free_list = &amp;pages[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=IOPHYSMEM/PGSIZE &amp;&amp; i&lt; EXTPHYSMEM/PGSIZE )</span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">			pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( i &gt;= EXTPHYSMEM / PGSIZE &amp;&amp; </span><br><span class="line">				i &lt; ( (<span class="type">int</span>)(boot_alloc(<span class="number">0</span>)) - KERNBASE)/PGSIZE)<span class="comment">//KERNBASE注意要加，pages里i就是物理地址从0开始的页数</span></span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">			pages[i].pp_link =<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">			pages[i].pp_link = page_free_list;</span><br><span class="line">			page_free_list = &amp;pages[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_alloc：从空闲表中分配一页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">res</span> =</span> page_free_list;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;page_alloc: out of free memory\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	page_free_list = res-&gt;pp_link;</span><br><span class="line">	res-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(res), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>page_free释放页到空闲表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="comment">// Hint: 你应该调用panic如果 pp-&gt;pp_ref 非0（有被引用） 或pp-&gt;pp_link 非空（找不到空闲表就无法找到要做空的页面）.</span></span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;page_free: pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;<span class="comment">//放入空闲表头部</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise3-1"><a href="#Exercise3-1" class="headerlink" title="Exercise3"></a>Exercise3</h3><p>虚拟地址：我们的代码都会被mmu进行转换，因此指针只能作为虚拟地址（或者偏移量）</p>
<h3 id="Exercise4-1"><a href="#Exercise4-1" class="headerlink" title="Exercise4"></a>Exercise4</h3><p>page_walk从页目录开始找到va point to PTE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pte_t *</span><br><span class="line">pgdir_walk(pde_t *pgdir, const void *va, int create)</span><br><span class="line">&#123;</span><br><span class="line">	// Fill this function in</span><br><span class="line">	pde_t* ppde = pgdir + PDX(va);</span><br><span class="line">	if (!(*ppde &amp; PTE_P)) &#123;								</span><br><span class="line">		if (create) &#123;</span><br><span class="line">			struct PageInfo *pp = page_alloc(1);</span><br><span class="line">			if (pp == NULL) &#123;</span><br><span class="line">				return NULL;</span><br><span class="line">			&#125;</span><br><span class="line">			pp-&gt;pp_ref++;</span><br><span class="line">			*ppde = (page2pa(pp)) | PTE_P | PTE_U | PTE_W;	</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return (pte_t *)KADDR(PTE_ADDR(*ppde)) + PTX(va);		//注意返回的是页表项虚址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boot_map_region给定范围进行映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">size_t</span> pgs = size / PGSIZE;</span><br><span class="line">	<span class="keyword">if</span> (size % PGSIZE != <span class="number">0</span>) &#123;<span class="comment">//多一页</span></span><br><span class="line">		pgs++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pgs; i++) &#123;<span class="comment">//对页表进行映射：填充页表项</span></span><br><span class="line">		<span class="type">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (pte == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			panic(<span class="string">&quot;boot_map_region(): out of memory\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		*pte = pa | PTE_P | perm;<span class="comment">//填充页表项</span></span><br><span class="line">		pa += PGSIZE;</span><br><span class="line">		va += PGSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_insert插入一页：页表项的创建或者替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);<span class="comment">//我们可能新建了一个页表项</span></span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	pp-&gt;pp_ref++;										</span><br><span class="line">	<span class="keyword">if</span> ((*pte) &amp; PTE_P) &#123;								<span class="comment">//替换这个页表项</span></span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pa = page2pa(pp);</span><br><span class="line">	*pte = pa | perm | PTE_P;</span><br><span class="line">	pgdir[PDX(va)] |= perm;<span class="comment">//页目录也要同步权限</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_lookup根据虚拟地址找到PageInfo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="type">pte_t</span> *pte =  pgdir_walk(pgdir, va, <span class="number">0</span>);			<span class="comment">//不允许创建页表项</span></span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(*pte) &amp; PTE_P) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pa = PTE_ADDR(*pte);					</span><br><span class="line">	pp = pa2page(pa);								</span><br><span class="line">	<span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		*pte_store = pte;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>page_remove删除一页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span> *pte_store;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pte_store);</span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	page_decref(pp);</span><br><span class="line">	*pte_store = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>happy！代码在这：<a target="_blank" rel="noopener" href="https://github.com/sakura-mac/mit_6.828_jos">Source Code</a></p>
<p><img src="https://bed1.oss-cn-beijing.aliyuncs.com/202112211121500.png"></p>
<h3 id="Exercise5-1"><a href="#Exercise5-1" class="headerlink" title="Exercise5"></a>Exercise5</h3><ol>
<li>我们的虚拟内存包含了内核和用户空间映射. 为什么用户程序不能访问内核空间?有什么机制？</li>
</ol>
<p>A：页表的PTE_U做权限保护。</p>
<ol start="2">
<li>操作系统最大能支持多大的物理空间？为什么？</li>
</ol>
<p>A：总共有4KB * 1K &#x3D; 4MB的大小，用来存放pages数组，PageInfo有8B，也就是总共可以存4MB&#x2F;8B&#x3D;0.5M个页面，页大小4KB，那么内存支持为0.5M*4KB&#x3D;2GB，所以最多提供2GB。之所以不是4GB是因为这里最终使用pages（UPAGES）来管理内存并且只有4MB，所以二级页表好像有点拉垮？总之如果pages扩展到8MB就会有4GB</p>
<ol start="3">
<li>如果物理内存尽可能用，那么我们能有多大的地方来管理内存?</li>
</ol>
<p>A：pages数组4MB，总页表对应页表项4B*0.5M&#x3D;2MB，对应只用了内核页目录2KB，所以6MB+2KB。</p>
<ol start="4">
<li>是什么时候EIP从低地址到KERNBASE上开始运行？是什么导致了这种转变？为什么？</li>
</ol>
<p>A：是页表设置完毕之后。mmu会将每个地址访问（数据&#x2F;代码）通过cr3来进行转换。原先给定的偏移只能映射4MB，但是代码会给出高于这个偏移能力的地址。因此只能通过划分地址，访问编写的多级页表，根据所给的<strong>填写物理地址的页表&#x2F;页目录项</strong>来完成映射。</p>
<h2 id="关键文件代码注释"><a href="#关键文件代码注释" class="headerlink" title="关键文件代码注释"></a>关键文件代码注释</h2><p>本实验中有用的东西快速回忆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">宏 </span><br><span class="line">PADDR(kva)</span><br><span class="line">kDDR(pa)</span><br><span class="line">UVPT</span><br><span class="line">UPAGES</span><br><span class="line">KERNBASE</span><br><span class="line">IOPHYSMEM</span><br><span class="line">PGSIZE</span><br><span class="line">PTSIZE</span><br><span class="line">PTE_ADDR</span><br><span class="line"><span class="title function_">PDX</span><span class="params">(la)</span></span><br><span class="line"><span class="title function_">PTX</span><span class="params">(la)</span></span><br><span class="line">npages</span><br><span class="line">npages_basemem</span><br><span class="line">npages_extmem</span><br><span class="line"></span><br><span class="line">函数</span><br><span class="line"><span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line"><span class="title function_">pa2page</span><span class="params">(pa)</span></span><br><span class="line"><span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line"></span><br><span class="line">定义</span><br><span class="line"><span class="type">unit32_t</span> <span class="type">pte_t</span></span><br><span class="line"><span class="type">unit32_t</span> <span class="type">pde_t</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"><span class="type">int</span> pp_ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="type">pde_t</span> *kern_pgdir</span><br></pre></td></tr></table></figure>



<h3 id="inc-x2F-memlayout-h"><a href="#inc-x2F-memlayout-h" class="headerlink" title="inc&#x2F;memlayout.h"></a>inc&#x2F;memlayout.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_INC_MEMLAYOUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_INC_MEMLAYOUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* not __ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个文件定义了实验os中的虚拟空间布局,</span></span><br><span class="line"><span class="comment"> * 包括了内核空间和用户空间布局.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符的存放偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_KT     0x08     <span class="comment">// 内核代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_KD     0x10     <span class="comment">// 内核数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_UT     0x18     <span class="comment">// 用户代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_UD     0x20     <span class="comment">// 用户数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GD_TSS0   0x28     <span class="comment">// 对于CPU0的段选择子</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *           虚拟空间   :                              权限</span></span><br><span class="line"><span class="comment"> *                                                    kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4 G   --------&gt;  +------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     |   内核空间：映射lab1放的物理地址 | RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *    内核空间起点, ----&gt;  +------------------------------+ 0xf0000000      </span></span><br><span class="line"><span class="comment"> *                     |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span></span><br><span class="line"><span class="comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span></span><br><span class="line"><span class="comment"> *                     |  Cur. 页表存放：（用户只读）     | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span></span><br><span class="line"><span class="comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span></span><br><span class="line"><span class="comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    用户栈顶    ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |              用户栈           | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     用户代码，数据 &amp; 堆         |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |  User 符号表 Data (可选)       |                 PTSIZE</span></span><br><span class="line"><span class="comment"> *    用户数据起始 ----&gt;  +------------------------------+ 0x00200000        |</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *    0 ------------&gt;  +------------------------------+                 --+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) Note: 内核保证invalid memory永远不会被映射.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; 可以用于需要情况下的映射</span></span><br><span class="line"><span class="comment"> *     如果有必要，用户程序可以暂时占用虚拟内存内存UTEMP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页目录结构从这个地址开始</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERNBASE	0xF0000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// At IOPHYSMEM (640K) 有个 384K 空洞留给 I/O.  From the kernel,</span></span><br><span class="line"><span class="comment">// IOPHYSMEM 可以指定为 KERNBASE + IOPHYSMEM.  空洞</span></span><br><span class="line"><span class="comment">// 在物理地址 EXTPHYSMEM 截止</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOPHYSMEM	0x0A0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTPHYSMEM	0x100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP	KERNBASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTKSIZE	(8*PGSIZE)   		<span class="comment">// 内核栈大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTKGAP		(8*PGSIZE)   		<span class="comment">// guard内核栈大小：防止访问越界</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射IO虚址.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOLIM		(KSTACKTOP - PTSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOBASE	(MMIOLIM - PTSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM		(MMIOBASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只读的用户映射！ 从这里往下直到UTOP都是用户只读</span></span><br><span class="line"><span class="comment"> * 在env分配时候，这是全局页表的映射地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户只读的页表基虚址 (see &#x27;uvpt&#x27; below)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT		(ULIM - PTSIZE)</span></span><br><span class="line"><span class="comment">// 只读的页表复制</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPAGES		(UVPT - PTSIZE)</span></span><br><span class="line"><span class="comment">// 只读的全局env页表虚址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENVS		(UPAGES - PTSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用户虚址顶部，用户可以从 UTOP-1 开始向下访问!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户访问虚址顶</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTOP		UENVS</span></span><br><span class="line"><span class="comment">// 用户的异常栈顶部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UXSTACKTOP	UTOP</span></span><br><span class="line"><span class="comment">// Next page left invalid to guard against exception stack overflow; then:</span></span><br><span class="line"><span class="comment">// Top of normal user stack</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTACKTOP	(UTOP - 2*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Where user programs generally begin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEXT		(2*PTSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Used for temporary page mappings.  Typed &#x27;void*&#x27; for convenience</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEMP		((void*) PTSIZE)</span></span><br><span class="line"><span class="comment">// Used for temporary page mappings for the user page-fault handler</span></span><br><span class="line"><span class="comment">// (should not conflict with other temporary page mappings)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFTEMP		(UTEMP + PTSIZE - PGSIZE)</span></span><br><span class="line"><span class="comment">// The location of the user-level STABS data structure</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTABDATA	(PTSIZE / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">pde_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> JOS_USER</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 首先根据虚拟地址进入页目录（lib/entry.S里看设定pte_t/pde_t结构（uvpd和uvpt）），从</span></span><br><span class="line"><span class="comment"> * [UVPT, UVPT + PTSIZE) 范围，找到页表物理地址。因此</span></span><br><span class="line"><span class="comment"> * 页目录表同时也可以认为是页表：实际上就这么干了，具体代码看下面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 简单来说，进程自有的页表映射由于内存问题被分为两部分：页目录表和页表，我们根据虚拟地址就可以进入自有页表，根据uvpt[N]（得到uvpt[N]方法： (UVPT + (UVPT &gt;&gt; PGSHIFT))）得到”页“pa，完成物理映射</span></span><br><span class="line"><span class="comment"> * 不过还有问题：1.从虚拟地址访问的页目录表，那么他的物理地址在哪？2.页表直接访问页的地址吗？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//1.进行位移来映射：PADDR，KADDR来完成</span></span><br><span class="line"> <span class="comment">//2.页表访问了pages数组，用于管理页的申请，引用，释放</span></span><br><span class="line"> <span class="comment">//说句题外话，xv6设计为内核/用户的页表切换，但是linux不进行切换页表，因为内核/用户切换开销大。并且对于内核页表，有两种方式：1.共享2.复制。linux选择了后者，并且统一内核/用户的页表。并且访问得到”物理地址“后，并没有直接访问页。还需要一个空闲表（哈希队列）来完成页的管理，所以很麻烦。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];     <span class="comment">// 页表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];     <span class="comment">// 页目录表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在UPAGES里存储的PageInfo，可以认为是个描述符，实际上就是个链表：</span></span><br><span class="line"><span class="comment"> * Read/write 内核, read-only 用户.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们知道每个页表项唯一映射一个虚页和物理页的地址</span></span><br><span class="line"><span class="comment"> * 但是这里的PageInfo没有存储物理页，只是有个指针，具体物理地址去kern/pmap.h里的page2pa()找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> &#123;</span></span><br><span class="line">	<span class="comment">// 物理内存空闲（未被进程使用：让我们考虑生产者-消费者问题）表的第一个页指针：注意这两种PageInfo的不同使用情景：页表项存放PageInfo-&gt;空闲表的头-&gt;空闲表访问</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp_ref是指向空闲表里空闲页面的引用计数：考虑多个paddr映射同一个vaddr，如果为0，我们就可以认为这个物理页可以被重新分配给任何进程使用</span></span><br><span class="line">	<span class="comment">// 通过 page_alloc来分配内存，还有映射</span></span><br><span class="line">	<span class="comment">// 在boot时候就会使用pamp.c来分配内存映射，做一个小页表</span></span><br><span class="line">	<span class="comment">// boot_alloc 并没有有效的引用计数，所以可以认为是个”小“页表，第一个实验就要实现这个</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !JOS_INC_MEMLAYOUT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="kern-x2F-pmap-h"><a href="#kern-x2F-pmap-h" class="headerlink" title="kern&#x2F;pmap.h"></a>kern&#x2F;pmap.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"><span class="comment">//pmap一般用来分配内存，建立/删除映射，所以相当于虚拟空间和物理空间之间的接口：接受/返回 虚拟地址/物理地址，从而进行内存交互。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERN_PMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_KERN_PMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERNEL</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> <span class="string">&quot;This is a JOS kernel header; user programs should not #include it&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> bootstacktop[], bootstack[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> npages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">pde_t</span> *kern_pgdir;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个宏 接受虚拟的内核地址--当然指向KERNEBASE上, 返回相应的物理地址.  如果传递非内核地址，报错。其中，他最高能够达到256MB物理地址的映射</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line">_paddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">void</span> *kva)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">uint32_t</span>)kva &lt; KERNBASE)</span><br><span class="line">		_panic(file, line, <span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">physaddr_t</span>)kva - KERNBASE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个宏 接受物理地址，返回虚拟地址.  如果物理地址是错误的，就报错</span></span><br><span class="line"><span class="comment">#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline void*</span></span><br><span class="line"><span class="comment">_kaddr(const char *file, int line, physaddr_t pa)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if (PGNUM(pa) &gt;= npages)</span></span><br><span class="line"><span class="comment">		_panic(file, line, &quot;KADDR called with invalid pa %08lx&quot;, pa);</span></span><br><span class="line"><span class="comment">	return (void *)(pa + KERNBASE);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">enum &#123;</span></span><br><span class="line"><span class="comment">	// 对于分配内存页, 我们对所有的内存进行置0.（当然很多内存分配不置0，比如malloc这样的，也有置0的，比如linux中，mmap加载ELF只分配虚拟地址，访问.bss节时，没有页表项，中断分配内存时就并不访问磁盘，而是找个物理内存页，置0）</span></span><br><span class="line"><span class="comment">	ALLOC_ZERO = 1&lt;&lt;0,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void	mem_init(void);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void	page_init(void);</span></span><br><span class="line"><span class="comment">struct PageInfo *page_alloc(int alloc_flags);</span></span><br><span class="line"><span class="comment">void	page_free(struct PageInfo *pp);</span></span><br><span class="line"><span class="comment">int	page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);</span></span><br><span class="line"><span class="comment">void	page_remove(pde_t *pgdir, void *va);</span></span><br><span class="line"><span class="comment">struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);</span></span><br><span class="line"><span class="comment">void	page_decref(struct PageInfo *pp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void	tlb_invalidate(pde_t *pgdir, void *va);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline physaddr_t</span></span><br><span class="line"><span class="comment">page2pa(struct PageInfo *pp)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return (pp - pages) &lt;&lt; PGSHIFT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline struct PageInfo*</span></span><br><span class="line"><span class="comment">pa2page(physaddr_t pa)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if (PGNUM(pa) &gt;= npages)</span></span><br><span class="line"><span class="comment">		panic(&quot;pa2page called with invalid pa&quot;);</span></span><br><span class="line"><span class="comment">	return &amp;pages[PGNUM(pa)];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static inline void*</span></span><br><span class="line"><span class="comment">page2kva(struct PageInfo *pp)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return KADDR(page2pa(pp));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#endif /* !JOS_KERN_PMAP_H */</span></span><br></pre></td></tr></table></figure>



<h3 id="kern-x2F-pmap-c"><a href="#kern-x2F-pmap-c" class="headerlink" title="kern&#x2F;pmap.c"></a>kern&#x2F;pmap.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"><span class="comment">//在这里我们将会建立完整的页面映射，你会填写以下代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*exercise1</span></span><br><span class="line"><span class="comment">* 1.boot_alloc() 启动的时候给内核分配虚拟页</span></span><br><span class="line"><span class="comment">* 2.mem_init()（仅限于调用`check_page_free_list(1)`）给内核建立页目录，并建立pages数组，然后建立映射</span></span><br><span class="line"><span class="comment">* 3.page_init() 建立空闲表</span></span><br><span class="line"><span class="comment">* 4.page_alloc() 从空闲表中找到空页并分配</span></span><br><span class="line"><span class="comment">* 5.page_free() 释放页面为空页放入空闲表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*exercise 4</span></span><br><span class="line"><span class="comment">* 1.pgdir_walk() 访问两级”页表“，找到PDE的虚拟地址</span></span><br><span class="line"><span class="comment">* 2.boot_map_region() 填充映射</span></span><br><span class="line"><span class="comment">* 3.page_lookup() 根据虚拟地址，得到PageInfo的虚拟地址</span></span><br><span class="line"><span class="comment">* 4.page_remove() 删除页</span></span><br><span class="line"><span class="comment">* 5.page_insert() 插入页</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/kclock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些变量由i386_detect_memory()设定</span></span><br><span class="line"><span class="type">size_t</span> npages;			<span class="comment">// 物理页数量 (in pages)</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> npages_basemem;	<span class="comment">// 基础内存页数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些变量由 mem_init()设定</span></span><br><span class="line"><span class="type">pde_t</span> *kern_pgdir;		<span class="comment">// 内核的初始页目录虚基址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span>		<span class="comment">// 能够管理的页面</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page_free_list</span>;</span>	<span class="comment">// 空闲表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 检测机器的物理内存配置</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nvram_read</span><span class="params">(<span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> mc146818_read(r) | (mc146818_read(r + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">i386_detect_memory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> basemem, extmem, ext16mem, totalmem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用CMOS调用来测量基本和扩展内存</span></span><br><span class="line">	<span class="comment">// (CMOS calls 以KB单位返回结果.)</span></span><br><span class="line">	basemem = nvram_read(NVRAM_BASELO);</span><br><span class="line">	extmem = nvram_read(NVRAM_EXTLO);</span><br><span class="line">	ext16mem = nvram_read(NVRAM_EXT16LO) * <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算可用物理页数量：基本和扩展内存中</span></span><br><span class="line">	<span class="keyword">if</span> (ext16mem)</span><br><span class="line">		totalmem = <span class="number">16</span> * <span class="number">1024</span> + ext16mem;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (extmem)</span><br><span class="line">		totalmem = <span class="number">1</span> * <span class="number">1024</span> + extmem;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		totalmem = basemem;</span><br><span class="line"></span><br><span class="line">	npages = totalmem / (PGSIZE / <span class="number">1024</span>);</span><br><span class="line">	npages_basemem = basemem / (PGSIZE / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;Physical memory: %uK available, base = %uK, extended = %uK\n&quot;</span>,</span><br><span class="line">		totalmem, basemem, totalmem - basemem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 从 UTOP ：内核上开始建立页表映射.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page_free_list</span><span class="params">(<span class="type">bool</span> only_low_memory)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page_alloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_kern_pgdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">physaddr_t</span> <span class="title function_">check_va2pa</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_page_installed_pgdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的boot内存分配调用page_alloc() 来实现.注：为了区分，空页意味着未被分配，空闲页则可能是空页；也可能不是，只是未被进程使用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果指定内存大小n字节&gt;0, 分配连续的内存，一般是稍大一点，来足够满足n字节的大小需求</span></span><br><span class="line"><span class="comment">// 但是并没有初始化这个内存. 返回内核的虚拟地址.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果n==0, 返回紧邻着的下一个空页（一开始分配，一定是引用计数为0的空闲表结点）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果内存耗尽, boot_alloc 应该报错</span></span><br><span class="line"><span class="comment">// 这个函数仅在boot给内核分配内存使用,</span></span><br><span class="line"><span class="comment">// 在 page_free_list 空闲表完成之前调用函数.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// 下一个空页虚拟地址</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化nextfree ：第一次被boot_alloc时候</span></span><br><span class="line">	<span class="comment">// &#x27;end&#x27; 指向.bss节最高处:</span></span><br><span class="line">	<span class="comment">// 从此代码和数据分配完成，紧接着自由分配</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//你应该1.分配足够大的内存，2.并更新nextfree，确保了nextfree（地址）以PGSIZE倍数对齐，如果不明白对齐，你应该看《深入理解操作系统》中虚拟内存里堆malloc地址对齐的讲解</span></span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立两级页表和pages数组</span></span><br><span class="line"><span class="comment">//    对于内核：kern_pgdir 是是内核页目录表虚拟基址</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个部分仅仅分配了内核的映射</span></span><br><span class="line"><span class="comment">// (ie. addresses &gt;= UTOP).  用户映射建立会在进程创建的时候发生</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 从 UTOP 到 ULIM, 用户只读</span></span><br><span class="line"><span class="comment">// 在 ULIM 上，用户禁止访问</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line">	<span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到这个机器以页为单位到底有多大 (npages &amp; npages_basemem).</span></span><br><span class="line">	i386_detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当你准备好测试的时候，把这一行注释：因为是报错用</span></span><br><span class="line">	panic(<span class="string">&quot;mem_init: This function is not finished\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 创建初始页目录表</span></span><br><span class="line">	kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);<span class="comment">//只有4KB</span></span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 递归插入 PD 作为页表映射：</span></span><br><span class="line">	<span class="comment">// 只设置了一个页目录项，相当于同时只建立了一个页表，剩下暂时没有建立映射:这里非常奇怪的是将UVPT通过页目录项映射到了kern_pgdir上，相当于一个4kb虚拟页表映射到了内核页目录上（为什么虚拟内存中要映射页表UVPT和UPAGES呢），而不是映射到新的物理页作为页表的存储。</span></span><br><span class="line">	<span class="comment">// 权限: 内核 , 用户 </span></span><br><span class="line">	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 你应该分配一个PageInfo的数组，你应该知道这个结构体定义，什么用</span></span><br><span class="line">	<span class="comment">// 内核通过这个数组追踪物理页， &#x27;npages&#x27; 代表了数组的长度：页面总数。 你应该使用 memset，来完成初始化页面为0</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 完成了内核的页目录表，页表，空页分配，初始化后，以后的操作将会通过 page_* functions. 完成。其中的操作，指分配内存：boot_map_region或者page_insert？？？</span></span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">1</span>);</span><br><span class="line">	check_page_alloc();</span><br><span class="line">	check_page();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 现在我们解决以下虚拟内存sd：flags</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 对于线性地址 UPAGES （用户只读）进行页面映射</span></span><br><span class="line">	<span class="comment">// 权限设定:</span></span><br><span class="line">	<span class="comment">//    -  UPAGES 的新快照-- 内核 读，用户 读</span></span><br><span class="line">	<span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">	<span class="comment">//    - 页面本身权限 -- 内核 RW, 用户无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">//  使用 &#x27;bootstack&#x27; 引用的物理内存作为内核栈.  内核栈从虚拟地址 KSTACKTOP 开始向下增长.</span></span><br><span class="line">	<span class="comment">// 从 [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">	<span class="comment">// 作为内核栈, 但是划分为两块:</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- 有物理内存作为映射</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- 没有物理内存对应; 所以如果内核栈溢出, 会出错而不是覆写溢出对应的内存，比如guard page</span></span><br><span class="line">	<span class="comment">//     权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// 映射所有 KERNBASE 开始的物理内存.</span></span><br><span class="line">	<span class="comment">// Ie.  虚拟地址范围 [KERNBASE, 2^32) 应该映射</span></span><br><span class="line">	<span class="comment">//      到实际物理地址范围 [0, 2^32 - KERNBASE)</span></span><br><span class="line">	<span class="comment">// 我们可能实际没有这么大： 2^32 - KERNBASE 物理内存的字节, but</span></span><br><span class="line">	<span class="comment">// 但是你应该还是要设置这个映射.</span></span><br><span class="line">	<span class="comment">// 权限: 内核 可读可写, 用户 无权限</span></span><br><span class="line">	<span class="comment">// 你的代码:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查初始化的页目录表是否正确设置</span></span><br><span class="line">	check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从小页表转换到 我们创建的全kern_pgdir</span></span><br><span class="line">	<span class="comment">// 页目录表.	我们的pc现在应该指向</span></span><br><span class="line">	<span class="comment">// 在 KERNBASE and KERNBASE+4MB , 那么两个页表都会有这样的地址映射</span></span><br><span class="line">	<span class="comment">// 如果机器这时候重启了, 你应该就是设置kern_pgdir页目录表的时候错了.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// entry.S 设置了cr0中的 flags  (包括了小页表建立).  我们这里设置一些我们需要的flags</span></span><br><span class="line">	cr0 = rcr0();</span><br><span class="line">	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">	cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">	lcr0(cr0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一些更多的设置,只有当kern_pgdir页目录表初始化后才能起效果</span></span><br><span class="line">	check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 追踪物理页表.</span></span><br><span class="line"><span class="comment">// 不要忘记我们的页表项PageInfo数组已经建立，但是空闲表还没建立</span></span><br><span class="line"><span class="comment">// 页面应该在空闲表里, 并且空闲表里存在空页结点</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化页结构，还有空闲表</span></span><br><span class="line"><span class="comment">// 完成之后, 不应该再使用boot_alloc. 而是应该使用下面的allocator函数来通过空闲表来分配，重分配物理页面</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">// 现在我们的页面都是空的：引用计数为0.</span></span><br><span class="line">	<span class="comment">// 但是这当然不正确.  什么样的内存是真的空的?</span></span><br><span class="line">	<span class="comment">//  1)将物理页面0标记为正在使用（非空闲）。这样我们就保留了实模式的IDT和基本输入输出系统结构，以防我们需要它们。(目前我们没有，但是...)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 2)基础内存的剩余部分，[PGSIZE，npages_basemem * PGSIZE)认为空闲。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 3)然后是IO空[IOPHYSMEM，EXTPHYSMEM)，它必须从不被分配。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 4)然后扩展内存[EXTPHYSMEM，...).</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//既然有的页正在被使用，有的是空闲的。那么</span></span><br><span class="line">	<span class="number">1.</span>内核在物理内存中的哪里？</span><br><span class="line">	<span class="number">2.</span>哪些页面已经在使用页表和其他数据结构？</span><br><span class="line">	<span class="comment">// 请你修改代码？？来回答这一点.</span></span><br><span class="line">	<span class="comment">// 注意: 请不要碰那些和空闲页对应的物理内存</span></span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一页物理页.  如果 (alloc_flags &amp; ALLOC_ZERO), 那么你就应该多做一点：填充0</span></span><br><span class="line"><span class="comment">// 返回这个物理页面必须以 &#x27;\0&#x27; 结尾.  不要增加引用计数 - 这是由调用函数做的 (或者通过 page_insert函数来做)，因为分配页面只是空页，还未被使用.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 确保将上述页面设置了 pp_link  为 NULL 以便于</span></span><br><span class="line"><span class="comment">// page_free 这个页面释放函数可以防止重复释放的bug.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果可分配物理内存为0返回 NULL .</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 使用 page2kva 和 memset来完成代码书写</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 向空闲表返回一页.</span></span><br><span class="line"><span class="comment">// (当pp-&gt;pp_ref引用计数为0，代表页面应该释放，于是应该从空闲表拿出，放入头部，方便下次当作空页取出使用)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="comment">// Hint: 你应该调用panic如果 pp-&gt;pp_ref 非0（有被引用） 或pp-&gt;pp_link 非空（找不到空闲表就无法找到要做空的页面）.</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用计数，当为0时候，free掉它</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> PageInfo* pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (--pp-&gt;pp_ref == <span class="number">0</span>)</span><br><span class="line">		page_free(pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定pgdir作为指向页目录表的指针, pgdir_walk 返回指向页表的虚拟地址&#x27;va&#x27;（pte）.</span></span><br><span class="line"><span class="comment">// 这需要走两级“页表”：进程的”页表“来找到页目录表，页目录表来找到页表</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 寻找页表过程中相关的页表项可能并不存在.我们可能就应该创建页表，来开始新的映射建立</span></span><br><span class="line"><span class="comment">// 如果创造新页表失败, 那么 create == false, 那么pgdir_walk 返回NULL.</span></span><br><span class="line"><span class="comment">// 否则, pgdir_walk 通过调用page_alloc分配一个新页作为新页表.</span></span><br><span class="line"><span class="comment">//    - 如果分配失败, pgdir_walk 返回 NULL.</span></span><br><span class="line"><span class="comment">//    - 否则, 增加新页的引用计数,清除页内容</span></span><br><span class="line"><span class="comment">//	然后 pgdir_walk 返回一个新的页表页的指针.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: 你可以把PageInfo * 通过page2pa(在kern/pmap.h里)转换得到页物理地址 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2:  x86 MMU 检查权限位：无论是页目录表还是页表，所以你或许应该放宽你的权限：走个形式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: 看  inc/mmu.h 里有对多级页表（页目录表和页表）的宏定义，有些帮助</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定页目录表的根外设的页表映射 </span></span><br><span class="line"><span class="comment">// 在pgdir中映射虚拟地址 [va, va+size) 到物理地址[pa, pa+size)</span></span><br><span class="line"><span class="comment">// 大小是 PGSIZE, 并且va和pa都要地址页对齐</span></span><br><span class="line"><span class="comment">// 使用权限位 perm|PTE_P 来进行入口时mmu检查.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个函数仅仅为了建立从UTOP上的静态映射（RO ENVS）,比如，我们不应该增加pp_ref引用计数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 通过使用 pgdir_walk解决寻找到页表项填充映射问题</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配页表中：映射物理页 &#x27;pp&#x27; 到虚拟页 &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// 页表PTE权限 (低 12 bits) </span></span><br><span class="line"><span class="comment">// 应该被设置为&#x27;perm|PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//   - 如果已经有虚拟页映射 &#x27;va&#x27;, 应该调用page_remove().</span></span><br><span class="line"><span class="comment">//   - 如果有必要, on demand, 一个页表应该被分配，然后快照插入到pgdir页目录表</span></span><br><span class="line"><span class="comment">//   - 如果插入成功，那么pp-&gt;pp_ref 应该增加：进程引用+1</span></span><br><span class="line"><span class="comment">//   - 如果已经有页表项占用了va，那么我们的页目录表项就应该无效</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  极端情况处理hint: 你应该考虑在同一个页目录表中，同样的物理页地址重复映射同一个虚拟地址，应该怎么处理。然而，不需要在本函数代码中区分，因为会导致无法避免的bug，你应该在多层调用中分散处理。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">//   0 成功插入</span></span><br><span class="line"><span class="comment">//   -E_NO_MEM, 如果页表不能被分配</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 解决办法是调用 pgdir_walk, page_remove,page2pa</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回物理页面的虚拟地址</span></span><br><span class="line"><span class="comment">// 如果页表项 pte_store 不为0, 那么我们就应该认为找到了这个页表项，.它会将被page_remove删除，并且会在系统调用参数的时候验证权限，防止用户直接调用。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果没有页面对应va，那么返回 NULL</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 通过调用 pgdir_walk 和 pa2page来写代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 你的代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除页表项</span></span><br><span class="line"><span class="comment">// 给定页虚拟地址 &#x27;va&#x27;，来取消映射</span></span><br><span class="line"><span class="comment">// 如果没有物理页被映射，那么就应该什么都不干</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 细节:</span></span><br><span class="line"><span class="comment">//   - 引用计数应该-1</span></span><br><span class="line"><span class="comment">//   - 如果引用计数是0，那么应该做空页面</span></span><br><span class="line"><span class="comment">//   - 页表项存在的话，那么应该被设置为 0.</span></span><br><span class="line"><span class="comment">//   - 同时对于页表项的缓存也应该无效</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: 你赢该通过调用page_lookup,tlb_invalidate,  page_decref来帮助代码书写</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  你的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 仅仅当页表项已经被修改之后，才对页表项缓存无效化</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tlb_invalidate</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 仅仅当我们修改这个地址空间，才刷新这个页表项缓存</span></span><br><span class="line">	<span class="comment">// 刷新之后，这只有一个地址空间，所以是无效的？？？没懂</span></span><br><span class="line">	invlpg(va);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 检查函数</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that the pages on the page_free_list are reasonable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page_free_list</span><span class="params">(<span class="type">bool</span> only_low_memory)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> pdx_limit = only_low_memory ? <span class="number">1</span> : NPDENTRIES;</span><br><span class="line">	<span class="type">int</span> nfree_basemem = <span class="number">0</span>, nfree_extmem = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *first_free_page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!page_free_list)</span><br><span class="line">		panic(<span class="string">&quot;&#x27;page_free_list&#x27; is a null pointer!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (only_low_memory) &#123;</span><br><span class="line">		<span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line">		<span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> &#123; &amp;pp1, &amp;pp2 &#125;;</span><br><span class="line">		<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line">			<span class="type">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">			*tp[pagetype] = pp;</span><br><span class="line">			tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">		&#125;</span><br><span class="line">		*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">		page_free_list = pp1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if there&#x27;s a page that shouldn&#x27;t be on the free list,</span></span><br><span class="line">	<span class="comment">// try to make sure it eventually causes trouble.</span></span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link)</span><br><span class="line">		<span class="keyword">if</span> (PDX(page2pa(pp)) &lt; pdx_limit)</span><br><span class="line">			<span class="built_in">memset</span>(page2kva(pp), <span class="number">0x97</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	first_free_page = (<span class="type">char</span> *) boot_alloc(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line">		<span class="comment">// check that we didn&#x27;t corrupt the free list itself</span></span><br><span class="line">		assert(pp &gt;= pages);</span><br><span class="line">		assert(pp &lt; pages + npages);</span><br><span class="line">		assert(((<span class="type">char</span> *) pp - (<span class="type">char</span> *) pages) % <span class="keyword">sizeof</span>(*pp) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// check a few pages that shouldn&#x27;t be on the free list</span></span><br><span class="line">		assert(page2pa(pp) != <span class="number">0</span>);</span><br><span class="line">		assert(page2pa(pp) != IOPHYSMEM);</span><br><span class="line">		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);</span><br><span class="line">		assert(page2pa(pp) != EXTPHYSMEM);</span><br><span class="line">		assert(page2pa(pp) &lt; EXTPHYSMEM || (<span class="type">char</span> *) page2kva(pp) &gt;= first_free_page);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (page2pa(pp) &lt; EXTPHYSMEM)</span><br><span class="line">			++nfree_basemem;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			++nfree_extmem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assert(nfree_basemem &gt; <span class="number">0</span>);</span><br><span class="line">	assert(nfree_extmem &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page_free_list() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check the physical page allocator (page_alloc(), page_free(),</span></span><br><span class="line"><span class="comment">// and page_init()).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>, *<span class="title">pp0</span>, *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="type">int</span> nfree;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">fl</span>;</span></span><br><span class="line">	<span class="type">char</span> *c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pages)</span><br><span class="line">		panic(<span class="string">&quot;&#x27;pages&#x27; is a null pointer!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check number of free pages</span></span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list, nfree = <span class="number">0</span>; pp; pp = pp-&gt;pp_link)</span><br><span class="line">		++nfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to allocate three pages</span></span><br><span class="line">	pp0 = pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">	assert(pp0);</span><br><span class="line">	assert(pp1 &amp;&amp; pp1 != pp0);</span><br><span class="line">	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);</span><br><span class="line">	assert(page2pa(pp0) &lt; npages*PGSIZE);</span><br><span class="line">	assert(page2pa(pp1) &lt; npages*PGSIZE);</span><br><span class="line">	assert(page2pa(pp2) &lt; npages*PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// temporarily steal the rest of the free pages</span></span><br><span class="line">	fl = page_free_list;</span><br><span class="line">	page_free_list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be no free memory</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free and re-allocate?</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	page_free(pp1);</span><br><span class="line">	page_free(pp2);</span><br><span class="line">	pp0 = pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert(pp0);</span><br><span class="line">	assert(pp1 &amp;&amp; pp1 != pp0);</span><br><span class="line">	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);</span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test flags</span></span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp0), <span class="number">1</span>, PGSIZE);</span><br><span class="line">	page_free(pp0);</span><br><span class="line">	assert((pp = page_alloc(ALLOC_ZERO)));</span><br><span class="line">	assert(pp &amp;&amp; pp0 == pp);</span><br><span class="line">	c = page2kva(pp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGSIZE; i++)</span><br><span class="line">		assert(c[i] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// give free list back</span></span><br><span class="line">	page_free_list = fl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free the pages we took</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	page_free(pp1);</span><br><span class="line">	page_free(pp2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of free pages should be the same</span></span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link)</span><br><span class="line">		--nfree;</span><br><span class="line">	assert(nfree == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page_alloc() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Checks that the kernel part of virtual address space</span></span><br><span class="line"><span class="comment">// has been set up roughly correctly (by mem_init()).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function doesn&#x27;t test every corner case,</span></span><br><span class="line"><span class="comment">// but it is a pretty good sanity check.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_kern_pgdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> i, n;</span><br><span class="line">	<span class="type">pde_t</span> *pgdir;</span><br><span class="line"></span><br><span class="line">	pgdir = kern_pgdir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check pages array</span></span><br><span class="line">	n = ROUNDUP(npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo), PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += PGSIZE)</span><br><span class="line">		assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// check phys mem</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages * PGSIZE; i += PGSIZE)</span><br><span class="line">		assert(check_va2pa(pgdir, KERNBASE + i) == i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check kernel stack</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KSTKSIZE; i += PGSIZE)</span><br><span class="line">		assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);</span><br><span class="line">	assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check PDE permissions</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NPDENTRIES; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (i) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="title function_">PDX</span><span class="params">(UVPT)</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="title function_">PDX</span><span class="params">(KSTACKTOP<span class="number">-1</span>)</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="title function_">PDX</span><span class="params">(UPAGES)</span>:</span><br><span class="line">			<span class="title function_">assert</span><span class="params">(pgdir[i] &amp; PTE_P)</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= PDX(KERNBASE)) &#123;</span><br><span class="line">				assert(pgdir[i] &amp; PTE_P);</span><br><span class="line">				assert(pgdir[i] &amp; PTE_W);</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				assert(pgdir[i] == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(<span class="string">&quot;check_kern_pgdir() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function returns the physical address of the page containing &#x27;va&#x27;,</span></span><br><span class="line"><span class="comment">// defined by the page directory &#x27;pgdir&#x27;.  The hardware normally performs</span></span><br><span class="line"><span class="comment">// this functionality for us!  We define our own version to help check</span></span><br><span class="line"><span class="comment">// the check_kern_pgdir() function; it shouldn&#x27;t be used elsewhere.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">check_va2pa</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pte_t</span> *p;</span><br><span class="line"></span><br><span class="line">	pgdir = &amp;pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">if</span> (!(*pgdir &amp; PTE_P))</span><br><span class="line">		<span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">	p = (<span class="type">pte_t</span>*) KADDR(PTE_ADDR(*pgdir));</span><br><span class="line">	<span class="keyword">if</span> (!(p[PTX(va)] &amp; PTE_P))</span><br><span class="line">		<span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> PTE_ADDR(p[PTX(va)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// check page_insert, page_remove, &amp;c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>, *<span class="title">pp0</span>, *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">fl</span>;</span></span><br><span class="line">	<span class="type">pte_t</span> *ptep, *ptep1;</span><br><span class="line">	<span class="type">void</span> *va;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">pde_t</span> entry_pgdir[];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to allocate three pages</span></span><br><span class="line">	pp0 = pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">	assert(pp0);</span><br><span class="line">	assert(pp1 &amp;&amp; pp1 != pp0);</span><br><span class="line">	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// temporarily steal the rest of the free pages</span></span><br><span class="line">	fl = page_free_list;</span><br><span class="line">	page_free_list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be no free memory</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// there is no page allocated at address 0</span></span><br><span class="line">	assert(page_lookup(kern_pgdir, (<span class="type">void</span> *) <span class="number">0x0</span>, &amp;ptep) == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// there is no free memory, so we can&#x27;t allocate a page table</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, <span class="number">0x0</span>, PTE_W) &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free pp0 and try again: pp0 should be used for page table</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, <span class="number">0x0</span>, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(PTE_ADDR(kern_pgdir[<span class="number">0</span>]) == page2pa(pp0));</span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0x0</span>) == page2pa(pp1));</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(pp0-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be no free memory</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to map pp2 at PGSIZE because it&#x27;s already there</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp2 should NOT be on the free list</span></span><br><span class="line">	<span class="comment">// could happen in ref counts are handled sloppily in page_insert</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check that pgdir_walk returns a pointer to the pte</span></span><br><span class="line">	ptep = (<span class="type">pte_t</span> *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));</span><br><span class="line">	assert(pgdir_walk(kern_pgdir, (<span class="type">void</span>*)PGSIZE, <span class="number">0</span>) == ptep+PTX(PGSIZE));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to change permissions too.</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W|PTE_U) == <span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_U);</span><br><span class="line">	assert(kern_pgdir[<span class="number">0</span>] &amp; PTE_U);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should be able to remap with fewer permissions</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_W);</span><br><span class="line">	assert(!(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_U));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should not be able to map at PTSIZE because need free page for page table</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp0, (<span class="type">void</span>*) PTSIZE, PTE_W) &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert pp1 at PGSIZE (replacing pp2)</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, (<span class="type">void</span>*) PGSIZE, PTE_W) == <span class="number">0</span>);</span><br><span class="line">	assert(!(*pgdir_walk(kern_pgdir, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) &amp; PTE_U));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...</span></span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0</span>) == page2pa(pp1));</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));</span><br><span class="line">	<span class="comment">// ... and ref counts should reflect this</span></span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">2</span>);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp2 should be returned by page_alloc</span></span><br><span class="line">	assert((pp = page_alloc(<span class="number">0</span>)) &amp;&amp; pp == pp2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unmapping pp1 at 0 should keep pp1 at PGSIZE</span></span><br><span class="line">	page_remove(kern_pgdir, <span class="number">0x0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0x0</span>) == ~<span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test re-inserting pp1 at PGSIZE</span></span><br><span class="line">	assert(page_insert(kern_pgdir, pp1, (<span class="type">void</span>*) PGSIZE, <span class="number">0</span>) == <span class="number">0</span>);</span><br><span class="line">	assert(pp1-&gt;pp_ref);</span><br><span class="line">	assert(pp1-&gt;pp_link == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unmapping pp1 at PGSIZE should free it</span></span><br><span class="line">	page_remove(kern_pgdir, (<span class="type">void</span>*) PGSIZE);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, <span class="number">0x0</span>) == ~<span class="number">0</span>);</span><br><span class="line">	assert(check_va2pa(kern_pgdir, PGSIZE) == ~<span class="number">0</span>);</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 被 page_alloc 返回</span></span><br><span class="line">	assert((pp = page_alloc(<span class="number">0</span>)) &amp;&amp; pp == pp1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无可分配空页</span></span><br><span class="line">	assert(!page_alloc(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制 带回 pp0 ？？？？</span></span><br><span class="line">	assert(PTE_ADDR(kern_pgdir[<span class="number">0</span>]) == page2pa(pp0));</span><br><span class="line">	kern_pgdir[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	assert(pp0-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算检查 pgdir_walk</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	va = (<span class="type">void</span>*)(PGSIZE * NPDENTRIES + PGSIZE);</span><br><span class="line">	ptep = pgdir_walk(kern_pgdir, va, <span class="number">1</span>);</span><br><span class="line">	ptep1 = (<span class="type">pte_t</span> *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));</span><br><span class="line">	assert(ptep == ptep1 + PTX(va));</span><br><span class="line">	kern_pgdir[PDX(va)] = <span class="number">0</span>;</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查新分配的页表是否被清除干净（否则映射会错误，超级难debug ）</span></span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp0), <span class="number">0xFF</span>, PGSIZE);</span><br><span class="line">	page_free(pp0);</span><br><span class="line">	pgdir_walk(kern_pgdir, <span class="number">0x0</span>, <span class="number">1</span>);</span><br><span class="line">	ptep = (<span class="type">pte_t</span> *) page2kva(pp0);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NPTENTRIES; i++)</span><br><span class="line">		assert((ptep[i] &amp; PTE_P) == <span class="number">0</span>);</span><br><span class="line">	kern_pgdir[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回一个新的空闲链表</span></span><br><span class="line">	page_free_list = fl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放页面：引用计数为0</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line">	page_free(pp1);</span><br><span class="line">	page_free(pp2);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个已经初始化的 kern_pgdir，检查 page_insert, page_remove, &amp;c, </span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_page_installed_pgdir</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>, *<span class="title">pp0</span>, *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">fl</span>;</span></span><br><span class="line">	<span class="type">pte_t</span> *ptep, *ptep1;</span><br><span class="line">	<span class="type">uintptr_t</span> va;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查：对于已经初始化的页表，我们应该可以R/W</span></span><br><span class="line">	pp1 = pp2 = <span class="number">0</span>;</span><br><span class="line">	assert((pp0 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp1 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	assert((pp2 = page_alloc(<span class="number">0</span>)));</span><br><span class="line">	page_free(pp0);</span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp1), <span class="number">1</span>, PGSIZE);</span><br><span class="line">	<span class="built_in">memset</span>(page2kva(pp2), <span class="number">2</span>, PGSIZE);</span><br><span class="line">	page_insert(kern_pgdir, pp1, (<span class="type">void</span>*) PGSIZE, PTE_W);</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(*(<span class="type">uint32_t</span> *)PGSIZE == <span class="number">0x01010101</span>U);</span><br><span class="line">	page_insert(kern_pgdir, pp2, (<span class="type">void</span>*) PGSIZE, PTE_W);</span><br><span class="line">	assert(*(<span class="type">uint32_t</span> *)PGSIZE == <span class="number">0x02020202</span>U);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	assert(pp1-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">	*(<span class="type">uint32_t</span> *)PGSIZE = <span class="number">0x03030303</span>U;</span><br><span class="line">	assert(*(<span class="type">uint32_t</span> *)page2kva(pp2) == <span class="number">0x03030303</span>U);</span><br><span class="line">	page_remove(kern_pgdir, (<span class="type">void</span>*) PGSIZE);</span><br><span class="line">	assert(pp2-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强制带回 pp0 </span></span><br><span class="line">	assert(PTE_ADDR(kern_pgdir[<span class="number">0</span>]) == page2pa(pp0));</span><br><span class="line">	kern_pgdir[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	assert(pp0-&gt;pp_ref == <span class="number">1</span>);</span><br><span class="line">	pp0-&gt;pp_ref = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放我们带回的页</span></span><br><span class="line">	page_free(pp0);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;check_page_installed_pgdir() succeeded!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kern-x2F-kclock-h"><a href="#kern-x2F-kclock-h" class="headerlink" title="kern&#x2F;kclock.h"></a>kern&#x2F;kclock.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERN_KCLOCK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_KERN_KCLOCK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERNEL</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> <span class="string">&quot;This is a JOS kernel header; user programs should not #include it&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_RTC		0x070		<span class="comment">/* RTC port */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MC_NVRAM_START	0xe	<span class="comment">/* start of NVRAM: offset 14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MC_NVRAM_SIZE	50	<span class="comment">/* 50 bytes of NVRAM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NVRAM bytes 7 &amp; 8: base memory size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_BASELO	(MC_NVRAM_START + 7)	<span class="comment">/* low byte; RTC off. 0x15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_BASEHI	(MC_NVRAM_START + 8)	<span class="comment">/* high byte; RTC off. 0x16 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NVRAM bytes 9 &amp; 10: extended memory size (between 1MB and 16MB) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXTLO	(MC_NVRAM_START + 9)	<span class="comment">/* low byte; RTC off. 0x17 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXTHI	(MC_NVRAM_START + 10)	<span class="comment">/* high byte; RTC off. 0x18 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NVRAM bytes 38 and 39: extended memory size (between 16MB and 4G) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXT16LO	(MC_NVRAM_START + 38)	<span class="comment">/* low byte; RTC off. 0x34 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NVRAM_EXT16HI	(MC_NVRAM_START + 39)	<span class="comment">/* high byte; RTC off. 0x35 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">mc146818_read</span><span class="params">(<span class="type">unsigned</span> reg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mc146818_write</span><span class="params">(<span class="type">unsigned</span> reg, <span class="type">unsigned</span> datum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">// !JOS_KERN_KCLOCK_H</span></span></span><br></pre></td></tr></table></figure>



<h3 id="kern-x2F-kclock-c"><a href="#kern-x2F-kclock-c" class="headerlink" title="kern&#x2F;kclock.c"></a>kern&#x2F;kclock.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为了读取现实时间用的硬件交互代码. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/kclock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span></span><br><span class="line"><span class="title function_">mc146818_read</span><span class="params">(<span class="type">unsigned</span> reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	outb(IO_RTC, reg);</span><br><span class="line">	<span class="keyword">return</span> inb(IO_RTC+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mc146818_write</span><span class="params">(<span class="type">unsigned</span> reg, <span class="type">unsigned</span> datum)</span></span><br><span class="line">&#123;</span><br><span class="line">	outb(IO_RTC, reg);</span><br><span class="line">	outb(IO_RTC+<span class="number">1</span>, datum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="inc-x2F-mmu-h"><a href="#inc-x2F-mmu-h" class="headerlink" title="inc&#x2F;mmu.h"></a>inc&#x2F;mmu.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_INC_MMU_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_INC_MMU_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个文件定义了x86下的内存管理单元：内存（访问，切换）处理逻辑，内存分配在pmap.c里，sd</span></span><br><span class="line"><span class="comment"> * 包括了使用页表映射，和段相关的数据结构和算法,</span></span><br><span class="line"><span class="comment"> * 还有%cr0, %cr4, and %eflags寄存器，还有中断.</span></span><br><span class="line"><span class="comment"> * 代码书写分为：Part1/Part2/Part3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Part 1.  给定虚址，在虚拟页表，PageInfo，空闲表中，映射处理的所需要的数据结构和算法.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟地址&#x27;la&#x27;根据实际情况划分成三个部分:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | 页目录偏移       |      页表偏移   | 页内偏移             |</span></span><br><span class="line"><span class="comment">// |                |                |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \---------- PGNUM(la) ----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.</span></span><br><span class="line"><span class="comment">// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span></span><br><span class="line"><span class="comment">// use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page number field of address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGNUM(la)	(((uintptr_t) (la)) &gt;&gt; PTXSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page directory index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(la)		((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page table index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(la)		((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// offset in page</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGOFF(la)	(((uintptr_t) (la)) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct linear address from indexes and offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGADDR(d, t, o)	((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Page directory and page table constants.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPDENTRIES	1024		<span class="comment">// page directory entries per page directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPTENTRIES	1024		<span class="comment">// page table entries per page table</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE		4096		<span class="comment">// bytes mapped by a page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT		12		<span class="comment">// log2(PGSIZE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTSIZE		(PGSIZE*NPTENTRIES) <span class="comment">// bytes mapped by a page directory entry</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTSHIFT		22		<span class="comment">// log2(PTSIZE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTXSHIFT	12		<span class="comment">// offset of PTX in a linear address</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDXSHIFT	22		<span class="comment">// offset of PDX in a linear address</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页表/页目录存放的项的flags部分.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_P		0x001	<span class="comment">// Present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W		0x002	<span class="comment">// 可写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U		0x004	<span class="comment">// 用户</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PWT		0x008	<span class="comment">// 直写：无缓存下使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PCD		0x010	<span class="comment">// 禁用cache</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A		0x020	<span class="comment">// 可访问</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D		0x040	<span class="comment">// 脏标：配合回写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PS		0x080	<span class="comment">// 页大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G		0x100	<span class="comment">// 全局</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The PTE_AVAIL bits aren&#x27;t used by the kernel or interpreted by the</span></span><br><span class="line"><span class="comment">// hardware, so user processes are allowed to set them arbitrarily.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_AVAIL	0xE00	<span class="comment">// Available for software use</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags in PTE_SYSCALL may be used in system calls.  (Others may not.)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address in page table or page directory entry</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte)	((physaddr_t) (pte) &amp; ~0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Control Register flags</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_PE		0x00000001	<span class="comment">// Protection Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_MP		0x00000002	<span class="comment">// Monitor coProcessor</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_EM		0x00000004	<span class="comment">// Emulation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_TS		0x00000008	<span class="comment">// Task Switched</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_ET		0x00000010	<span class="comment">// Extension Type</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_NE		0x00000020	<span class="comment">// Numeric Errror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_WP		0x00010000	<span class="comment">// Write Protect</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_AM		0x00040000	<span class="comment">// Alignment Mask</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_NW		0x20000000	<span class="comment">// Not Writethrough</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_CD		0x40000000	<span class="comment">// Cache Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR0_PG		0x80000000	<span class="comment">// Paging</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PCE		0x00000100	<span class="comment">// Performance counter enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_MCE		0x00000040	<span class="comment">// Machine Check Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PSE		0x00000010	<span class="comment">// Page Size Extensions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_DE		0x00000008	<span class="comment">// Debugging Extensions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_TSD		0x00000004	<span class="comment">// Time Stamp Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_PVI		0x00000002	<span class="comment">// Protected-Mode Virtual Interrupts</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CR4_VME		0x00000001	<span class="comment">// V86 Mode Extensions</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eflags register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_CF		0x00000001	<span class="comment">// Carry Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_PF		0x00000004	<span class="comment">// Parity Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_AF		0x00000010	<span class="comment">// Auxiliary carry Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_ZF		0x00000040	<span class="comment">// Zero Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_SF		0x00000080	<span class="comment">// Sign Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_TF		0x00000100	<span class="comment">// Trap Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IF		0x00000200	<span class="comment">// Interrupt Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_DF		0x00000400	<span class="comment">// Direction Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_OF		0x00000800	<span class="comment">// Overflow Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_MASK	0x00003000	<span class="comment">// I/O Privilege Level bitmask</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_0	0x00000000	<span class="comment">//   IOPL == 0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_1	0x00001000	<span class="comment">//   IOPL == 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_2	0x00002000	<span class="comment">//   IOPL == 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_IOPL_3	0x00003000	<span class="comment">//   IOPL == 3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_NT		0x00004000	<span class="comment">// Nested Task</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_RF		0x00010000	<span class="comment">// Resume Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_VM		0x00020000	<span class="comment">// Virtual 8086 mode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_AC		0x00040000	<span class="comment">// Alignment Check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_VIF		0x00080000	<span class="comment">// Virtual Interrupt Flag</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_VIP		0x00100000	<span class="comment">// Virtual Interrupt Pending</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FL_ID		0x00200000	<span class="comment">// ID flag</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页错误的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEC_PR		0x1	<span class="comment">// Page fault caused by protection violation</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEC_WR		0x2	<span class="comment">// Page fault caused by a write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEC_U		0x4	<span class="comment">// Page fault occured while in user mode</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Part 2.  段相关的数据结构和算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 汇编代码：宏定义的GDT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_NULL						\</span></span><br><span class="line"><span class="meta">	.word 0, 0;						\</span></span><br><span class="line"><span class="meta">	.byte 0, 0, 0, 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG(type,base,lim)					\</span></span><br><span class="line"><span class="meta">	.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);	\</span></span><br><span class="line"><span class="meta">	.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),		\</span></span><br><span class="line"><span class="meta">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">// not __ASSEMBLER__</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Segment Descriptors</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> sd_lim_15_0 : <span class="number">16</span>;  <span class="comment">// Low bits of segment limit</span></span><br><span class="line">	<span class="type">unsigned</span> sd_base_15_0 : <span class="number">16</span>; <span class="comment">// Low bits of segment base address</span></span><br><span class="line">	<span class="type">unsigned</span> sd_base_23_16 : <span class="number">8</span>; <span class="comment">// Middle bits of segment base address</span></span><br><span class="line">	<span class="type">unsigned</span> sd_type : <span class="number">4</span>;       <span class="comment">// Segment type (see STS_ constants)</span></span><br><span class="line">	<span class="type">unsigned</span> sd_s : <span class="number">1</span>;          <span class="comment">// 0 = system, 1 = application</span></span><br><span class="line">	<span class="type">unsigned</span> sd_dpl : <span class="number">2</span>;        <span class="comment">// Descriptor Privilege Level</span></span><br><span class="line">	<span class="type">unsigned</span> sd_p : <span class="number">1</span>;          <span class="comment">// Present</span></span><br><span class="line">	<span class="type">unsigned</span> sd_lim_19_16 : <span class="number">4</span>;  <span class="comment">// High bits of segment limit</span></span><br><span class="line">	<span class="type">unsigned</span> sd_avl : <span class="number">1</span>;        <span class="comment">// Unused (available for software use)</span></span><br><span class="line">	<span class="type">unsigned</span> sd_rsv1 : <span class="number">1</span>;       <span class="comment">// Reserved</span></span><br><span class="line">	<span class="type">unsigned</span> sd_db : <span class="number">1</span>;         <span class="comment">// 0 = 16-bit segment, 1 = 32-bit segment</span></span><br><span class="line">	<span class="type">unsigned</span> sd_g : <span class="number">1</span>;          <span class="comment">// Granularity: limit scaled by 4K when set</span></span><br><span class="line">	<span class="type">unsigned</span> sd_base_31_24 : <span class="number">8</span>; <span class="comment">// High bits of segment base address</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 空段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_NULL	&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;</span></span><br><span class="line"><span class="comment">// 错误段：可加载，但是不能用，会出错</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG_FAULT	&#123; 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 &#125;</span></span><br><span class="line"><span class="comment">// 正常段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG(type, base, lim, dpl) 					\</span></span><br><span class="line"><span class="meta">&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff,	\</span></span><br><span class="line"><span class="meta">    type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1,		\</span></span><br><span class="line"><span class="meta">    (unsigned) (base) &gt;&gt; 24 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEG16(type, base, lim, dpl) (struct Segdesc)			\</span></span><br><span class="line"><span class="meta">&#123; (lim) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff,		\</span></span><br><span class="line"><span class="meta">    type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 16, 0, 0, 1, 0,		\</span></span><br><span class="line"><span class="meta">    (unsigned) (base) &gt;&gt; 24 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 段类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_X		0x8	    <span class="comment">// 可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_E		0x4	    <span class="comment">// Expand down (non-executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_C		0x4	    <span class="comment">// Conforming code segment (executable only)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_W		0x2	    <span class="comment">// Writeable (non-executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_R		0x2	    <span class="comment">// Readable (executable segments)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_A		0x1	    <span class="comment">// Accessed</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System segment type bits</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T16A	0x1	    <span class="comment">// Available 16-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_LDT		0x2	    <span class="comment">// Local Descriptor Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T16B	0x3	    <span class="comment">// Busy 16-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_CG16	0x4	    <span class="comment">// 16-bit Call Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG		0x5	    <span class="comment">// Task Gate / Coum Transmitions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG16	0x6	    <span class="comment">// 16-bit Interrupt Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG16	0x7	    <span class="comment">// 16-bit Trap Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T32A	0x9	    <span class="comment">// Available 32-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_T32B	0xB	    <span class="comment">// Busy 32-bit TSS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_CG32	0xC	    <span class="comment">// 32-bit Call Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32	0xE	    <span class="comment">// 32-bit Interrupt Gate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32	0xF	    <span class="comment">// 32-bit Trap Gate</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Part 3.  中断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task state segment format (as described by the Pentium architecture book)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> ts_link;	<span class="comment">// Old ts selector</span></span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp0;	<span class="comment">// Stack pointers and segment selectors</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_ss0;	<span class="comment">//   after an increase in privilege level</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_padding1;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp1;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ss1;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding2;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp2;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ss2;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding3;</span><br><span class="line">	<span class="type">physaddr_t</span> ts_cr3;	<span class="comment">// Page directory base</span></span><br><span class="line">	<span class="type">uintptr_t</span> ts_eip;	<span class="comment">// Saved state from last task switch</span></span><br><span class="line">	<span class="type">uint32_t</span> ts_eflags;</span><br><span class="line">	<span class="type">uint32_t</span> ts_eax;	<span class="comment">// More saved state (registers)</span></span><br><span class="line">	<span class="type">uint32_t</span> ts_ecx;</span><br><span class="line">	<span class="type">uint32_t</span> ts_edx;</span><br><span class="line">	<span class="type">uint32_t</span> ts_ebx;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_esp;</span><br><span class="line">	<span class="type">uintptr_t</span> ts_ebp;</span><br><span class="line">	<span class="type">uint32_t</span> ts_esi;</span><br><span class="line">	<span class="type">uint32_t</span> ts_edi;</span><br><span class="line">	<span class="type">uint16_t</span> ts_es;		<span class="comment">// Even more saved state (segment selectors)</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_padding4;</span><br><span class="line">	<span class="type">uint16_t</span> ts_cs;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding5;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ss;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding6;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ds;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding7;</span><br><span class="line">	<span class="type">uint16_t</span> ts_fs;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding8;</span><br><span class="line">	<span class="type">uint16_t</span> ts_gs;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding9;</span><br><span class="line">	<span class="type">uint16_t</span> ts_ldt;</span><br><span class="line">	<span class="type">uint16_t</span> ts_padding10;</span><br><span class="line">	<span class="type">uint16_t</span> <span class="type">ts_t</span>;		<span class="comment">// Trap on task switch</span></span><br><span class="line">	<span class="type">uint16_t</span> ts_iomb;	<span class="comment">// I/O map base address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断门描述符：interrupts and traps的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gatedesc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> gd_off_15_0 : <span class="number">16</span>;   <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">	<span class="type">unsigned</span> gd_sel : <span class="number">16</span>;        <span class="comment">// segment selector</span></span><br><span class="line">	<span class="type">unsigned</span> gd_args : <span class="number">5</span>;        <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">	<span class="type">unsigned</span> gd_rsv1 : <span class="number">3</span>;        <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">	<span class="type">unsigned</span> gd_type : <span class="number">4</span>;        <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">	<span class="type">unsigned</span> gd_s : <span class="number">1</span>;           <span class="comment">// must be 0 (system)</span></span><br><span class="line">	<span class="type">unsigned</span> gd_dpl : <span class="number">2</span>;         <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">	<span class="type">unsigned</span> gd_p : <span class="number">1</span>;           <span class="comment">// Present</span></span><br><span class="line">	<span class="type">unsigned</span> gd_off_31_16 : <span class="number">16</span>;  <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 interrupt/trap  门描述符.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF.&quot;</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//	  the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//	  this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;		\</span></span><br><span class="line"><span class="meta">	(gate).gd_sel = (sel);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_args = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_rsv1 = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span></span><br><span class="line"><span class="meta">	(gate).gd_s = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_dpl = (dpl);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_p = 1;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up a call gate descriptor.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETCALLGATE(gate, sel, off, dpl)           	        \</span></span><br><span class="line"><span class="meta">&#123;								\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;		\</span></span><br><span class="line"><span class="meta">	(gate).gd_sel = (sel);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_args = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_rsv1 = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_type = STS_CG32;				\</span></span><br><span class="line"><span class="meta">	(gate).gd_s = 0;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_dpl = (dpl);					\</span></span><br><span class="line"><span class="meta">	(gate).gd_p = 1;					\</span></span><br><span class="line"><span class="meta">	(gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pseudo-descriptors used for LGDT, LLDT and LIDT instructions.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pseudodesc</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> pd_lim;		<span class="comment">// Limit</span></span><br><span class="line">	<span class="type">uint32_t</span> pd_base;		<span class="comment">// Base address</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !JOS_INC_MMU_H */</span></span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://sakura-mac.github.io/2024/03/08/lab2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mit-6-828/" rel="tag">Mit-6.828</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/03/08/lab3%EF%BC%9APartA/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            lab3：用户环境(PartA)
          
        </div>
      </a>
    
    
      <a href="/2024/03/08/lab1/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">实验1：汇编，工具和引导</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "bbzBMY2PHFRlbkSCorlYCrRX-gzGzoHsz",
    app_key: "NMnT9uDCzg2rW4ckm0fpSm5y",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "请留下你此刻脑海中的想法~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2024
        <i class="ri-heart-fill heart_icon"></i> 环烷烃
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.jpg" alt="海猫栖息地"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/player/">播放器</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>

    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>我很可爱，请我喝一瓶怡宝吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":80,"vOffset":-50},"mobile":{"show":true},"log":false});</script></body>

</html>